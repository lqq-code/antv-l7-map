(self["webpackChunkxboilerplate"] = self["webpackChunkxboilerplate"] || []).push([["mf-dep_vendors-node_modules_antv_l7_es_index_js"],{

/***/ "./node_modules/@antv/l7-component/es/control/BaseControl.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/control/BaseControl.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PositionType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.PositionType; },
/* harmony export */   "default": function() { return /* binding */ Control; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_9__);








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var controlId = 0;

var Control = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Control, _EventEmitter);

  var _super = _createSuper(Control);

  function Control(cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Control);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "controlOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "container", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sceneContainer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mapsService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "renderService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "controlService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "isShow", void 0);

    _this.controlOption = _objectSpread(_objectSpread({}, _this.getDefault()), cfg || {});
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Control, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        position: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.PositionType.TOPRIGHT,
        name: "".concat(controlId++)
      };
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.PositionType.BOTTOMRIGHT;
      var controlService = this.controlService;

      if (controlService) {
        controlService.removeControl(this);
      }

      this.controlOption.position = position;

      if (controlService) {
        controlService.addControl(this, this.sceneContainer);
      }

      return this;
    }
  }, {
    key: "addTo",
    value: function addTo(sceneContainer) {
      this.mapsService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IMapService);
      this.renderService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IRendererService);
      this.layerService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.ILayerService);
      this.controlService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IControlService);
      this.sceneContainer = sceneContainer;
      this.isShow = true;
      this.container = this.onAdd();
      var container = this.container;
      var pos = this.controlOption.position;
      var corner = this.controlService.controlCorners[pos];
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.addClass(container, 'l7-control');

      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }

      return this;
    }
  }, {
    key: "onAdd",
    value: function onAdd() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "hide",
    value: function hide() {
      var container = this.container;
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.addClass(container, 'l7-control-hide');
      this.isShow = false;
    }
  }, {
    key: "show",
    value: function show() {
      var container = this.container;
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.removeClass(container, 'l7-control-hide');
      this.isShow = true;
    }
  }, {
    key: "remove",
    value: function remove() {
      if (!this.mapsService) {
        return this;
      }

      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.remove(this.container);
      this.onRemove();
    }
  }, {
    key: "_refocusOnMap",
    value: function _refocusOnMap(e) {
      if (this.mapsService && e && e.screenX > 0 && e.screenY > 0) {
        var container = this.mapsService.getContainer();

        if (container !== null) {
          container.focus();
        }
      }
    }
  }]);

  return Control;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_9__.EventEmitter);


//# sourceMappingURL=BaseControl.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/control/layer.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/control/layer.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Layers; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _BaseControl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BaseControl */ "./node_modules/@antv/l7-component/es/control/BaseControl.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Layers = function (_Control) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Layers, _Control);

  var _super = _createSuper(Layers);

  function Layers(cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Layers);

    _this = _super.call(this, cfg);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "layerControlInputs", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "layers", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "lastZIndex", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "handlingClick", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "layersLink", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "baseLayersList", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "separator", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "overlaysList", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "form", void 0);

    _this.layerControlInputs = [];
    _this.layers = [];
    _this.lastZIndex = 0;
    _this.handlingClick = false;

    _this.initLayers();

    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.bindAll)(['checkDisabledLayers', 'onLayerChange', 'collapse', 'extend', 'expand', 'onInputClick'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Layers, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        collapsed: true,
        position: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.PositionType.TOPRIGHT,
        autoZIndex: true,
        hideSingleBase: false,
        sortLayers: false,
        name: 'layers'
      };
    }
  }, {
    key: "onAdd",
    value: function onAdd() {
      var _this2 = this;

      this.initLayout();
      this.update();
      this.mapsService.on('zoomend', this.checkDisabledLayers);
      this.layers.forEach(function (layerItem) {
        layerItem.layer.on('remove', _this2.onLayerChange);
        layerItem.layer.on('add', _this2.onLayerChange);
      });
      return this.container;
    }
  }, {
    key: "addVisualLayer",
    value: function addVisualLayer(layer, name) {
      this.addLayer(layer, name, true);
      return this.mapsService ? this.update() : this;
    }
  }, {
    key: "expand",
    value: function expand() {
      var _this$renderService$g = this.renderService.getViewportSize(),
          height = _this$renderService$g.height;

      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.addClass(this.container, 'l7-control-layers-expanded');
      this.form.style.height = 'null';
      var acceptableHeight = height - (this.container.offsetTop + 50);

      if (acceptableHeight < this.form.clientHeight) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.addClass(this.form, 'l7-control-layers-scrollbar');
        this.form.style.height = acceptableHeight + 'px';
      } else {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.removeClass(this.form, 'l7-control-layers-scrollbar');
      }

      this.checkDisabledLayers();
      return this;
    }
  }, {
    key: "collapse",
    value: function collapse() {
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.removeClass(this.container, 'l7-control-layers-expanded');
      return this;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      var _this3 = this;

      if (!this.mapsService) {
        return;
      }

      this.mapsService.off('click', this.collapse);
      this.layers.forEach(function (layerItem) {
        layerItem.layer.off('remove', _this3.onLayerChange);
        layerItem.layer.off('add', _this3.onLayerChange);
      });
    }
  }, {
    key: "initLayout",
    value: function initLayout() {
      var className = 'l7-control-layers';
      var container = this.container = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div', className);
      var collapsed = this.controlOption.collapsed;
      container.setAttribute('aria-haspopup', 'true');
      var form = this.form = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('form', className + '-list');

      if (collapsed) {
        this.mapsService.on('click', this.collapse);
        container.addEventListener('mouseenter', this.expand);
        container.addEventListener('mouseleave', this.collapse);
      }

      this.layersLink = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('a', className + '-toggle', container);
      var link = this.layersLink;
      link.title = 'Layers';

      if (!collapsed) {
        this.expand();
      }

      this.baseLayersList = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div', className + '-base', form);
      this.separator = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div', className + '-separator', form);
      this.overlaysList = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div', className + '-overlays', form);
      container.appendChild(form);
    }
  }, {
    key: "initLayers",
    value: function initLayers() {
      var _this4 = this;

      var _this$controlOption = this.controlOption,
          _this$controlOption$b = _this$controlOption.baseLayers,
          baseLayers = _this$controlOption$b === void 0 ? {} : _this$controlOption$b,
          _this$controlOption$o = _this$controlOption.overlayers,
          overlayers = _this$controlOption$o === void 0 ? {} : _this$controlOption$o;
      Object.keys(baseLayers).forEach(function (name, index) {
        _this4.addLayer(baseLayers[name], name, false);
      });
      Object.keys(overlayers).forEach(function (name, index) {
        _this4.addLayer(overlayers[name], name, true);
      });
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.container) {
        return this;
      }

      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.empty(this.baseLayersList);
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.empty(this.overlaysList);
      this.layerControlInputs = [];
      var baseLayersPresent;
      var overlaysPresent;
      var i;
      var obj;
      var baseLayersCount = 0;

      for (i = 0; i < this.layers.length; i++) {
        obj = this.layers[i];
        this.addItem(obj);
        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      }

      if (this.controlOption.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this.baseLayersList.style.display = baseLayersPresent ? '' : 'none';
      }

      this.separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
      return this;
    }
  }, {
    key: "checkDisabledLayers",
    value: function checkDisabledLayers() {
      var inputs = this.layerControlInputs;
      var input;
      var layer;
      var zoom = this.mapsService.getZoom();

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this.layerService.getLayer(input.layerId);

        if (layer && layer.inited) {
          var minZoom = layer.getMinZoom();
          var maxZoom = layer.getMaxZoom();
          input.disabled = zoom < minZoom || zoom > maxZoom;
        }
      }
    }
  }, {
    key: "addLayer",
    value: function addLayer(layer, name, overlay) {
      if (this.mapsService) {
        layer.on('add', this.onLayerChange);
        layer.on('remove', this.onLayerChange);
      }

      this.layers.push({
        layer: layer,
        name: name,
        overlay: overlay
      });
      var _this$controlOption2 = this.controlOption,
          sortLayers = _this$controlOption2.sortLayers,
          sortFunction = _this$controlOption2.sortFunction,
          autoZIndex = _this$controlOption2.autoZIndex;

      if (sortLayers) {
        this.layers.sort(function (a, b) {
          return sortFunction(a.layer, b.layer, a.name, b.name);
        });
      }

      if (autoZIndex && layer.setZIndex) {
        this.lastZIndex++;
        layer.setZIndex(this.lastZIndex);
      }

      this.expandIfNotCollapsed();
    }
  }, {
    key: "expandIfNotCollapsed",
    value: function expandIfNotCollapsed() {
      if (this.mapsService && !this.controlOption.collapsed) {
        this.expand();
      }

      return this;
    }
  }, {
    key: "onLayerChange",
    value: function onLayerChange(e) {
      if (!this.handlingClick) {
        this.update();
      }

      var obj = this.layerService.getLayer(e.target.layerId);
      var type = obj !== null && obj !== void 0 && obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

      if (type) {
        this.emit(type, obj);
      }
    }
  }, {
    key: "createRadioElement",
    value: function createRadioElement(name, checked) {
      var radioHtml = '<input type="radio" class="l7-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    }
  }, {
    key: "addItem",
    value: function addItem(obj) {
      var label = document.createElement('label');
      var layer = this.layerService.getLayer(obj.layer.id);
      var checked = layer && layer.inited && obj.layer.isVisible();
      var input;

      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'l7-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this.createRadioElement('l7-base-layers', checked);
      }

      this.layerControlInputs.push(input);
      input.layerId = obj.layer.id;
      input.addEventListener('click', this.onInputClick);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name;
      var holder = document.createElement('div');
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);
      var container = obj.overlay ? this.overlaysList : this.baseLayersList;
      container.appendChild(label);
      this.checkDisabledLayers();
      return label;
    }
  }, {
    key: "onInputClick",
    value: function onInputClick() {
      var inputs = this.layerControlInputs;
      var input;
      var layer;
      var addedLayers = [];
      var removedLayers = [];
      this.handlingClick = true;

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this.layerService.getLayer(input.layerId);

        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      }

      removedLayers.forEach(function (l) {
        l.hide();
      });
      addedLayers.forEach(function (l) {
        l.show();
      });
      this.handlingClick = false;
    }
  }]);

  return Layers;
}(_BaseControl__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=layer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/control/logo.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/control/logo.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Logo; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _BaseControl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BaseControl */ "./node_modules/@antv/l7-component/es/control/BaseControl.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var Logo = function (_Control) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(Logo, _Control);

  var _super = _createSuper(Logo);

  function Logo() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Logo);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Logo, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        position: _BaseControl__WEBPACK_IMPORTED_MODULE_6__.PositionType.BOTTOMLEFT,
        name: 'logo'
      };
    }
  }, {
    key: "onAdd",
    value: function onAdd() {
      var className = 'l7-control-logo';
      var container = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.DOM.create('div', className);
      var anchor = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.DOM.create('a', 'l7-ctrl-logo');
      anchor.target = '_blank';
      anchor.rel = 'noopener nofollow';
      anchor.href = 'https://antv.alipay.com/l7';
      anchor.setAttribute('aria-label', 'AntV logo');
      anchor.setAttribute('rel', 'noopener nofollow');
      container.appendChild(anchor);
      return container;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      return null;
    }
  }]);

  return Logo;
}(_BaseControl__WEBPACK_IMPORTED_MODULE_6__.default);


//# sourceMappingURL=logo.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/control/scale.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/control/scale.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Scale; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _BaseControl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseControl */ "./node_modules/@antv/l7-component/es/control/BaseControl.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var Scale = function (_Control) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Scale, _Control);

  var _super = _createSuper(Scale);

  function Scale(cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Scale);

    _this = _super.call(this, cfg);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mScale", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "iScale", void 0);

    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.bindAll)(['update'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Scale, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        position: _BaseControl__WEBPACK_IMPORTED_MODULE_8__.PositionType.BOTTOMLEFT,
        maxWidth: 100,
        metric: true,
        updateWhenIdle: false,
        imperial: false,
        name: 'scale'
      };
    }
  }, {
    key: "onAdd",
    value: function onAdd() {
      var className = 'l7-control-scale';
      var container = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.create('div', className);
      this.addScales(className + '-line', container);
      var updateWhenIdle = this.controlOption.updateWhenIdle;
      this.mapsService.on(updateWhenIdle ? 'moveend' : 'mapmove', this.update);
      this.mapsService.on(updateWhenIdle ? 'zoomend' : 'zoomchange', this.update);
      this.update();
      return container;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      var updateWhenIdle = this.controlOption.updateWhenIdle;
      this.mapsService.off(updateWhenIdle ? 'zoomend' : 'zoomchange', this.update);
      this.mapsService.off(updateWhenIdle ? 'moveend' : 'mapmove', this.update);
    }
  }, {
    key: "update",
    value: function update() {
      var mapsService = this.mapsService;
      var maxWidth = this.controlOption.maxWidth;
      var y = mapsService.getSize()[1] / 2;
      var p1 = mapsService.containerToLngLat([0, y]);
      var p2 = mapsService.containerToLngLat([maxWidth, y]);
      var maxMeters = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.lnglatDistance)([p1.lng, p1.lat], [p2.lng, p2.lat]);
      this.updateScales(maxMeters);
    }
  }, {
    key: "updateScales",
    value: function updateScales(maxMeters) {
      var _this$controlOption = this.controlOption,
          metric = _this$controlOption.metric,
          imperial = _this$controlOption.imperial;

      if (metric && maxMeters) {
        this.updateMetric(maxMeters);
      }

      if (imperial && maxMeters) {
        this.updateImperial(maxMeters);
      }
    }
  }, {
    key: "updateMetric",
    value: function updateMetric(maxMeters) {
      var meters = this.getRoundNum(maxMeters);
      var label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';
      this.updateScale(this.mScale, label, meters / maxMeters);
    }
  }, {
    key: "updateImperial",
    value: function updateImperial(maxMeters) {
      var maxFeet = maxMeters * 3.2808399;
      var maxMiles;
      var miles;
      var feet;

      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this.getRoundNum(maxMiles);
        this.updateScale(this.iScale, miles + ' mi', miles / maxMiles);
      } else {
        feet = this.getRoundNum(maxFeet);
        this.updateScale(this.iScale, feet + ' ft', feet / maxFeet);
      }
    }
  }, {
    key: "updateScale",
    value: function updateScale(scale, text, ratio) {
      var maxWidth = this.controlOption.maxWidth;
      scale.style.width = Math.round(maxWidth * ratio) + 'px';
      scale.innerHTML = text;
    }
  }, {
    key: "getRoundNum",
    value: function getRoundNum(num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
      var d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  }, {
    key: "addScales",
    value: function addScales(className, container) {
      var _this$controlOption2 = this.controlOption,
          metric = _this$controlOption2.metric,
          imperial = _this$controlOption2.imperial;

      if (metric) {
        this.mScale = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.create('div', className, container);
      }

      if (imperial) {
        this.iScale = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.create('div', className, container);
      }
    }
  }]);

  return Scale;
}(_BaseControl__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=scale.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/control/zoom.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/control/zoom.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Zoom; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _BaseControl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseControl */ "./node_modules/@antv/l7-component/es/control/BaseControl.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var Zoom = function (_Control) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Zoom, _Control);

  var _super = _createSuper(Zoom);

  function Zoom(cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Zoom);

    _this = _super.call(this, cfg);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "disabled", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "zoomInButton", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "zoomOutButton", void 0);

    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.bindAll)(['updateDisabled', 'zoomIn', 'zoomOut'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Zoom, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        position: _BaseControl__WEBPACK_IMPORTED_MODULE_8__.PositionType.TOPLEFT,
        zoomInText: '+',
        zoomInTitle: 'Zoom in',
        zoomOutText: '&#x2212;',
        zoomOutTitle: 'Zoom out',
        name: 'zoom'
      };
    }
  }, {
    key: "onAdd",
    value: function onAdd() {
      var zoomName = 'l7-control-zoom';
      var container = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.create('div', zoomName + ' l7-bar');
      this.zoomInButton = this.createButton(this.controlOption.zoomInText, this.controlOption.zoomInTitle, zoomName + '-in', container, this.zoomIn);
      this.zoomOutButton = this.createButton(this.controlOption.zoomOutText, this.controlOption.zoomOutTitle, zoomName + '-out', container, this.zoomOut);
      this.mapsService.on('zoomend', this.updateDisabled);
      this.mapsService.on('zoomchange', this.updateDisabled);
      this.updateDisabled();
      return container;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.mapsService.off('zoomend', this.updateDisabled);
      this.mapsService.off('zoomchange', this.updateDisabled);
    }
  }, {
    key: "disable",
    value: function disable() {
      this.disabled = true;
      this.updateDisabled();
      return this;
    }
  }, {
    key: "enable",
    value: function enable() {
      this.disabled = false;
      this.updateDisabled();
      return this;
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      if (!this.disabled && this.mapsService.getZoom() < this.mapsService.getMaxZoom()) {
        this.mapsService.zoomIn();
      }
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      if (!this.disabled && this.mapsService.getZoom() > this.mapsService.getMinZoom()) {
        this.mapsService.zoomOut();
      }
    }
  }, {
    key: "createButton",
    value: function createButton(html, tile, className, container, fn) {
      var link = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.create('a', className, container);
      link.innerHTML = html;
      link.title = tile;
      link.href = 'javascript:void(0)';
      link.addEventListener('click', fn);
      return link;
    }
  }, {
    key: "updateDisabled",
    value: function updateDisabled() {
      var mapsService = this.mapsService;
      var className = 'l7-disabled';
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.removeClass(this.zoomInButton, className);
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.removeClass(this.zoomOutButton, className);

      if (this.disabled || mapsService.getZoom() <= mapsService.getMinZoom()) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.addClass(this.zoomOutButton, className);
      }

      if (this.disabled || mapsService.getZoom() >= mapsService.getMaxZoom()) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.addClass(this.zoomInButton, className);
      }
    }
  }]);

  return Zoom;
}(_BaseControl__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=zoom.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Control": function() { return /* reexport safe */ _control_BaseControl__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "Logo": function() { return /* reexport safe */ _control_logo__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "Scale": function() { return /* reexport safe */ _control_scale__WEBPACK_IMPORTED_MODULE_3__.default; },
/* harmony export */   "Zoom": function() { return /* reexport safe */ _control_zoom__WEBPACK_IMPORTED_MODULE_4__.default; },
/* harmony export */   "Layers": function() { return /* reexport safe */ _control_layer__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "Marker": function() { return /* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_5__.default; },
/* harmony export */   "Popup": function() { return /* reexport safe */ _popup__WEBPACK_IMPORTED_MODULE_7__.default; },
/* harmony export */   "MarkerLayer": function() { return /* reexport safe */ _marker_layer__WEBPACK_IMPORTED_MODULE_6__.default; }
/* harmony export */ });
/* harmony import */ var _control_BaseControl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control/BaseControl */ "./node_modules/@antv/l7-component/es/control/BaseControl.js");
/* harmony import */ var _control_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/layer */ "./node_modules/@antv/l7-component/es/control/layer.js");
/* harmony import */ var _control_logo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./control/logo */ "./node_modules/@antv/l7-component/es/control/logo.js");
/* harmony import */ var _control_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control/scale */ "./node_modules/@antv/l7-component/es/control/scale.js");
/* harmony import */ var _control_zoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./control/zoom */ "./node_modules/@antv/l7-component/es/control/zoom.js");
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./marker */ "./node_modules/@antv/l7-component/es/marker.js");
/* harmony import */ var _marker_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./marker-layer */ "./node_modules/@antv/l7-component/es/marker-layer.js");
/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popup */ "./node_modules/@antv/l7-component/es/popup.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interface */ "./node_modules/@antv/l7-component/es/interface.js");









function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');

  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }

  if (!doc) doc = document;

  if (!doc) {
    return;
  }

  var head = doc.head || doc.getElementsByTagName('head')[0];

  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];

    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }

  var style = doc.createElement('style');
  style.type = 'text/css';

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }

  head.appendChild(style);
  return style;
}

loadStyles(".l7-marker-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: absolute;\n}\n\n.l7-marker {\n  position: absolute !important;\n  top: 0;\n  left: 0;\n  z-index: 5;\n  cursor: pointer;\n}\n\n.l7-marker-cluster {\n  background-clip: padding-box;\n  border-radius: 20px;\n  background-color: rgba(181, 226, 140, 0.6);\n  width: 40px;\n  height: 40px;\n}\n.l7-marker-cluster div {\n  width: 30px;\n  height: 30px;\n  margin-left: 5px;\n  margin-top: 5px;\n  text-align: center;\n  border-radius: 15px;\n  font: 12px 'Helvetica Neue', Arial, Helvetica, sans-serif;\n  background-color: rgba(110, 204, 57, 0.6);\n}\n.l7-marker-cluster span {\n  line-height: 30px;\n}\n\n.l7-popup-anchor-bottom,\n.l7-popup-anchor-bottom-left,\n.l7-popup-anchor-bottom-right {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: reverse;\n      -ms-flex-direction: column-reverse;\n          flex-direction: column-reverse;\n}\n\n.l7-popup-close-button {\n  position: absolute;\n  right: 0;\n  top: 0;\n  border: 0;\n  border-radius: 0 3px 0 0;\n  cursor: pointer;\n  background-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n/* layers control */\n\n.l7-control-layers {\n  -webkit-box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);\n  background: #fff;\n  border-radius: 5px;\n}\n.l7-popup-anchor-top,\n.l7-popup-anchor-top-left,\n.l7-popup-anchor-top-right {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.l7-popup-anchor-left {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n}\n\n.l7-popup-anchor-right {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: reverse;\n      -ms-flex-direction: row-reverse;\n          flex-direction: row-reverse;\n}\n.l7-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  will-change: transform;\n  pointer-events: none;\n  z-index: 5;\n}\n.l7-popup-tip {\n  width: 0;\n  height: 0;\n  border: 10px solid transparent;\n  z-index: 1;\n}\n.l7-popup-anchor-top .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-top: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-left .l7-popup-tip {\n  -webkit-align-self: flex-start;\n  -ms-flex-item-align: start;\n      align-self: flex-start;\n  border-top: none;\n  border-left: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-right .l7-popup-tip {\n  -webkit-align-self: flex-end;\n  -ms-flex-item-align: end;\n      align-self: flex-end;\n  border-top: none;\n  border-right: none;\n  border-bottom-color: #fff;\n}\n\n.l7-popup-anchor-bottom .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-bottom: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-tip {\n  -webkit-align-self: flex-start;\n  -ms-flex-item-align: start;\n      align-self: flex-start;\n  border-bottom: none;\n  border-left: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-tip {\n  -webkit-align-self: flex-end;\n  -ms-flex-item-align: end;\n      align-self: flex-end;\n  border-bottom: none;\n  border-right: none;\n  border-top-color: #fff;\n}\n\n.l7-popup-anchor-left .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-left: none;\n  border-right-color: #fff;\n}\n\n.l7-popup-anchor-right .l7-popup-tip {\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n      align-self: center;\n  border-right: none;\n  border-left-color: #fff;\n}\n\n.l7-popup-close-button {\n  position: absolute;\n  right: 0;\n  top: 0;\n  border: 0;\n  padding: 0;\n  font-size: 25px;\n  line-height: 20px;\n  border-radius: 0 3px 0 0;\n  cursor: pointer;\n  background-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n.l7-popup-anchor-top-left .l7-popup-content {\n  border-top-left-radius: 0;\n}\n\n.l7-popup-anchor-top-right .l7-popup-content {\n  border-top-right-radius: 0;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-content {\n  border-bottom-left-radius: 0;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-content {\n  border-bottom-right-radius: 0;\n}\n\n.l7-popup-track-pointer {\n  display: none;\n}\n\n.l7-popup-track-pointer * {\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n\n.l7-map:hover .l7-popup-track-pointer {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n}\n\n.l7-map:active .l7-popup-track-pointer {\n  display: none;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n/* general toolbar styles */\n\n.l7-bar {\n  -webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.3);\n          box-shadow: 0 0 1px rgba(0, 0, 0, 0.3);\n  border-radius: 4px;\n}\n.l7-bar a,\n.l7-bar a:hover {\n  background-color: #fff;\n  width: 30px;\n  height: 30px;\n  font-size: 20px;\n  display: block;\n  text-align: center;\n  text-decoration: none;\n  color: #8e9dab;\n}\n.l7-bar a,\n.l7-control-layers-toggle {\n  background-position: 50% 50%;\n  background-repeat: no-repeat;\n  display: block;\n}\n.l7-bar a:hover {\n  background-color: #f4f4f4;\n}\n.l7-bar a:first-child {\n  border-top-left-radius: 2px;\n  border-top-right-radius: 2px;\n}\n.l7-bar a:last-child {\n  border-bottom-left-radius: 2px;\n  border-bottom-right-radius: 2px;\n  border-bottom: none;\n}\n.l7-bar a.l7-disabled {\n  cursor: default;\n  background-color: #f4f4f4;\n  color: #bbb;\n}\n\n/* control positioning */\n\n.l7-control-container {\n  font: 12px/1.5 'Helvetica Neue', Arial, Helvetica, sans-serif;\n}\n.l7-control-hide {\n  display: none;\n}\n.l7-control {\n  position: relative;\n  z-index: 800;\n  pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\n  pointer-events: auto;\n}\n.l7-control {\n  float: left;\n  clear: both;\n}\n.l7-top,\n.l7-bottom {\n  position: absolute;\n  z-index: 1000;\n  pointer-events: none;\n}\n.l7-top {\n  top: 0;\n}\n.l7-right {\n  right: 0;\n}\n.l7-bottom {\n  bottom: 0;\n}\n.l7-left {\n  left: 0;\n}\n.l7-center {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: absolute;\n  -webkit-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n}\n.l7-bottom.l7-center,\n.l7-top.l7-center {\n  width: 100%;\n}\n.l7-right.l7-center,\n.l7-left.l7-center {\n  height: 100%;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.l7-top.l7-center,\n.l7-left.l7-center {\n  -webkit-box-align: start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n}\n\n.l7-bottom.l7-center,\n.l7-right.l7-center {\n  -webkit-box-align: end;\n      -ms-flex-align: end;\n          align-items: flex-end;\n}\n\n.l7-center .l7-control {\n  margin-right: 10px;\n  margin-bottom: 10px;\n}\n\n.l7-control {\n  float: left;\n  clear: both;\n}\n.l7-right .l7-control {\n  float: right;\n}\n.l7-top .l7-control {\n  margin-top: 10px;\n}\n.l7-bottom .l7-control {\n  margin-bottom: 10px;\n}\n.l7-left .l7-control {\n  margin-left: 10px;\n}\n.l7-right .l7-control {\n  margin-right: 10px;\n}\n\n/* attribution and scale controls */\n\n.l7-control-container .l7-control-attribution {\n  background: #fff;\n  background: rgba(59, 58, 58, 0.7);\n  margin: 0;\n}\n.l7-control-attribution,\n.l7-control-scale-line {\n  padding: 0 5px;\n  color: #333;\n}\n.l7-control-attribution a {\n  text-decoration: none;\n}\n.l7-control-attribution a:hover {\n  text-decoration: underline;\n}\n.l7-container .l7-control-attribution,\n.l7-container .l7-control-scale {\n  font-size: 11px;\n  padding: 5px 5px 2px 5px;\n  background: rgba(255, 255, 255, 0.7);\n}\n.l7-left .l7-control-scale {\n  margin-left: 5px;\n}\n.l7-bottom .l7-control-scale {\n  margin-bottom: 5px;\n}\n.l7-control-scale-line {\n  border: 2px solid #000;\n  border-top: none;\n  color: #000;\n  line-height: 1.1;\n  padding: 2px 5px 1px;\n  font-size: 11px;\n  white-space: nowrap;\n  overflow: hidden;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n\n  background: #fff;\n}\n.l7-control-scale-line:not(:first-child) {\n  border-top: 2px solid #777;\n  border-bottom: none;\n  margin-top: -2px;\n}\n.l7-control-scale-line:not(:first-child):not(:last-child) {\n  border-bottom: 2px solid #777;\n}\n\n.l7-touch .l7-control-attribution,\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n  -webkit-box-shadow: none;\n          box-shadow: none;\n}\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n  border: 2px solid rgba(0, 0, 0, 0.2);\n  background-clip: padding-box;\n}\n/*logo */\n\n.l7-ctrl-logo {\n  background-size: 100% 100%;\n  width: 89px;\n  height: 16px;\n  margin: 0 0 -3px -3px;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALIAAAAgCAYAAAHBIxK2AAAABGdBTUEAALGPC/xhBQAAIJZJREFUeAHtfAl8Tkf3/9z7PNmDRFbZSawhQcRSaqva1xCqpataqrT2UkuUUiqlaKtafe1VS1pUiypB0dIgIkpKRPZIELI/2/zO98akN48nltL3838//84nNzNzzpkzc+eee+bMOXMfxijNaMJ7LOrGO/HdYfZ8fb12gD2JJINJdR8WNHVQnRtSn7hilpz0u2DMKaEcFhZmhdzLNbiPyNVlwPxcm4Qh93Fr0gO4Ol5hfqiz6Q14G+QzGpYzQ9nXrUl7X/fgbrXdG3skX7m26+bNW2fQqJ5XmCs6RQKd6EQwB0zgtKgsvCidGF+N8wV/SBLqSKnXzx2WKIHw1xNxq2xtrKsBXqgrbePt1rivJFmloa5OoD129NcVQwa9Phxwaflw3ifvHCus1YIVjW7fwEF66dIhdYO/XV7Qk+9HY/5F7RA+w0G5TdRxq7gw10FBPWwA+3r9jpkYGcoJ5/7YiFxMiYCjLspsekOeCiJ1AhJJNER+8rfTX/j4BNcUMNCLMmhF+wC3cE9RZmMd/0IQjeTtGdwJjURD5EajsRQN1EwEHjAkUVce2LLhnKf8xGId3ZhkX4uxmj7MMKqJz0ZmMr3MJNZBmphV8WDBOCCgo+2QiE7DF3005wvU75e8vMLs4+P3HwwN7do5MzOu2NcjpPHRX/csCqjt2wvtxEAy8xJ3o+7j3jjkcurpn2xtrT0EPiS0oQPKSOfi/ygqL9H/qNbls8EXuer4+65xUa149QnBvGYFgapAN21EZ+pnuH3rrrnKdNA/zCRmjoqGzu36RoL21q38BLAAjRgo6iir63g1QAOcOoU27DAgwKtpPzVMKU+qBWIuve3Jx0zw4j/eQ0CASeNnjUi5mrYH72ZxUfFV0emJ479/BvrM9KxDAgZZEjziTp1d8+pL415sEdJloIAhF7QCZmnQoCkuLkkXNPfkozU8b4wVb30P4i4ADNQ41P08mtSBogHc27Vx70CPEHeUgRNwgUOuTqBR8wwODraGSIkrKipKxqVuI300mntri1jz9OOs0IHeHUdvms2t0iG+vn5nxmnan5QeUff6GGWttpidSjvGbCSZJdAAGTMwtjWSH2G5XrOp3oEv9wuWxqdeUPchZkW8OGqcedmcdujgUcMOH/zltmgL2YW2Fu22fbMz6q2xM+IEvmvHiCGyRq7AK3QLe959+T6v46co0uVBisLk0/9SqIIhcnQiVBPqULJ4dPVd2ypLg6Dx8wxuhAGDHrCOHTtqUfZ2b6KsYYIOuUiXL1/dKW4SMJRxkbbpG9nv5ecVutlt+PSoNvw7VPg8V4X5wqf4YQVp9g+NDQZDITr2cm/8lNIGlbvp+edGD/946eqJqOKmoBJRhjyjrclk0qlZAqeumw8YOEwE6ILdgh0raN9pcHeWx9n3mViPh9IKnlmBVBWI4bfoePDAEcOGPz9WWUDBzMe1cUdft5CnUfb2DvFR8rsz2avrkOdmT18wJisz5zDaqthVWjwAtzRgtBF9VbSdVofXIPWmB2CCouYqUBUFH59QbwwEqg0XykAi96/VuCEetRrm59msEfA+nqEtAUeqNEt324JGJEsDxpMi26gnaCpUxqJk6bahkGFp3akrZO8IBurcVGponpGW+VOdQP++uIAznzE1/cBBvRRZTc+OP0miUBJ78OiyxNxE6uX+KSP3vDIZuEE/z9BgWZZtHHj1oxZbkS6uJFNqIn+SWSy1AubjFtLd171xoHrQooyFQJRB7+0eHBrk2cxNtBW5mgYwoYNFXg5r7CvoFXWxajQ3mjiTc84wVkB2kTWt5NYk3lZ02SCvzphDDVrNZOY2p3mdA0wrhQoGSm5ig6SRyTsqwSxUaMKk+t4tXJIy4/IsoP82yNu7pYusKwk2WdslZmScvGHOyNs1tJ5GNrjVaeT2W2xsLCnuv5J6woQq/QtbXoLCMJqYtbWj208pKbGK4aamgWJR19XlCvpFEdxn6SDOl0byAjXB/cp8rlM/PteZ83k1T92PTuAw0Ly8GychmosWLB/v7xFSW+AeJQ/0auyLiYFEBgQ0dYKdDRsJfFOvpe0V76fgCVrgkNQTao63hAONr2vjFtAFltoTTFLzB415Al7RFdNipHRviWlLbzCHhZ05HxfEy9e7T/zX8FV+XLk+96e8Tl0xOJZfOpjdKp4kzboZXgGrouDj1rTunHnTQl1caoZ/unLNlKnTx32sNxobR0ZGakQTDCY8tEtEkG+LfihDg+NC2ccjpBXoyMTqVaLjTaFLduxe219XqH+67HYGKU5D0pbN30X5+vl0a9m6mZOPTxvFUIayPRAbM1RpS1uztp0a/SD6e9hcYlKVqgi7QEg/DAyRsAUsKSlNLyvT56Bs8e2Ias4LZzfnfEowJyOOVocZDs9jt8YnMDvUZzblZ+jis1rwtqg/KMHgwEThCUOCUS64U/An6iiL9oIGcFjwqMOQQB0JdTyEXd/tfR/1rMzsWCrPBxwPCxJMfJMELVYq0KO+fNkXk6CHRV/qXPSLXA0XZejpqiRZ0IgcY7hzu+AS2TB3quInaNnU2vzSlNqcT/fhHSqAVJgawAunEXxCPU4W9MMlcRN0ryZMAl2XcOHm6YlnYgMAToIOuxks+YBBErGrAa0YtKDDDkeYAaBFErjSUl2uKOfm5v1GE9y1nOLe/4IO+b3YchfKw0wy3lZ6m2arxyr4KV4RURH54qtS/fGufEMZZ7Hja/Ko0ptsgYML0+kKGM+4wbTbmGQUtPfLMfBrWWc3gIZenX4aJmUp9OQdqunk4nv2QmzMus0rO730wtj0qu2DqnuQjCYbrOjYrINq5JuRe/CKQp3QtRMweivm0yur+FBQf9xk6WFQX99Tvw2GDO0390jssWXW1vKf6n4q7Dc1EOXledJwQxF7RV/EomQbptMXssJlNyT5YSe4dq1m/s907eik1WprNKjdur9sW/1AWt7535Ur6/zvN2/lpcds/37eM892mEgTXGHuHD1y4qLRYK0YvrJsMly5knKu0tg0csmObbvfC2/ZbETK9bOnW4TU7xtGEw0a2geZbKysz/Xu9txQvV6fX6VOrMTw/hVsdF8b/tbGgX1feqF1m7Bq5hda+/o+pVgXm9Ztmzk0ctTBlMyEi/fnaoZ9g3HH1xmv5GgwI/m3+oAZUOzkj4fx7rQBt7qdxnhJDiuj/YlBe9dG1pLNbF9D8c2dem2xVMA3NQhjBk6WMyVaelmZVaL0+vmcB/Tz/zVa+8lIPlWW2SLMQh559ZSNCE2sbCq/FBuLyrrbLJVHsYZMr/sdfpiKJOv1pOxtyISp0tQRtHXqhNWQZffSy5d/LBOwJ5H71mrcAnzSSA2Z84ObJPlCbiujSZubkRefZI5X61hL5pavbzMvY4kuTCuzm6nXE4+Ztwf/lBRmcW1zcSkwxsXF6bWmEnbQSPJsoqWMZumwUqYC7QCVi3Y6tMmnCZdYDItiJezj0v3MaLJmRmXX58w0zKJ3w3ww2IwE+fk7JSUll9b2Crl4NfPcJXOav1OH7fyfdSs6cS7zl18Y65GRd36Pmk/S+dwex0/tHTN54pxNJ0/I2tTsM5WccqDFQgn9rW4nyphg4J95ut9gZis7p6Ym3BI4L9eQ+sS/ntrbLXDIE8/fLKaHVP7goyN5whKyKKMHcsWboSasqsznORfSRYEaz3v29uZt4JiDxMC8QVJLjzntg+ow+dBe7BhRJ1MwQ/AVkRbwQbBj7OtTXgVu49qt79LDrW/OX4yrqjEJ/OIPVrwlfM2CB/rW6XQ3wd9SgjsM41SsC9pLt+H0AptK2fdRjFdYHHwdhY0QOsL1VZDimkIHfLLD8xThcmCF+p3SjOxc0WlV+Zervm2x68dN/QQ+MLC2DVSHqOOVw6ZFXDRgCXjUBQ1y7Py+3bO+HyQLO0bArGV2auRrkxRv1orPPgjXF6XVARxJz0vCPvz4vbkoT50899yTenvAD0ljLx0L8Gr2Et4C9XXnTkEiecNKv/xiU/q1nHNXlQmN2iYVlpWwL0qLmSR3ZNFgQCpCogXuLDMa45WrTH8AcCVpTL8Q7ChbVDhAgO6XmwwGj7AWoa9lZ+UcBt3ufZvn6Ar0bUSbP/+42cJQ7NhbNjj3ybpW2p0G3LtP966DUIYk0TbZDr4Kk9Ho7lXLw1+0g6qo6Wtz8+f9sfmARQzqPZNWiCCBJ/NLtrOz9SkoKPxDlmT1SiJIHiuH6oAeF5e1o9XRGjWqa6pXrxbcqlm3YY7Wtifu6WDeU1xHF59an1cDki9wm8nnU7h3AV0fergDNrsln0+BtKUoP0yizYJr/57DhuJ1wnY5/mziepTVr6e3R0hrsbPLyck7BrxIZO/eAi2uuwE4I3Aok5rIAtzPPbjtxQuXtgCOOtQTwkqrPvlqMmBd2vcfDGeSpfGCXrS7H96SujCnBy+oj6LComSoEoGvUA0A6EvZ8DLaO9nYsUOoSzNy57Oi4mJyBu2SpuRcj2rGvZievUsRgleBf5gk6cpabd62egFoaYtr6NFl8DaUoz96LzTAq0kDlNWppLhE2UTg9Tuf8MdG2sw4DRjQU9H7e3b/FE2vomLoU3nJjm92rYSEwoXZuX3EJvDZsWtdz/+sjGlqMJqCXx/90jzALlz4syQl5awi7aj/EwnxPfC1srJy7ti232Sb6jZHRT+VJvm909I3pjKWayxjYdODeLkO1hnC2OLC/mhQWsJO6UvInCtjHQWDB+XKK2tvF3Dq5JkvVR4t/tzwiHk6namuefunwruvEq9ft86RW4Ef9sqQcK2WXRkzYtKBgtsFGYCNHjHpt3enzd+cnpvwo8pHbKQd2Wg9M3qDhjz9tqd+O7tao2XZqP+TKf8Ga3vyzP630EdGRpY+OTnutuiv0iQDqDOxVgaaSDLpjqMuResukoXHpwTw7jT5XnQlfHBBOgPcgxIiEqu+jG4NuoYN63a4mHzio0vJvy7Blhcwa2srWW0NAFZVgh0uaTSKj0LQYFERZVmy+WP1Z2uno25vZyd/tX5FO5T79x72faoF+xm4J5m4geLOPl7PHPvl1CeyLF1T875nkpdckq7qdOwIqY4aEz35i+XEXCYJ30MXs7dnSghSzaSqMunN2n36dZsBfG7uzYt3r0vpaVm/AHbkxJ4xJYWpD80PbapK6bmnL8+dvURRJXsPbXu5W49OU6n/ItA/zEapKr4PA8fC7OVVS1EXgwe8sq9Nh4aJ6nYWdyrFmayLvQsrIwleF8n4Jk9ntlCvo00gZ6ujE6UHBujQAZw2ZY52Cv8fvj/wwahXJu6VGFdu2sh4rdTs+M6+fl7dSAI+kTS0yfkbCWEndbhJIzPdjRu3TgcGBijqbcHc6Km21iz+b7C22KTEaGxFi1slHDyLsrGgKHr5kvYCsW3btkpeynskGYSrmaQnvTufLubhyL6WDGwK0zH9ypvSKMHoQXmuoaztz0diJoHu9VfePp6el3BYeOGstVYJ0Ys/VSR81OjhPmQqKAvbg3hqZNOd9PTsZNAt/3Rhi+5dW/cmy6SzaGfv7HS817NDlUUWsFWfrU9LzkxMFfjHyadMe3MZ7HPzCwJjMnK/8JbNI6rib1GSQfxpoTT7TRs+mYzLSJJoWkTYsKqYWIIbTNzWuaZTA0iWOT4l+2zKxx99fpXCUKxXv+5hn6/akP7n5eRztbw9O5rToi7cnx5+0rWIvi/uSU4/M2BgZJ/ZAwb2KiO9HynaXLp0rIAkTZeff/tc7MFju2Qm0T7r8RPcnJa43MjL1+PtocUif8SrE2ZkpWWX0Tmbex4q5q/KNFLLO8mcHSTXRc7nRsmzSkILCOzWsJkAypLjBXE4U+mdtmSCGclC+AEbC8US0Wh+u5Jz7jraIWREYfRGuJG064n7AAvxCHHIMxorpLcac4q9lHesYjLRb06qrgtZMoVpuecqzCi0tZRg2wq4pXEiKCDwlnIRMMD9WFvrjGqrwhK9RRj5kp+bwLgS37NI8C/wgTOgSPLyV7ibxoa9Rp7kV8nrVo1E3qSjJSr/CuNlBUxHTswSZmLFkhWTtLSGUqSEjO7yXEN1DZW1FBuQrQllxzK5FVuTc5HtnnOIwlRf1X6Waa1GM24KoNGQT69SkpiGFtIyYwwrMK1jb1+9/U9bApV6/7fyxGYAwewzZ1IdiosNBvF2PzHmD8FIWfcoKPIV7ZZ7Q8rImmJGPWPpR0jqdMxEAs5IgEkWCUm6mf6YRITIOXIFUC6heCvIyguhPIR5s1PE9TYrMixlWkM9ZqRwC2jLkywKSm4tPc005KKeOxe+qb+oKhE9fAUOvLLi0ubYH6AVNpoaLU++lnWezs8/OLbw8D09GUp8HkB7wHCEEwVHjBkOxqvX7x906kgOzMvn89qZWLm7SbSXmXwnqLHLMdVmWKAq5eolSY2wtDyp8aIcFNSqekl+Uftjhy5IbduGV0tKulrCdMEGrcRupeYm/iLoLOXkMpJqe4fUN+hZHRM3keQ9Wip3IGiSEIupmLjooXwByeoUA2daCrSw4nx2Kucye86qhJUq7MUKSznt+SqSHcq0KAqY1okZxqySrlcQUIEvJ7e+RDocW2JdmR3T8K0UT2lOwk1viKQnh2oUuaIqrFt120ct4ySGwaALHDPuVb8ZM9+OxjlFOh95oGXzrsvpxk2e/jb7ERB6VL6PQw9hS79427lUqzOOGBGZj5i64IcPYUp1paHDXxzs+UH07NUCvnrVumlzZ334h0ajuZqWc+68gKtz+Bq//CSmq4kbrRL/PDbPyalGKPDJySm7n27V+wtJywozshMPqduYl4Ugw/oHDm455A8ryDjEhp3CkV+/HxEYGKC0/XDRyreXLVmVbKeyE8HTPOE0DNmONhS3Gu0f4NPTHP+gOj7JGRwx4icYzRU7kUlfSzMW9+PJJMTLS03MztqahXs1YuuK8tmAqFgp70FM74eXxpeHTvhkR3eKY2wic6K5YmRoWBE51UdI825tuV/7h8Uh1qQzFAf26vusy8zZE1eKdt6+Xl1ooovbt+795fVUXRuC03rzzyecisZBYwoCsvETRgbcupFfunrl1mwSHtIW7EpqduKF5My4VBIG9w3rt7L+g3qtggsRI3t91IvzNq7d/sKVK1drk8bOtaSZ16zc3pw0sdV332/sLYSYzofd7tdj+H/Aw1O2/S0DhX8wlWvFv7eI0jpJqs1gs33brv09ej6TT7wqFKulIbt7utalw5RKxJwO4+yCEGMDFdjILbFCkNFw6k7py0XP8qu0Fm8nl4UTcW1nY81ORHXjPaL2SZcFcxq2xNbUXsSstB0oiCbA5TkWCCMvYQbda9KotCuVkCbTQGYyNCFb3ESh72wmayOlRbePV6L5m5UAOh+sK8wNh4tzxaeLF99lY6KjunGuri7h0BZf/GfZBfhQfDyaNEnPSUgw70o5bm8yuZrDUcdSTXftYL4EaiT5tobZJqXknsq+p52e+wB28vT+cfQyPYtyxOA+nw/oPXwPyiKl5ibE+Xs06UJb9x/OJB4OdXd3aUMmkPX2XWsnNAvu8EGZJDWhZfi62izyouPDRh2v9cabr/iGt2o6UvCa9c7CqfQFo0Gy0ZyJyyg/uiZw/0SuNocelX9qbvwv8F5+suxzv6VLPo211J6EvRZWnCXL5jUb+sKAoaDBh5SYKzyT1JxzRzAvlQQZRNN+kn6Oepq3JXn8gar+JKZBRPQbffnSJ+qEpAgdCTjnt/UbGCt7jkq+lbZwVmQqGPlcaVJWhRBHPcXd6ciG29xDbOecNtIGCm3VkKJLnqiy0JfcbIvxxx7fOc7Gxkpx6G3ZEDNn1rsLEy5cOb6GIkIuPXt3eef5FwaO3LxpByNteTM9Pb7yGO7az7+fPTBR+Km2bIyZPWPa/Pi1m1b0b0FONnt7Oz/0g0Su6oLLSVd+GP/G9G9154uLtZL2lsnGPo6XFjyDB0wx33JCC/8NBoavKQKBogB8noskH89jxs5dOw78MC7h5/VkUjiSQD+1fvPKDi8+/+ZhX0/lawzl5bv70jZ1dHTQTJ0xfr5gv+/HQ4vXr/smC/GC9Ixz6QL+T+aPo5ExrvT0E/BwX7I0RoR9TSajFebgmWc7TgINjk6OG/POKVnLctKzE06SECtNK2+67nKLOipdIEEOp7jI73QKg+lKWE3aDB56N5wPuUvCpInpCazEEM7yS86wQloh7tBVXFLEbpa8REL8fjkdl2Y158NItDOp/XnZimXM/ZW3lJY+WSH2dwttRt5o+6+3r+6C4A/6Tkq6EjNp4uz44pIS05wZi94V4164ZNYSN1cXKyz54hyowFnK+0X0GJGccXpneKuwQRcvJB3YvXPfAgSX6CPVeBK2avUb1huy79COLecuHp1Dx5fgU+wCId70zapnhNdZaGPwb9mq2SgBRx45uK87p1Xgjh3NjrV0FmHm92YtnirGggfYp09XV5PRFIBNIeDGohstke/9edtrCNmifC0l/YdXXxz3Cxy76dfPVz4DC4L/sYQvkhFh+HT1h62EEP+45+dFEGJ8xp6enXhSfUsWBRkEM45KubIDe5qE+DsE9XSlNM2lbMv0YP4OxaJIzsm+ePd6DivMb8vu6GKYviyJFRq7Se/d+hq4KMa104PZLBLgDXRiRkPhbU5h7s03PNgx4J9UCvBsGqDnBh/YoO07PDUefEtLyzK7tI9Yh80dQtTr1m7JPHL4+HLg6GxB9f2Hy0M1CNtg5wx4VUnWaO1bNn12YJBfizf69hr+5Zujpqx5PnLUp43rtZvVtFHHCBFAdHFxDlu28v1w8JEljf6FIaN/FseJ8DGe4I9wvYAj37Z113XZVnsaZxUyM8+nkYJJw5Gjn386/JFos3Tl+3NQ1nMpDB/aGbmpxkfL329Wu46fcqiD7je7U9u+n0M72jr5nhDt/ldzH7fgIJOJ+0+aNjaw34AeihI6ezph7YiX3zpGk3sjI/fsWfN7q1KQQUibvNIF51kECfMysmuNlFPUjy2sHchWvhzAyXNM9aWshDTsQOmD0vrShwWKkI704vZFddkXRDuXhJgsELKYS9n7CxKkF1b8KNFr8WQS3Gw6g74JztRNeefNDwXXyeNnzSIBI88gl40GpkRyhg4aeeD69RvKQ8aSHbNrfS+Exvy8yn9OQ7Q1z2kCd+D8BDZnGdcTTqTmJCTjRKgky3nQntezc0+JNl7etRT7WqM1XcOuX9ZoKnlvBB1yrdb6CmhwqU2cjNzEs/A2vPj82Nj0tMz9oLWzt/Pfd3DbYNjntJmr06x5Ywf6ZEIRbuBHvz5lWplOp7jrnvRxZPD/byZ8IE0u3IZ16wbaTpw8Zgn6pjBiQq9uQ2Po6/SyjJwEiy/qfQW5/AYkvviyNIEEcgIFqstweou07GgXA4sZ6cxrlNP89X9MDe7sILM9JK4v60CrYyUlejZy0Z/SrL+oHr8EB7w4q7hr78ZZcLMJritXL16jXr5FGZsoQdOqTfNRM2ZNrGvU81pVfXUGWnoZlN2seqOl8PgH/dFWtm4noF07te33KX0GmIv+GjdpOIzs4SCUN2xZ9Q5lyrPbuuW7uT/tPXjLykq6bMmzAfr/pVQs3WmG8W785rMRlCkr//w50eWrKWPx9zyHuzenvZs/MItOl1a85cGvajjbpJNYdYpd97C3YkfH2fGeK0qkdDCg3x4JoI3fXknH6hMNRnFLx9igZTnSwQd28IgExw9fpO9PTVbQVOR6CkFzslvP0pI/+36scLwRp+9A88a4Vxbt2bV3WHz8hUb0uzm3yn9i4H6tVbgHmCQqykcuptBX2/6uYXFk37d4+413pn62Jvo/YPLm+Nfmt+/QZouzs5PiL066dHnrhHEz4xB8QLDnkTv6hxuQtyWAPESKXV9VV5JReyM193QWBNTXlT4Y4boaeGF9fL26og3cbF9vjsmRtdqcq9nxVX6R9NCCDKYf50jfv+3EO5gYHYbjzItATZg1OzVG5t3IFrWmjeGPpL9cCQ8HXYpGw3rQB38XUX2SCd8ilOmMrouXzAmBpgJvsnUNg/u/shBlnMC2dD7Wzy24HTaAzVuFxtSrFxhBk6fd+u1X8+rXaT2Jlcmt6ZzVHQMYPKEk0SecYEVnd/WCpZNzjZoKjII28FrgvK9tDftjly//dkfQIL+WF5dF9nDyrl37WLeYZ+b3j+g5kzaX9s2aN3kV+OLC4iud2vXfiMMqdYJdfk2NBfT/jfTc0P49unXrVKXQiVEWFhUXvT12xgHaK+jpxf3doNH7IUjWf0DPZwXNvh8OHkFZMsiKshRw8/yRBBmNl+VLZ0fb8ZayzH4krdyEnpQnudbiKRxMAbry9Y5gJwnfOzpfUpZF804fp46dOwlxvY5dnnZ64aVIRbOC39ovN8/GAW9ZsrpoSYhBU82dnczPkbpiI5iUcrK1ra2Nl2M1x7oHf/lueOd2/TeYmEnxAID2iSSDdQbZVp6ff7J214IPZ3YnnnLdunUiyNSJuMvfSC/fi8eOnepAp6EOnss5Rydc/kp0EDORfuXOZeyoqSeDmzSIQVtg8Q3K4IGvzkSZW9vd87sdgP+3Ejw05n3hFxroMgffU6f7KBs4uM8fy5euTjFKRkf6ks4FRJ61PJojL7hTePH99z5Kwsuael3R2gBbTPcMwiKVBeBkxh0KtGw7mQ/dhbeUynihvrU2sKEr2JPb1Km7h238a+ylp4zc6IRNXsdObV3JTswqKCw0kUeCNmLxiWp68zLOBpTeLm5LGydt377dXJycnazhewUd/K/YLZPmk8aOf80/LSW96Ntvf8jFRGodXA5iyRf88Es5xQZda0GbkZZVtGP77ntocaKXlRW3wQOv5ugot+vUyqluUGB18CGT5hZ+jwuOfRx0FbzVOcLQaz7Z0Q6eCsDRHzayiodCI58URwXVbR6l/Lghavw6hYGZsDr/rYSNLSKQcfS7AwiOSGWF4eJewRAmRVAD59MPOjPytwUZncAN5yyzhVacDSFlbDJIbO1qkzQXuP9Gql+/bTXj7WLbUq1t4V3H+kN3q5zWOnq5Jn05Jdm6GvMTExPJnC9PCDgYC2/X1Mp6o38j1xv3m0Q1LT5wu985DghlzGcxdqUaKzvSRpLJXtaFhdUpND8mLsZhKQcPuhSTxRL+UWFCkM3bPexZC/N2/9b/nYF/Z+AxZuD/AA8zEhkTLyOGAAAAAElFTkSuQmCC');\n}\n\n/* layers control */\n\n.l7-control-layers {\n  -webkit-box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n  background: #fff;\n  border-radius: 2px;\n}\n.l7-control-layers-toggle {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAkCAYAAAGf7Ah0AAAABGdBTUEAALGPC/xhBQAABzdJREFUWAnVV3lslEUUn/l2F0tpwdAih1HEqCReDcphNCo1EkgFkXa5PNpuC0Fo2e7Wgko8KiaKWrvbK5672xYFpNtiRRuNiY0aURA14BGviBcVlaKltVa6+42/N9v5Mrtt05rwj/PHzjt+8743b+a9N8vYwKgMNlUQyemnMtAkaJajvb3dToQSGp8e6boopkr4VYgEMYwO0vhCTfMVzBcMf8bx086YyODcuM80zTqp9IWat+7evW8sMdIxIqqCLa6oiAaJpuEtcBqcc2HEWMZ0JclgZR/Nchf++ubrzKjJSguXS4tVjXvPjfb3/UAAacGTn/MOMb7QnjNpNqP/bKZ50Ai0tqYmCi0n4zbM+W+lBc7JBOa+QPhDwcTsxJXE2+32edKCL9h8hRDmRzpIOWydAylhrcMfDN+ugBRKSdP3KwPhsFJIPth02FISIYQwYsDYcVfWhy/Bon4JgumffMGmiGTwQ0B/sHml4q2ZFAD3WQIQVhx0IdFw8B189lolN+w8w5PnjPmlhJgtA8/vfn3iye7u3yGzDljDxZEG4097Cp3rSSjBtMHunp6vFR+HHoIxmbgTe1xHKssDHecLNFUjMzbqMs5ZlHF7ute17M84+TMHDzr+OvR9JwKdCms9yRkzJq6bPTsWXh05QOPUN+PUHyPWMPhm6UHd7vaUohWZPSRE8OqxpTyibQa/qcTlbEP0vwF7AWUAT3JM9dy69FfSNza+MU4awNE8iQtXSkJuGLleV852ov2h5jkwVof0mUs8aO4LhTuYYFOAjExId0wcFIPahpaLTkWiX9ECfHG/sLNi1i8+HODfgLFFRI96+INNi0cNTgTS1obKQh03aAuk9DeELzcj4pACYivvwvXrFK/PcQZiQWo+hmidpYMUjQC7EOB6xdNsGfAHwk/RDdOVw9Dm+NTUSWtWLDohDVQ37JkbiUT2DwMeVswZP+gtdM4x3HnLDhjcGM2XLWOISaenIGee9MCSgqgMht/H/q/SZYk0qviV3oKcj5XcioESyOoqIseFYDYloxnAGm/hcrcuk3JV2XBMl+pKqn6mENux11+w12m6jpqMMFn7rPPTHdwfCm8yTfG4tMaNu+GepPUFiqbM7T105ARSPQU+dY/LOC/N2gI65WEkyWUEtjmSppfkLvlRLaQ5VnZFDtGGzbheNRROKZmbu/AvUvh3tE4Wff2/0IUC+y2q+4VVoXBW1BSvkR7Rb8BW84lWJQBdlGozcs7GLy3Nd35OSqTxBqtfgkc1+sPjcqbDgEl6xK0dH5lv545LOCVL1/F+3CoY4eyY1+WcBiC2KYEHQBd5XDkyndE17xCm2Ug6BLcSwb3LigE1AlOYu6TS4HUwVEw0Df1osfBnLDwnpiFDCQPuvQ73Fkqxg8/hEVYLXt66MXbbzOK8bKre1hhkgDT0RDja3fEHytwZxCMLH0YWPkD0fxqjqUZDejDSV3z1LbexqPkEPJxKWLqtKOGbvPnZL460NlE/KgfkIZiRrfjShsQcG2QQDUwwXjcuZcID61Ys6ErUJ/LDOiCfLUzUjVQdEg0O4jn/ABEq0iuIjrEcwE0x/KGWNbjPj4BO00Gni0ZOoIPzLR5X9vMqqaQDqDzzENra4V5zp8sBZQcROYjsLvYUOPdbEVBKeiZ193QjCmwtZCM+ldS6EWYTH3wuNSV1i+pFCj/IAaWgGUfBq0N78qPM3DZcp9TxcTQeyzZm3ON2LatXpSlOP8BIB6qDLddHmHnFrBlpNZmZmdZbNXEB9XsRlZXFennqGHzoXW5DaId4iSoc/Q365EjnRjszPnYXZL9NDWUtGsqzCjAw7xprTypbn7fkaILcYqkInzzeX06C8emO8sKlS7stZQLxVMPes/+O9FVAvEpXob+utY6gZmfrtMjf/RUI+2odhF7wJbq+Gzf3zTj5CAwyaoEwozVoCzN1KKK00z7WUbZx9dIOklsO6CAZpu87i5gpHoJ8gtLh9vZixSO2KckV7qysf5Sc5uq2tjOix3rL0FW3IJuSNV0XM/iDs85LqxvqeKUD8n3LxUobt5WVuLJlS9IM4O9i09VRwWtxLWfpcix+hXjs8mZdjn19YuOiuKRgufzXqOuqQi2r8O+yAk/tl2Q/RMW7ETe8UdX1GJhHDM5qjDHJ5e7bs07qBp7ZsTe9t6/vUXykkLKEdLFbLgLJSUn3rrt1yXEdX/1C23jzVG+5Keg/B5r2wJD9g/NcaUAJq4MvXxxl/TWoATcoGc0Av4eUKnIXZlsvXpLHO0CS2KgOtGQgdeuwqWuUjGbUgrdszLHRXXDLF0oe54AS0kyPnc5Iz/2CmV7EeIzSwcjvsHQPXkUhld/kCP6Xu+DRNjg/SWHh+SnODF+aPeVh9XCydAPEsA4kAqsCzcuiTPiw7+maTj6SwGsVk/9gY9xbUpizR8MNS47aAd0C7s35CG8VdrxYyjl/FcdUgo73nY77X9D/Au9RDMh+aBoVAAAAAElFTkSuQmCC');\n  width: 30px;\n  height: 30px;\n  background-size: 20px 20px;\n}\n\n.l7-touch .l7-control-layers-toggle {\n  width: 44px;\n  height: 44px;\n}\n.l7-control-layers .l7-control-layers-list,\n.l7-control-layers-expanded .l7-control-layers-toggle {\n  display: none;\n}\n.l7-control-layers-expanded .l7-control-layers-list {\n  display: block;\n  position: relative;\n}\n.l7-control-layers-expanded {\n  padding: 6px 10px 6px 6px;\n  color: #59626b;\n  background: #fff;\n}\n.l7-control-layers-scrollbar {\n  overflow-y: scroll;\n  overflow-x: hidden;\n  padding-right: 5px;\n}\n.l7-control-layers-selector {\n  margin-top: 2px;\n  position: relative;\n  top: 1px;\n}\n.l7-control-layers label {\n  display: block;\n  padding: 8px;\n}\n.l7-control-layers label input[type='radio'],\n.l7-control-layers label input[type='checkbox'] {\n  width: 14px;\n  height: 14px;\n  margin: 0;\n}\n.l7-control-layers-separator {\n  height: 0;\n  border-top: 1px solid #d8d8d8;\n  margin: 5px -10px 5px -6px;\n}\n.mapboxgl-ctrl-logo {\n  display: none !important;\n}\n.amap-logo {\n  display: none !important;\n}\n");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/interface.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/interface.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/marker-layer.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/marker-layer.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MarkerLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js");
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! supercluster/dist/supercluster */ "./node_modules/supercluster/dist/supercluster.js");
/* harmony import */ var supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./marker */ "./node_modules/@antv/l7-component/es/marker.js");









function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var MarkerLayer = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(MarkerLayer, _EventEmitter);

  var _super = _createSuper(MarkerLayer);

  function MarkerLayer(option) {
    var _this$markerLayerOpti;

    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, MarkerLayer);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "markers", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "markerLayerOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "clusterIndex", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "points", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "clusterMarkers", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mapsService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "scene", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "zoom", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "bbox", void 0);

    _this.markerLayerOption = lodash_merge__WEBPACK_IMPORTED_MODULE_7___default()(_this.getDefault(), option);
    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.bindAll)(['update'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));
    _this.zoom = ((_this$markerLayerOpti = _this.markerLayerOption.clusterOption) === null || _this$markerLayerOpti === void 0 ? void 0 : _this$markerLayerOpti.zoom) || -99;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(MarkerLayer, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        cluster: false,
        clusterOption: {
          radius: 80,
          maxZoom: 20,
          minZoom: 0,
          zoom: -99,
          style: {},
          className: ''
        }
      };
    }
  }, {
    key: "addTo",
    value: function addTo(scene) {
      this.scene = scene;
      this.mapsService = scene.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.TYPES.IMapService);

      if (this.markerLayerOption.cluster) {
        this.initCluster();
        this.update();
        this.mapsService.on('camerachange', this.update);
        this.mapsService.on('viewchange', this.update);
      }

      this.addMarkers();
      return this;
    }
  }, {
    key: "addMarker",
    value: function addMarker(marker) {
      var cluster = this.markerLayerOption.cluster;

      if (cluster) {
        this.addPoint(marker, this.markers.length);

        if (this.mapsService) {
          var zoom = this.mapsService.getZoom();
          var bbox = this.mapsService.getBounds();
          this.bbox = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.padBounds)(bbox, 0.5);
          this.zoom = Math.floor(zoom);
          this.getClusterMarker(this.bbox, this.zoom);
        }
      }

      this.markers.push(marker);
    }
  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      this.markers.indexOf(marker);
      var markerIndex = this.markers.indexOf(marker);

      if (markerIndex > -1) {
        this.markers.splice(markerIndex, 1);
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      this.markers.map(function (m) {
        m.getElement().style.opacity = '0';
      });
      this.clusterMarkers.map(function (m) {
        m.getElement().style.opacity = '0';
      });
    }
  }, {
    key: "show",
    value: function show() {
      this.markers.map(function (m) {
        m.getElement().style.opacity = '1';
      });
      this.clusterMarkers.map(function (m) {
        m.getElement().style.opacity = '1';
      });
    }
  }, {
    key: "getMarkers",
    value: function getMarkers() {
      var cluster = this.markerLayerOption.cluster;
      return cluster ? this.clusterMarkers : this.markers;
    }
  }, {
    key: "addMarkers",
    value: function addMarkers() {
      var _this2 = this;

      this.getMarkers().forEach(function (marker) {
        marker.addTo(_this2.scene);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.markers.forEach(function (marker) {
        marker.remove();
      });
      this.clusterMarkers.forEach(function (clusterMarker) {
        clusterMarker.remove();
      });
      this.mapsService.off('camerachange', this.update);
      this.markers = [];
      this.clusterMarkers = [];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      this.removeAllListeners();
    }
  }, {
    key: "addPoint",
    value: function addPoint(marker, id) {
      var _marker$getLnglat = marker.getLnglat(),
          lng = _marker$getLnglat.lng,
          lat = _marker$getLnglat.lat;

      var feature = {
        geometry: {
          type: 'Point',
          coordinates: [lng, lat]
        },
        properties: _objectSpread(_objectSpread({}, marker.getExtData()), {}, {
          marker_id: id
        })
      };
      this.points.push(feature);

      if (this.clusterIndex) {
        this.clusterIndex.load(this.points);
      }
    }
  }, {
    key: "initCluster",
    value: function initCluster() {
      if (!this.markerLayerOption.cluster) {
        return;
      }

      var _ref = this.markerLayerOption.clusterOption,
          radius = _ref.radius,
          _ref$minZoom = _ref.minZoom,
          minZoom = _ref$minZoom === void 0 ? 0 : _ref$minZoom,
          maxZoom = _ref.maxZoom;
      this.clusterIndex = new (supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_11___default())({
        radius: radius,
        minZoom: minZoom,
        maxZoom: maxZoom
      });
      this.clusterIndex.load(this.points);
    }
  }, {
    key: "getClusterMarker",
    value: function getClusterMarker(viewBounds, zoom) {
      var _this3 = this;

      var viewBBox = viewBounds[0].concat(viewBounds[1]);
      var clusterPoint = this.clusterIndex.getClusters(viewBBox, zoom);
      this.clusterMarkers.forEach(function (marker) {
        marker.remove();
      });
      this.clusterMarkers = [];
      clusterPoint.forEach(function (feature) {
        var _feature$properties;

        var _this3$markerLayerOpt = _this3.markerLayerOption.clusterOption,
            field = _this3$markerLayerOpt.field,
            method = _this3$markerLayerOpt.method;

        if (feature.properties && (_feature$properties = feature.properties) !== null && _feature$properties !== void 0 && _feature$properties.cluster_id) {
          var _feature$properties2;

          var clusterData = _this3.getLeaves((_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.cluster_id);

          feature.properties.clusterData = clusterData;

          if (field && method) {
            var columnData = clusterData === null || clusterData === void 0 ? void 0 : clusterData.map(function (item) {
              var data = (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)({}, field, item.properties[field]);

              return data;
            });
            var column = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.Satistics.getColumn(columnData, field);
            var stat = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.Satistics.getSatByColumn(method, column);
            var fieldName = 'point_' + method;
            feature.properties[fieldName] = stat.toFixed(2);
          }
        }

        var marker = _this3.clusterMarker(feature);

        _this3.clusterMarkers.push(marker);

        marker.addTo(_this3.scene);
      });
    }
  }, {
    key: "getLeaves",
    value: function getLeaves(clusterId) {
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!clusterId) {
        return null;
      }

      return this.clusterIndex.getLeaves(clusterId, limit, offset);
    }
  }, {
    key: "clusterMarker",
    value: function clusterMarker(feature) {
      var clusterOption = this.markerLayerOption.clusterOption;
      var _ref2 = clusterOption,
          _ref2$element = _ref2.element,
          element = _ref2$element === void 0 ? this.generateElement.bind(this) : _ref2$element;
      var marker = new _marker__WEBPACK_IMPORTED_MODULE_12__.default({
        element: element(feature)
      }).setLnglat({
        lng: feature.geometry.coordinates[0],
        lat: feature.geometry.coordinates[1]
      });
      return marker;
    }
  }, {
    key: "normalMarker",
    value: function normalMarker(feature) {
      var marker_id = feature.properties.marker_id;
      return this.markers[marker_id];
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.mapsService) {
        return;
      }

      var zoom = this.mapsService.getZoom();
      var bbox = this.mapsService.getBounds();

      if (!this.bbox || Math.abs(zoom - this.zoom) >= 1 || !(0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.boundsContains)(this.bbox, bbox)) {
        this.bbox = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.padBounds)(bbox, 0.5);
        this.zoom = Math.floor(zoom);
        this.getClusterMarker(this.bbox, this.zoom);
      }
    }
  }, {
    key: "generateElement",
    value: function generateElement(feature) {
      var el = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.DOM.create('div', 'l7-marker-cluster');
      var label = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.DOM.create('div', '', el);
      var span = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.DOM.create('span', '', label);
      var _this$markerLayerOpti2 = this.markerLayerOption.clusterOption,
          field = _this$markerLayerOpti2.field,
          method = _this$markerLayerOpti2.method;
      feature.properties.point_count = feature.properties.point_count || 1;
      var text = field && method ? feature.properties['point_' + method] || feature.properties[field] : feature.properties.point_count;
      span.textContent = text;
      return el;
    }
  }]);

  return MarkerLayer;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_10__.EventEmitter);


//# sourceMappingURL=marker-layer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/marker.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/marker.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Marker; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_9__);








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Marker = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Marker, _EventEmitter);

  var _super = _createSuper(Marker);

  function Marker(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Marker);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "markerOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "defaultMarker", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "popup", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mapsService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sceneSerive", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "lngLat", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "scene", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "added", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "eventHandle", function (e) {
      _this.emit(e.type, {
        target: e,
        data: _this.markerOption.extData,
        lngLat: _this.lngLat
      });
    });

    _this.markerOption = _objectSpread(_objectSpread({}, _this.getDefault()), option);
    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.bindAll)(['update', 'onMove', 'onUp', 'addDragHandler', 'onMapClick'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));

    _this.init();

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Marker, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        element: undefined,
        anchor: _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.anchorType.BOTTOM,
        offsets: [0, 0],
        color: '#5B8FF9',
        draggable: false
      };
    }
  }, {
    key: "addTo",
    value: function addTo(scene) {
      this.scene = scene;
      this.mapsService = scene.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IMapService);
      this.sceneSerive = scene.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.ISceneService);
      var _this$markerOption = this.markerOption,
          element = _this$markerOption.element,
          draggable = _this$markerOption.draggable;
      this.mapsService.getMarkerContainer().appendChild(element);
      this.registerMarkerEvent(element);
      this.mapsService.on('camerachange', this.update);
      this.mapsService.on('viewchange', this.update);
      this.update();
      this.added = true;
      this.emit('added');
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      if (this.mapsService) {
        this.mapsService.off('click', this.onMapClick);
        this.mapsService.off('move', this.update);
        this.mapsService.off('moveend', this.update);
        this.mapsService.off('mousedown', this.addDragHandler);
        this.mapsService.off('touchstart', this.addDragHandler);
        this.mapsService.off('mouseup', this.onUp);
        this.mapsService.off('touchend', this.onUp);
      }

      this.unRegisterMarkerEvent();
      this.removeAllListeners();
      var element = this.markerOption.element;

      if (element) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.remove(element);
      }

      if (this.popup) {
        this.popup.remove();
      }

      return this;
    }
  }, {
    key: "setLnglat",
    value: function setLnglat(lngLat) {
      this.lngLat = lngLat;

      if (Array.isArray(lngLat)) {
        this.lngLat = {
          lng: lngLat[0],
          lat: lngLat[1]
        };
      }

      if (this.popup) {
        this.popup.setLnglat(this.lngLat);
      }

      this.update();
      return this;
    }
  }, {
    key: "getLnglat",
    value: function getLnglat() {
      return this.lngLat;
    }
  }, {
    key: "getElement",
    value: function getElement() {
      return this.markerOption.element;
    }
  }, {
    key: "setElement",
    value: function setElement(el) {
      var _this2 = this;

      if (!this.added) {
        this.once('added', function () {
          _this2.setElement(el);
        });
        return this;
      }

      var element = this.markerOption.element;

      if (element) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.remove(element);
      }

      this.markerOption.element = el;
      this.init();
      this.mapsService.getMarkerContainer().appendChild(el);
      this.registerMarkerEvent(el);
      this.update();
      return this;
    }
  }, {
    key: "openPopup",
    value: function openPopup() {
      var _this3 = this;

      if (!this.added) {
        this.once('added', function () {
          _this3.openPopup();
        });
        return this;
      }

      var popup = this.popup;

      if (!popup) {
        return this;
      }

      if (!popup.isOpen()) {
        popup.addTo(this.scene);
      }

      return this;
    }
  }, {
    key: "closePopup",
    value: function closePopup() {
      var _this4 = this;

      if (!this.added) {
        this.once('added', function () {
          _this4.closePopup();
        });
      }

      var popup = this.popup;

      if (popup) {
        popup.remove();
      }

      return this;
    }
  }, {
    key: "setPopup",
    value: function setPopup(popup) {
      this.popup = popup;

      if (this.lngLat) {
        this.popup.setLnglat(this.lngLat);
      }

      return this;
    }
  }, {
    key: "togglePopup",
    value: function togglePopup() {
      var popup = this.popup;

      if (!popup) {
        return this;
      } else if (popup.isOpen()) {
        popup.remove();
      } else {
        popup.addTo(this.scene);
      }

      return this;
    }
  }, {
    key: "getPopup",
    value: function getPopup() {
      return this.popup;
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      return this.markerOption.offsets;
    }
  }, {
    key: "setDraggable",
    value: function setDraggable(draggable) {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "isDraggable",
    value: function isDraggable() {
      return this.markerOption.draggable;
    }
  }, {
    key: "getExtData",
    value: function getExtData() {
      return this.markerOption.extData;
    }
  }, {
    key: "setExtData",
    value: function setExtData(data) {
      this.markerOption.extData = data;
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.mapsService) {
        return;
      }

      var _this$markerOption2 = this.markerOption,
          element = _this$markerOption2.element,
          anchor = _this$markerOption2.anchor;
      this.updatePosition();
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.setTransform(element, "".concat(_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.anchorTranslate[anchor]));
    }
  }, {
    key: "onMapClick",
    value: function onMapClick(e) {
      var element = this.markerOption.element;

      if (this.popup && element) {
        this.togglePopup();
      }
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      if (!this.mapsService) {
        return;
      }

      var _this$markerOption3 = this.markerOption,
          element = _this$markerOption3.element,
          offsets = _this$markerOption3.offsets;
      var _this$lngLat = this.lngLat,
          lng = _this$lngLat.lng,
          lat = _this$lngLat.lat;
      var bounds = this.mapsService.getBounds();
      var pos = this.mapsService.lngLatToContainer([lng, lat]);

      if (element) {
        element.style.display = 'block';
        element.style.whiteSpace = 'nowrap';
        var container = this.mapsService.getContainer();
        var containerWidth = 0;
        var containerHeight = 0;

        if (container) {
          containerWidth = container.scrollWidth;
          containerHeight = container.scrollHeight;
        }

        if (Math.abs(bounds[0][0]) > 180 || Math.abs(bounds[1][0]) > 180) {
          if (pos.x > containerWidth) {
            var newPos = this.mapsService.lngLatToContainer([lng - 360, lat]);
            pos.x = newPos.x;
          }

          if (pos.x < 0) {
            var _newPos = this.mapsService.lngLatToContainer([lng + 360, lat]);

            pos.x = _newPos.x;
          }
        }

        if (pos.x > containerWidth || pos.x < 0 || pos.y > containerHeight || pos.y < 0) {
          element.style.display = 'none';
        }

        element.style.left = pos.x + offsets[0] + 'px';
        element.style.top = pos.y - offsets[1] + 'px';
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this5 = this;

      var element = this.markerOption.element;
      var _this$markerOption4 = this.markerOption,
          color = _this$markerOption4.color,
          anchor = _this$markerOption4.anchor;

      if (!element) {
        this.defaultMarker = true;
        element = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div');
        this.markerOption.element = element;
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttributeNS(null, 'display', 'block');
        svg.setAttributeNS(null, 'height', '48px');
        svg.setAttributeNS(null, 'width', '48px');
        svg.setAttributeNS(null, 'viewBox', '0 0 1024 1024');
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttributeNS(null, 'd', 'M512 490.666667C453.12 490.666667 405.333333 442.88 405.333333 384 405.333333 325.12 453.12 277.333333 512 277.333333 570.88 277.333333 618.666667 325.12 618.666667 384 618.666667 442.88 570.88 490.666667 512 490.666667M512 85.333333C346.88 85.333333 213.333333 218.88 213.333333 384 213.333333 608 512 938.666667 512 938.666667 512 938.666667 810.666667 608 810.666667 384 810.666667 218.88 677.12 85.333333 512 85.333333Z');
        path.setAttributeNS(null, 'fill', color);
        svg.appendChild(path);
        element.appendChild(svg);
      }

      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.addClass(element, 'l7-marker');
      Object.keys(this.markerOption.style || {}).forEach(function (key) {
        var _this5$markerOption, _this5$markerOption2;

        var value = ((_this5$markerOption = _this5.markerOption) === null || _this5$markerOption === void 0 ? void 0 : _this5$markerOption.style) && ((_this5$markerOption2 = _this5.markerOption) === null || _this5$markerOption2 === void 0 ? void 0 : _this5$markerOption2.style[key]);

        if (element) {
          element.style[key] = value;
        }
      });
      element.addEventListener('click', function (e) {
        _this5.onMapClick(e);
      });
      element.addEventListener('click', this.eventHandle);
      (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.applyAnchorClass)(element, anchor, 'marker');
    }
  }, {
    key: "registerMarkerEvent",
    value: function registerMarkerEvent(element) {
      element.addEventListener('mousemove', this.eventHandle);
      element.addEventListener('click', this.eventHandle);
      element.addEventListener('mousedown', this.eventHandle);
      element.addEventListener('mouseup', this.eventHandle);
      element.addEventListener('dblclick', this.eventHandle);
      element.addEventListener('contextmenu', this.eventHandle);
      element.addEventListener('mouseover', this.eventHandle);
      element.addEventListener('mouseout', this.eventHandle);
    }
  }, {
    key: "unRegisterMarkerEvent",
    value: function unRegisterMarkerEvent() {
      var element = this.getElement();
      element.removeEventListener('mousemove', this.eventHandle);
      element.removeEventListener('click', this.eventHandle);
      element.removeEventListener('mousedown', this.eventHandle);
      element.removeEventListener('mouseup', this.eventHandle);
      element.removeEventListener('dblclick', this.eventHandle);
      element.removeEventListener('contextmenu', this.eventHandle);
      element.removeEventListener('mouseover', this.eventHandle);
      element.removeEventListener('mouseout', this.eventHandle);
    }
  }, {
    key: "addDragHandler",
    value: function addDragHandler(e) {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "onUp",
    value: function onUp(e) {
      throw new Error('Method not implemented.');
    }
  }]);

  return Marker;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_9__.EventEmitter);


//# sourceMappingURL=marker.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-component/es/popup.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/l7-component/es/popup.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Popup; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_9__);








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Popup = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Popup, _EventEmitter);

  var _super = _createSuper(Popup);

  function Popup(cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Popup);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "popupOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mapsService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sceneSerive", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "lngLat", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "content", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "closeButton", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "timeoutInstance", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "container", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "tip", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "scene", void 0);

    _this.popupOption = _objectSpread(_objectSpread({}, _this.getdefault()), cfg);
    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.bindAll)(['update', 'onClickClose', 'remove'], (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this));
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Popup, [{
    key: "addTo",
    value: function addTo(scene) {
      var _this2 = this;

      this.mapsService = scene.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IMapService);
      this.sceneSerive = scene.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.ISceneService);
      this.mapsService.on('camerachange', this.update);
      this.mapsService.on('viewchange', this.update);
      this.scene = scene;
      this.update();

      if (this.popupOption.closeOnClick) {
        this.timeoutInstance = setTimeout(function () {
          _this2.mapsService.on('click', _this2.onClickClose);
        }, 30);
      }

      this.emit('open');
      return this;
    }
  }, {
    key: "close",
    value: function close() {
      this.remove();
    }
  }, {
    key: "open",
    value: function open() {
      this.addTo(this.scene);
    }
  }, {
    key: "setHTML",
    value: function setHTML(html) {
      var frag = window.document.createDocumentFragment();
      var temp = window.document.createElement('body');
      var child;
      temp.innerHTML = html;

      while (true) {
        child = temp.firstChild;

        if (!child) {
          break;
        }

        frag.appendChild(child);
      }

      return this.setDOMContent(frag);
    }
  }, {
    key: "setLnglat",
    value: function setLnglat(lngLat) {
      this.lngLat = lngLat;

      if (Array.isArray(lngLat)) {
        this.lngLat = {
          lng: lngLat[0],
          lat: lngLat[1]
        };
      }

      if (this.mapsService) {
        this.mapsService.on('camerachange', this.update);
        this.mapsService.on('viewchange', this.update);
      }

      this.update();
      return this;
    }
  }, {
    key: "getLnglat",
    value: function getLnglat() {
      return this.lngLat;
    }
  }, {
    key: "setText",
    value: function setText(text) {
      return this.setDOMContent(window.document.createTextNode(text));
    }
  }, {
    key: "setMaxWidth",
    value: function setMaxWidth(maxWidth) {
      this.popupOption.maxWidth = maxWidth;
      this.update();
      return this;
    }
  }, {
    key: "setDOMContent",
    value: function setDOMContent(htmlNode) {
      this.createContent();
      this.content.appendChild(htmlNode);
      this.update();
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      if (this.content) {
        this.removeDom(this.content);
      }

      if (this.container) {
        this.removeDom(this.container);
        delete this.container;
      }

      if (this.mapsService) {
        this.mapsService.off('camerachange', this.update);
        this.mapsService.off('viewchange', this.update);
        this.mapsService.off('click', this.onClickClose);
        delete this.mapsService;
      }

      clearTimeout(this.timeoutInstance);
      this.emit('close');
      return this;
    }
  }, {
    key: "isOpen",
    value: function isOpen() {
      return !!this.mapsService;
    }
  }, {
    key: "createContent",
    value: function createContent() {
      if (this.content) {
        _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.remove(this.content);
      }

      this.content = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('div', 'l7-popup-content', this.container);

      if (this.popupOption.closeButton) {
        this.closeButton = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.create('button', 'l7-popup-close-button', this.content);

        if (this.popupOption.closeButtonOffsets) {
          this.closeButton.style.right = this.popupOption.closeButtonOffsets[0] + 'px';
          this.closeButton.style.top = this.popupOption.closeButtonOffsets[1] + 'px';
        }

        this.closeButton.setAttribute('aria-label', 'Close popup');
        this.closeButton.innerHTML = '&#215;';
        this.closeButton.addEventListener('click', this.onClickClose);
      }
    }
  }, {
    key: "creatDom",
    value: function creatDom(tagName, className, container) {
      var el = window.document.createElement(tagName);

      if (className !== undefined) {
        el.className = className;
      }

      if (container) {
        container.appendChild(el);
      }

      return el;
    }
  }, {
    key: "removeDom",
    value: function removeDom(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }, {
    key: "getdefault",
    value: function getdefault() {
      return {
        closeButton: true,
        closeOnClick: true,
        maxWidth: '240px',
        offsets: [0, 0],
        anchor: _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.anchorType.BOTTOM,
        className: '',
        stopPropagation: true
      };
    }
  }, {
    key: "onClickClose",
    value: function onClickClose(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }

      this.remove();
    }
  }, {
    key: "update",
    value: function update() {
      var _this3 = this;

      var hasPosition = this.lngLat;
      var _this$popupOption = this.popupOption,
          className = _this$popupOption.className,
          maxWidth = _this$popupOption.maxWidth,
          anchor = _this$popupOption.anchor;

      if (!this.mapsService || !hasPosition || !this.content) {
        return;
      }

      var popupContainer = this.mapsService.getMarkerContainer();

      if (!this.container && popupContainer) {
        this.container = this.creatDom('div', 'l7-popup', popupContainer);
        this.tip = this.creatDom('div', 'l7-popup-tip', this.container);
        this.container.appendChild(this.content);

        if (className) {
          className.split(' ').forEach(function (name) {
            return _this3.container.classList.add(name);
          });
        }

        var stopPropagation = this.popupOption.stopPropagation;

        if (stopPropagation) {
          ['mousemove', 'mousedown', 'mouseup', 'click', 'dblclick'].forEach(function (type) {
            _this3.container.addEventListener(type, function (e) {
              e.stopPropagation();
            });
          });
        }

        this.container.style.whiteSpace = 'nowrap';
      }

      if (maxWidth && this.container.style.maxWidth !== maxWidth) {
        this.container.style.maxWidth = maxWidth;
      }

      this.updatePosition();
      _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.DOM.setTransform(this.container, "".concat(_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.anchorTranslate[anchor]));
      (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.applyAnchorClass)(this.container, anchor, 'popup');
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      if (!this.mapsService) {
        return;
      }

      var _this$lngLat = this.lngLat,
          lng = _this$lngLat.lng,
          lat = _this$lngLat.lat;
      var offsets = this.popupOption.offsets;
      var pos = this.mapsService.lngLatToContainer([lng, lat]);
      this.container.style.left = pos.x + offsets[0] + 'px';
      this.container.style.top = pos.y - offsets[1] + 'px';
    }
  }]);

  return Popup;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_9__.EventEmitter);


//# sourceMappingURL=popup.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/Geometry/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/Geometry/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ GeometryLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models */ "./node_modules/@antv/l7-layers/es/Geometry/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var GeometryLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(GeometryLayer, _BaseLayer);

  var _super = _createSuper(GeometryLayer);

  function GeometryLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, GeometryLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'GeometryLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(GeometryLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        plane: {},
        sprite: {},
        billboard: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var _shapeAttribute$scale;

      var shapeAttribute = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shape = shapeAttribute === null || shapeAttribute === void 0 ? void 0 : (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;

      if (shape === 'plane') {
        return 'plane';
      } else if (shape === 'sprite') {
        return 'sprite';
      } else if (shape === 'billboard') {
        return 'billboard';
      } else {
        return 'plane';
      }
    }
  }]);

  return GeometryLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/Geometry/models/billboard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/Geometry/models/billboard.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BillBoardModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var planeFrag = "\nuniform sampler2D u_texture;\nuniform float u_opacity;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\n\n#pragma include \"picking\"\nvoid main() {\n  gl_FragColor = texture2D(u_texture, vec2(v_uv.x, 1.0 - v_uv.y));\n  gl_FragColor.a *= u_opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var planeVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform float u_raisingHeight: 0.0;\nuniform mat4 u_Mvp;\nuniform float u_opacity;\nuniform vec2 u_size: [1.0, 1.0];\nuniform mat2 u_RotateMatrix;\n\nattribute vec3 a_Extrude;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nattribute vec3 a_Color;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\nvoid main() {\n   vec3 extrude = a_Extrude;\n   v_Color = a_Color;\n   v_uv = a_Uv;\n\n   float raiseHeight = u_raisingHeight;\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      raiseHeight = u_raisingHeight * mapboxZoomScale;\n   }\n\n   // \u8BA1\u7B97\u7ECF\u7EAC\u5EA6\u70B9\u4F4D\u5750\u6807\n   vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n   // \u8BA1\u7B97\u7ED5 z \u8F74\u65CB\u8F6C\u540E\u7684\u504F\u79FB\n   vec2 offsetXY = project_pixel(u_RotateMatrix * vec2(extrude.x * u_size.x, 0.0));\n   // \u7ED5 z \u8F74\u65CB\u8F6C\n   float x = project_pos.x + offsetXY.x;\n   float y = project_pos.y + offsetXY.y;\n   // z \u8F74\u4E0D\u53C2\u4E0E\u65CB\u8F6C\n   float z = project_pixel(extrude.y * u_size.y + raiseHeight);\n\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      // gl_Position = u_Mvp * (vec4(project_pos.xy, a_Position.z, 1.0));\n      gl_Position = u_Mvp * (vec4(x, y, z, 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(x , y, z , 1.0));\n   }\n\n   setPickingColor(a_PickingColor);\n}\n";

var BillBoardModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(BillBoardModel, _BaseModel);

  var _super = _createSuper(BillBoardModel);

  function BillBoardModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, BillBoardModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "radian", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "planeGeometryTriangulation", function () {
      var _ref = _this.layer.getLayerConfig(),
          _ref$center = _ref.center,
          center = _ref$center === void 0 ? [120, 30] : _ref$center;

      return {
        size: 4,
        indices: [0, 1, 2, 2, 3, 0],
        vertices: [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(center), [1, 1], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(center), [0, 1], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(center), [0, 0], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(center), [1, 0])
      };
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(BillBoardModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref2 = this.layer.getLayerConfig(),
          opacity = _ref2.opacity,
          _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 1 : _ref2$height,
          _ref2$raisingHeight = _ref2.raisingHeight,
          raisingHeight = _ref2$raisingHeight === void 0 ? 0 : _ref2$raisingHeight;

      var rotateFlag = 1;

      if (this.mapService.version === 'GAODE2.x' || this.mapService.version === 'GAODE1.x') {
        rotateFlag = -1;
      }

      this.radian = rotateFlag * Math.PI * (this.mapService.getRotation() % 360) / 180;
      return {
        u_raisingHeight: Number(raisingHeight),
        u_RotateMatrix: new Float32Array([Math.cos(this.radian), Math.sin(this.radian), -Math.sin(this.radian), Math.cos(this.radian)]),
        u_opacity: opacity || 1,
        u_texture: this.texture,
        u_size: [width, height]
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside,
          drawCanvas = _ref3.drawCanvas;

      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });

      if (drawCanvas) {
        this.updateTexture(drawCanvas);
      }

      return [this.layer.buildLayerModel({
        moduleName: 'geometry_billboard',
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: this.planeGeometryTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        depth: {
          enable: true
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture(drawCanvas) {
      var createTexture2D = this.rendererService.createTexture2D;

      var _ref4 = this.layer.getLayerConfig(),
          _ref4$canvasWidth = _ref4.canvasWidth,
          canvasWidth = _ref4$canvasWidth === void 0 ? 1 : _ref4$canvasWidth,
          _ref4$canvasHeight = _ref4.canvasHeight,
          canvasHeight = _ref4$canvasHeight === void 0 ? 1 : _ref4$canvasHeight;

      var canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      var ctx = canvas.getContext('2d');

      if (ctx) {
        drawCanvas(canvas);
        this.texture = createTexture2D({
          data: canvas,
          width: canvas.width,
          height: canvas.height,
          wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
          wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE
        });
        this.layerService.updateLayerRenderList();
        this.layerService.renderLayers();
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'extrude',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Extrude',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
            var extrudeIndex = attributeIdx % 4 * 3;
            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[2], vertex[3]];
          }
        }
      });
    }
  }]);

  return BillBoardModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_10__.default);


//# sourceMappingURL=billboard.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/Geometry/models/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/Geometry/models/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _billboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./billboard */ "./node_modules/@antv/l7-layers/es/Geometry/models/billboard.js");
/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plane */ "./node_modules/@antv/l7-layers/es/Geometry/models/plane.js");
/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite */ "./node_modules/@antv/l7-layers/es/Geometry/models/sprite.js");



var GeometryModels = {
  plane: _plane__WEBPACK_IMPORTED_MODULE_0__.default,
  sprite: _sprite__WEBPACK_IMPORTED_MODULE_1__.default,
  billboard: _billboard__WEBPACK_IMPORTED_MODULE_2__.default
};
/* harmony default export */ __webpack_exports__["default"] = (GeometryModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/Geometry/models/plane.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/Geometry/models/plane.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PlaneModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var planeFrag = "\nuniform sampler2D u_texture;\nuniform float u_mapFlag;\nuniform float u_opacity;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\nvarying float v_clip;\n\n#pragma include \"picking\"\nvoid main() {\n  // gl_FragColor = vec4(v_Color, u_opacity);\n  if(u_mapFlag > 0.0) {\n    gl_FragColor = texture2D(u_texture, vec2(v_uv.x, 1.0 - v_uv.y));\n    gl_FragColor.a *= u_opacity;\n  } else {\n    // gl_FragColor = vec4(v_uv, 0.0, u_opacity);\n    gl_FragColor = vec4(v_Color, u_opacity);\n  }\n  gl_FragColor.a *= v_clip;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var planeVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\n\nuniform mat4 u_Mvp;\nuniform float u_opacity;\nuniform float u_terrainClipHeight;\n\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nattribute vec3 a_Color;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\nvarying float v_clip;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\nvoid main() {\n   v_Color = a_Color;\n   v_uv = a_Uv;\n  \n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n   v_clip = 1.0;\n   if(a_Position.z < u_terrainClipHeight) {\n      v_clip = 0.0;\n   }\n  \n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n\n   // float x = 1.0;\n   // float y = 0.0;\n   // float z = 0.0;\n   // mat3 translateMatrix = mat3(\n   //    1.0, 0.0, 0.0 \n   //    0.0, 1.0, 0.0\n   //    -project_pos.x,    -project_pos.y,  1.0\n   // );\n   //  mat4 translateMatrix = mat4(\n   //    1.0, 0.0, 0.0, 0.0 ,\n   //    0.0, 1.0, 0.0, 0.0,\n   //    0.0, 0.0, 1.0, 0.0,\n   //    1.0, 0.0, 0.0, 1.0\n   // );\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy, a_Position.z, 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n   }\n\n   setPickingColor(a_PickingColor);\n}\n";

var PlaneModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__.default)(PlaneModel, _BaseModel);

  var _super = _createSuper(PlaneModel);

  function PlaneModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, PlaneModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "terrainImage", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "terrainImageLoaded", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "mapTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "planeGeometryTriangulation", function () {
      var _this2;

      var _ref = _this.layer.getLayerConfig(),
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 1 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 1 : _ref$height,
          _ref$widthSegments = _ref.widthSegments,
          widthSegments = _ref$widthSegments === void 0 ? 1 : _ref$widthSegments,
          _ref$heightSegments = _ref.heightSegments,
          heightSegments = _ref$heightSegments === void 0 ? 1 : _ref$heightSegments,
          _ref$center = _ref.center,
          center = _ref$center === void 0 ? [120, 30] : _ref$center,
          terrainTexture = _ref.terrainTexture;

      var _this$initPlane = (_this2 = _this).initPlane.apply(_this2, [width, height, widthSegments, heightSegments].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(center))),
          indices = _this$initPlane.indices,
          positions = _this$initPlane.positions;

      if (terrainTexture) {
        _this.loadTerrainTexture(positions, indices);
      }

      return {
        vertices: positions,
        indices: indices,
        size: 5
      };
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(PlaneModel, [{
    key: "initPlane",
    value: function initPlane() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var lng = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 120;
      var lat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 30;
      var widthHalf = width / 2;
      var heightHalf = height / 2;
      var gridX = Math.floor(widthSegments);
      var gridY = Math.floor(heightSegments);
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segmentWidth = width / gridX;
      var segmentHeight = height / gridY;
      var indices = [];
      var positions = [];

      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;

        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segmentWidth - widthHalf;

          if (this.mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version["GAODE2.x"]) {
            var _ref2 = this.mapService.lngLatToCoord([x + lng, -y + lat]),
                _ref3 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_ref2, 2),
                a = _ref3[0],
                _b = _ref3[1];

            positions.push(a, _b, 0);
          } else {
            positions.push(x + lng, -y + lat, 0);
          }

          positions.push(ix / gridX);
          positions.push(1 - iy / gridY);
        }
      }

      for (var _iy = 0; _iy < gridY; _iy++) {
        for (var _ix = 0; _ix < gridX; _ix++) {
          var _a = _ix + gridX1 * _iy;

          var _b2 = _ix + gridX1 * (_iy + 1);

          var c = _ix + 1 + gridX1 * (_iy + 1);
          var d = _ix + 1 + gridX1 * _iy;
          indices.push(_a, _b2, d);
          indices.push(_b2, c, d);
        }
      }

      return {
        indices: indices,
        positions: positions
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var _ref4 = this.layer.getLayerConfig(),
          opacity = _ref4.opacity,
          mapTexture = _ref4.mapTexture,
          _ref4$terrainClipHeig = _ref4.terrainClipHeight,
          terrainClipHeight = _ref4$terrainClipHeig === void 0 ? 0 : _ref4$terrainClipHeig,
          terrainTexture = _ref4.terrainTexture;

      if (this.mapTexture !== mapTexture) {
        var _this$texture;

        this.mapTexture = mapTexture;
        (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
        this.updateTexture(mapTexture);
      }

      return {
        u_opacity: opacity || 1,
        u_mapFlag: mapTexture ? 1 : 0,
        u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,
        u_texture: this.texture
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture2;

      this.terrainImage = null;
      (_this$texture2 = this.texture) === null || _this$texture2 === void 0 ? void 0 : _this$texture2.destroy();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref5 = this.layer.getLayerConfig(),
          _ref5$mask = _ref5.mask,
          mask = _ref5$mask === void 0 ? false : _ref5$mask,
          _ref5$maskInside = _ref5.maskInside,
          maskInside = _ref5$maskInside === void 0 ? true : _ref5$maskInside,
          mapTexture = _ref5.mapTexture;

      this.mapTexture = mapTexture;
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      this.updateTexture(mapTexture);
      return [this.layer.buildLayerModel({
        moduleName: 'geometry_plane',
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: this.planeGeometryTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.TRIANGLES,
        depth: {
          enable: true
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside),
        cull: {
          enable: true,
          face: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.BACK
        }
      })];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "createModelData",
    value: function createModelData(options) {
      if (options) {
        var _ref6 = this.layer.getLayerConfig(),
            oldwidthSegments = _ref6.widthSegments,
            oldheightSegments = _ref6.heightSegments,
            oldwidth = _ref6.width,
            oldheight = _ref6.height;

        var _ref7 = options,
            widthSegments = _ref7.widthSegments,
            heightSegments = _ref7.heightSegments,
            width = _ref7.width,
            height = _ref7.height;
        this.layer.style({
          widthSegments: widthSegments !== undefined ? widthSegments : oldwidthSegments,
          heightSegments: heightSegments !== undefined ? heightSegments : oldheightSegments,
          width: width !== undefined ? width : oldwidth,
          height: height !== undefined ? height : oldheight
        });
      }

      var oldFeatures = this.layer.getEncodedData();
      var res = this.styleAttributeService.createAttributesAndIndices(oldFeatures, this.planeGeometryTriangulation);
      return res;
    }
  }, {
    key: "updateTexture",
    value: function updateTexture(mapTexture) {
      var _this3 = this;

      var createTexture2D = this.rendererService.createTexture2D;

      if (mapTexture) {
        var img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = function () {
          _this3.texture = createTexture2D({
            data: img,
            width: img.width,
            height: img.height,
            wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE,
            wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE
          });

          _this3.layerService.updateLayerRenderList();

          _this3.layerService.renderLayers();
        };

        img.src = mapTexture;
      } else {
        this.texture = createTexture2D({
          width: 0,
          height: 0
        });
      }
    }
  }, {
    key: "getImageData",
    value: function getImageData(img) {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var width = img.width,
          height = img.height;
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      var imageData = ctx.getImageData(0, 0, width, height);
      return imageData;
    }
  }, {
    key: "translateVertex",
    value: function translateVertex(positions, indices, image, widthSegments, heightSegments, rgb2height) {
      var imgWidth = image.width;
      var imgHeight = image.height;
      var imageData = this.getImageData(image).data;
      var gridX = Math.floor(widthSegments);
      var gridY = Math.floor(heightSegments);
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var widthStep = imgWidth / gridX;
      var heihgtStep = imgHeight / gridY;

      for (var iy = 0; iy < gridY1; iy++) {
        var imgIndexY = Math.floor(iy * heihgtStep);
        var imgLen = imgIndexY * imgWidth;

        for (var ix = 0; ix < gridX1; ix++) {
          var imgIndexX = Math.floor(ix * widthStep);
          var imgDataIndex = (imgLen + imgIndexX) * 4;
          var _r = imageData[imgDataIndex];
          var _g = imageData[imgDataIndex + 1];
          var _b3 = imageData[imgDataIndex + 2];
          var z = (iy * gridX1 + ix) * 5 + 2;
          positions[z] = rgb2height(_r, _g, _b3);
        }
      }

      var oldFeatures = this.layer.getEncodedData();
      var modelData = this.styleAttributeService.createAttributesAndIndices(oldFeatures, function () {
        return {
          vertices: positions,
          indices: indices,
          size: 5
        };
      });
      this.layer.updateModelData(modelData);
      this.layerService.renderLayers();
    }
  }, {
    key: "loadTerrainTexture",
    value: function loadTerrainTexture(positions, indices) {
      var _this4 = this;

      var _ref8 = this.layer.getLayerConfig(),
          _ref8$widthSegments = _ref8.widthSegments,
          widthSegments = _ref8$widthSegments === void 0 ? 1 : _ref8$widthSegments,
          _ref8$heightSegments = _ref8.heightSegments,
          heightSegments = _ref8$heightSegments === void 0 ? 1 : _ref8$heightSegments,
          terrainTexture = _ref8.terrainTexture,
          _ref8$rgb2height = _ref8.rgb2height,
          rgb2height = _ref8$rgb2height === void 0 ? function (r, g, b) {
        return r + g + b;
      } : _ref8$rgb2height;

      if (this.terrainImage) {
        if (this.terrainImageLoaded) {
          this.translateVertex(positions, indices, this.terrainImage, widthSegments, heightSegments, rgb2height);
        } else {
          this.terrainImage.onload = function () {
            _this4.translateVertex(positions, indices, _this4.terrainImage, widthSegments, heightSegments, rgb2height);
          };
        }
      } else {
        var terrainImage = new Image();
        this.terrainImage = terrainImage;
        terrainImage.crossOrigin = 'anonymous';

        terrainImage.onload = function () {
          _this4.terrainImageLoaded = true;
          setTimeout(function () {
            return _this4.layer.emit('terrainImageLoaded', null);
          });

          _this4.translateVertex(positions, indices, terrainImage, widthSegments, heightSegments, rgb2height);
        };

        terrainImage.src = terrainTexture;
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return PlaneModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=plane.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/Geometry/models/sprite.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/Geometry/models/sprite.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ SpriteModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var spriteFrag = "\nuniform sampler2D u_texture;\nuniform float u_mapFlag;\nuniform float u_opacity;\n\nvarying vec3 v_Color;\nvarying float v_d;\n\nvoid main() {\n\n  if(v_d < 0.0) {\n    discard;\n  }\n\n  if(u_mapFlag > 0.0) {\n    gl_FragColor = texture2D(u_texture, gl_PointCoord);\n    gl_FragColor.a *= u_opacity;\n  } else {\n    gl_FragColor = vec4(v_Color, u_opacity);\n  }\n}\n";
var spriteVert = "precision highp float;\n\nattribute vec3 a_Position;\nattribute vec3 a_Color;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_opacity;\nuniform float u_Scale;\nvarying vec3 v_Color;\nvarying float v_d;\n\n#pragma include \"projection\"\nvoid main() {\n   v_Color = a_Color;\n  \n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n   v_d = a_Position.z;\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy, a_Position.z, 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n   }\n\n   gl_PointSize = pow((u_Zoom - 1.0), 2.0) * u_Scale;\n}\n";
var SPRITE_ANIMATE_DIR;

(function (SPRITE_ANIMATE_DIR) {
  SPRITE_ANIMATE_DIR["UP"] = "up";
  SPRITE_ANIMATE_DIR["DOWN"] = "down";
})(SPRITE_ANIMATE_DIR || (SPRITE_ANIMATE_DIR = {}));

var SpriteModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__.default)(SpriteModel, _BaseModel);

  var _super = _createSuper(SpriteModel);

  function SpriteModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, SpriteModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "mapTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "positions", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "indices", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "timer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "spriteTop", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "spriteUpdate", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "spriteAnimate", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "planeGeometryUpdateTriangulation", function () {
      var _ref = _this.layer.getLayerConfig(),
          _ref$spriteBottom = _ref.spriteBottom,
          spriteBottom = _ref$spriteBottom === void 0 ? -100000 : _ref$spriteBottom;

      var updateZ = _this.spriteUpdate;
      var bottomZ = spriteBottom;
      var topZ = _this.spriteTop;

      for (var i = 0; i < _this.positions.length; i += 5) {
        if (_this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {
          _this.positions[i + 2] += updateZ;

          if (_this.positions[i + 2] > topZ) {
            _this.positions[i + 2] = bottomZ;
          }
        } else {
          _this.positions[i + 2] -= updateZ;

          if (_this.positions[i + 2] < bottomZ) {
            _this.positions[i + 2] = topZ;
          }
        }
      }

      return {
        vertices: _this.positions,
        indices: _this.indices,
        size: 5
      };
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "updateModel", function () {
      var attributes = _this.layer.createAttrubutes({
        triangulation: _this.planeGeometryUpdateTriangulation
      });

      _this.layer.models.map(function (m) {
        m.updateAttributes(attributes);
      });

      _this.layer.renderLayers();

      _this.timer = requestAnimationFrame(_this.updateModel);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "planeGeometryTriangulation", function () {
      var _this2;

      var _ref2 = _this.layer.getLayerConfig(),
          _ref2$center = _ref2.center,
          center = _ref2$center === void 0 ? [120, 30] : _ref2$center,
          _ref2$spriteCount = _ref2.spriteCount,
          spriteCount = _ref2$spriteCount === void 0 ? 100 : _ref2$spriteCount,
          _ref2$spriteRadius = _ref2.spriteRadius,
          spriteRadius = _ref2$spriteRadius === void 0 ? 10 : _ref2$spriteRadius;

      var _this$initSprite = (_this2 = _this).initSprite.apply(_this2, [spriteRadius, spriteCount].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(center))),
          indices = _this$initSprite.indices,
          positions = _this$initSprite.positions;

      _this.positions = positions;
      _this.indices = indices;
      return {
        vertices: positions,
        indices: indices,
        size: 5
      };
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(SpriteModel, [{
    key: "initSprite",
    value: function initSprite() {
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var spriteCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var lng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120;
      var lat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
      var indices = [];
      var positions = [];
      var mapService = this.mapService;
      var heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;

      for (var i = 0; i < spriteCount; i++) {
        var height = Math.random() * heightLimit;
        positions.push.apply(positions, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(getPos(height)));
      }

      for (var _i = 0; _i < spriteCount; _i++) {
        indices.push(_i);
      }

      function getPos(z) {
        var randomX = radius * Math.random();
        var randomY = radius * Math.random();
        var x = -radius / 2 + randomX;
        var y = -radius / 2 + randomY;

        if (mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_10__.Version["GAODE2.x"]) {
          var _ref3 = mapService.lngLatToCoord([x + lng, -y + lat]),
              _ref4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_ref3, 2),
              a = _ref4[0],
              b = _ref4[1];

          return [a, b, z, 0, 0];
        } else {
          return [x + lng, -y + lat, z, 0, 0];
        }
      }

      return {
        indices: indices,
        positions: positions
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var _ref5 = this.layer.getLayerConfig(),
          opacity = _ref5.opacity,
          mapTexture = _ref5.mapTexture,
          _ref5$spriteScale = _ref5.spriteScale,
          spriteScale = _ref5$spriteScale === void 0 ? 1 : _ref5$spriteScale;

      if (this.mapTexture !== mapTexture) {
        var _this$texture;

        this.mapTexture = mapTexture;
        (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
        this.updateTexture(mapTexture);
      }

      return {
        u_opacity: opacity || 1,
        u_mapFlag: mapTexture ? 1 : 0,
        u_texture: this.texture,
        u_Scale: spriteScale
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture2;

      cancelAnimationFrame(this.timer);
      (_this$texture2 = this.texture) === null || _this$texture2 === void 0 ? void 0 : _this$texture2.destroy();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this3 = this;

      var _ref6 = this.layer.getLayerConfig(),
          mapTexture = _ref6.mapTexture,
          _ref6$spriteTop = _ref6.spriteTop,
          spriteTop = _ref6$spriteTop === void 0 ? 5000000 : _ref6$spriteTop,
          _ref6$spriteUpdate = _ref6.spriteUpdate,
          spriteUpdate = _ref6$spriteUpdate === void 0 ? 10000 : _ref6$spriteUpdate,
          _ref6$spriteAnimate = _ref6.spriteAnimate,
          spriteAnimate = _ref6$spriteAnimate === void 0 ? SPRITE_ANIMATE_DIR.DOWN : _ref6$spriteAnimate;

      this.mapTexture = mapTexture;
      this.spriteTop = spriteTop;
      this.spriteUpdate = spriteUpdate;
      spriteAnimate === 'up' ? this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      this.updateTexture(mapTexture);
      setTimeout(function () {
        _this3.updateModel();
      }, 100);
      return [this.layer.buildLayerModel({
        moduleName: 'geometry_sprite',
        vertexShader: spriteVert,
        fragmentShader: spriteFrag,
        triangulation: this.planeGeometryTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.POINTS,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture(mapTexture) {
      var _this4 = this;

      var createTexture2D = this.rendererService.createTexture2D;

      if (mapTexture) {
        var img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = function () {
          _this4.texture = createTexture2D({
            data: img,
            width: img.width,
            height: img.height,
            wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE,
            wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE
          });

          _this4.layerService.updateLayerRenderList();

          _this4.layerService.renderLayers();
        };

        img.src = mapTexture;
      } else {
        this.texture = createTexture2D({
          width: 0,
          height: 0
        });
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      return '';
    }
  }]);

  return SpriteModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=sprite.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/canvas/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/canvas/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CanvasLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/index */ "./node_modules/@antv/l7-layers/es/canvas/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var CanvasLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(CanvasLayer, _BaseLayer);

  var _super = _createSuper(CanvasLayer);

  function CanvasLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, CanvasLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'CanvasLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(CanvasLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models_index__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        canvas: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return 'canvas';
    }
  }]);

  return CanvasLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/canvas/models/canvas.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/canvas/models/canvas.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CanvaModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/interface */ "./node_modules/@antv/l7-layers/es/core/interface.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var CanvaModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(CanvaModel, _BaseModel);

  var _super = _createSuper(CanvaModel);

  function CanvaModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, CanvaModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "updateMode", _core_interface__WEBPACK_IMPORTED_MODULE_8__.CanvasUpdateType.ALWAYS);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "canvas", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "ctx", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "prevSize", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "renderUpdate", function () {
      var _ref = _this.layer.getLayerConfig(),
          _ref$zIndex = _ref.zIndex,
          zIndex = _ref$zIndex === void 0 ? 10 : _ref$zIndex,
          _ref$update = _ref.update,
          update = _ref$update === void 0 ? _core_interface__WEBPACK_IMPORTED_MODULE_8__.CanvasUpdateType.ALWAYS : _ref$update,
          _ref$animateOption = _ref.animateOption,
          animateOption = _ref$animateOption === void 0 ? {
        enable: false,
        duration: 20
      } : _ref$animateOption;

      if (+_this.canvas.style.zIndex === zIndex) {
        _this.canvas.style.zIndex = zIndex + '';
      }

      if (_this.updateMode !== update) {
        _this.updateMode = update;

        _this.unBindListener();

        _this.bindListener();
      }

      if (_this.updateMode === _core_interface__WEBPACK_IMPORTED_MODULE_8__.CanvasUpdateType.ALWAYS && animateOption.enable) {
        _this.renderCanvas();
      }
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "unBindListener", function () {
      _this.mapService.off('mapchange', _this.renderCanvas);

      _this.mapService.off('zoomstart', _this.clearCanvas);

      _this.mapService.off('zoomend', _this.renderCanvas);

      _this.mapService.off('movestart', _this.clearCanvas);

      _this.mapService.off('moveend', _this.renderCanvas);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "bindListener", function () {
      if (_this.updateMode === _core_interface__WEBPACK_IMPORTED_MODULE_8__.CanvasUpdateType.ALWAYS) {
        _this.mapService.on('mapchange', _this.renderCanvas);
      } else {
        _this.mapService.on('zoomstart', _this.clearCanvas);

        _this.mapService.on('zoomend', _this.renderCanvas);

        _this.mapService.on('movestart', _this.clearCanvas);

        _this.mapService.on('moveend', _this.renderCanvas);
      }
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "clearCanvas", function () {
      if (_this.ctx) {
        var _this$rendererService = _this.rendererService.getViewportSize(),
            w = _this$rendererService.width,
            h = _this$rendererService.height;

        _this.ctx.clearRect(0, 0, w, h);
      }
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "renderCanvas", function () {
      var _this$rendererService2 = _this.rendererService.getViewportSize(),
          viewWidth = _this$rendererService2.width,
          viewHeight = _this$rendererService2.height;

      if (_this.prevSize[0] !== viewWidth || _this.prevSize[1] !== viewHeight) {
        _this.prevSize = [viewWidth, viewHeight];

        var size = _this.mapService.getSize();

        var _size = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(size, 2),
            width = _size[0],
            height = _size[1];

        _this.canvas.width = viewWidth;
        _this.canvas.height = viewHeight;
        _this.canvas.style.width = width + 'px';
        _this.canvas.style.height = height + 'px';
      }

      var _ref2 = _this.layer.getLayerConfig(),
          drawingOnCanvas = _ref2.drawingOnCanvas;

      if (_this.ctx) {
        drawingOnCanvas({
          canvas: _this.canvas,
          ctx: _this.ctx,
          mapService: _this.mapService,
          size: [viewWidth, viewHeight]
        });
      }
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(CanvaModel, [{
    key: "clearModels",
    value: function clearModels() {
      if (this.canvas) {
        var _this$mapService$getC;

        (_this$mapService$getC = this.mapService.getContainer()) === null || _this$mapService$getC === void 0 ? void 0 : _this$mapService$getC.removeChild(this.canvas);
        this.canvas = null;
      }

      this.unBindListener();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$update = _ref3.update,
          update = _ref3$update === void 0 ? _core_interface__WEBPACK_IMPORTED_MODULE_8__.CanvasUpdateType.ALWAYS : _ref3$update;

      this.updateMode = update;
      this.initCanvas();
      this.renderCanvas();
      this.bindListener();
      this.mapService.getContainer();
      return [];
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var _this$mapService$getC2;

      var _ref4 = this.layer.getLayerConfig(),
          zIndex = _ref4.zIndex;

      var size = this.mapService.getSize();

      var _size2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(size, 2),
          width = _size2[0],
          height = _size2[1];

      var _this$rendererService3 = this.rendererService.getViewportSize(),
          viewWidth = _this$rendererService3.width,
          viewHeight = _this$rendererService3.height;

      this.prevSize = [viewWidth, viewHeight];
      var canvas = document.createElement('canvas');
      this.canvas = canvas;
      canvas.width = viewWidth;
      canvas.height = viewHeight;
      canvas.style.pointerEvents = 'none';
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.zIndex = zIndex + '';
      (_this$mapService$getC2 = this.mapService.getContainer()) === null || _this$mapService$getC2 === void 0 ? void 0 : _this$mapService$getC2.appendChild(canvas);
      var ctx = canvas.getContext('2d');
      this.ctx = ctx;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      return;
    }
  }]);

  return CanvaModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/canvas/models/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/canvas/models/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas */ "./node_modules/@antv/l7-layers/es/canvas/models/canvas.js");

var CanvasModels = {
  canvas: _canvas__WEBPACK_IMPORTED_MODULE_0__.default
};
/* harmony default export */ __webpack_exports__["default"] = (CanvasModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/citybuliding/building.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/citybuliding/building.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CityBuildingLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_build__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/build */ "./node_modules/@antv/l7-layers/es/citybuliding/models/build.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var CityBuildingLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(CityBuildingLayer, _BaseLayer);

  var _super = _createSuper(CityBuildingLayer);

  function CityBuildingLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, CityBuildingLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'PolygonLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(CityBuildingLayer, [{
    key: "buildModels",
    value: function buildModels() {
      this.layerModel = new _models_build__WEBPACK_IMPORTED_MODULE_7__.default(this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "setLight",
    value: function setLight(t) {
      this.updateLayerConfig({
        time: t
      });
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return 'citybuilding';
    }
  }]);

  return CityBuildingLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=building.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/citybuliding/models/build.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/citybuliding/models/build.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CityBuildModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var buildFrag = "uniform float u_opacity: 1.0;\nuniform vec4 u_baseColor : [ 1.0, 0, 0, 1.0 ];\nuniform vec4 u_brightColor : [ 1.0, 0, 0, 1.0 ];\nuniform vec4 u_windowColor : [ 1.0, 0, 0, 1.0 ];\nuniform float u_near : 0;\nuniform float u_far : 1;\nvarying vec4 v_Color;\nvarying vec2 v_texCoord;\nuniform float u_Zoom : 1;\nuniform float u_time;\n\nuniform float u_circleSweep;\nuniform float u_cityMinSize;\nuniform vec3 u_circleSweepColor;\nuniform float u_circleSweepSpeed;\n\nvarying float v_worldDis;\n\n#pragma include \"picking\"\n\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\n    float s = step(hot, n);\n    vec3 color = mix(brightColor,vec3(0.9,0.9,1.0),n);\n\n    return mix(darkColor, color, s);\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat LinearizeDepth()\n{\n    float z = gl_FragCoord.z * 2.0 - 1.0;\n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\n}\n\nvec3 fog(vec3 color, vec3 fogColor, float depth){\n    float fogFactor=clamp(depth,0.0,1.0);\n    vec3 output_color=mix(fogColor,color,fogFactor);\n    return output_color;\n}\n\nfloat sdRect(vec2 p, vec2 sz) {\n  vec2 d = abs(p) - sz;\n  float outside = length(max(d, 0.));\n  float inside = min(max(d.x, d.y), 0.);\n  return outside + inside;\n}\n\nvoid main() {\n  gl_FragColor = v_Color;\n  vec3 baseColor = u_baseColor.xyz;\n  vec3 brightColor = u_brightColor.xyz;\n  vec3 windowColor = u_windowColor.xyz;\n  float targetColId = 5.;\n  float depth = 1.0 - LinearizeDepth() / u_far * u_Zoom;\n  vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0);\n  if(v_texCoord.x < 0.) { //\u9876\u90E8\u989C\u8272\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\n       gl_FragColor = vec4( foggedColor, v_Color.w);\n  }else { // \u4FA7\u9762\u989C\u8272\n        vec2 st = v_texCoord;\n        vec2  UvScale = v_texCoord;\n        float tStep = min(0.08,max(0.05* (18.0-u_Zoom),0.02));\n        float tStart = 0.25 * tStep;\n        float tEnd = 0.75 * tStep;\n        float u = mod(UvScale.x, tStep);\n        float v = mod(UvScale.y, tStep);\n        float ux = floor(UvScale.x/tStep);\n        float uy = floor(UvScale.y/tStep);\n        float n = random(vec2(ux,uy));\n        float lightP = u_time;\n        float head = 1.0- step(0.005,st.y);\n        /*step3*/\n        // \u5C06\u7A97\u6237\u989C\u8272\u548C\u5899\u9762\u989C\u8272\u533A\u522B\u5F00\u6765\n        float sU = step(tStart, u) - step(tEnd, u);\n        float sV = step(tStart, v) - step(tEnd, v);\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\n        float dist = sdRect(vec2(u,v), windowSize);\n        float s = sU * sV;\n\n        float curColId = floor(UvScale.x / tStep);\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\n\n        float mLightP = mod(lightP, 2.);\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\n        if(ux == targetColId){\n            n =0.;\n        }\n        float timeP = min(0.75, abs ( sin(u_time/3.0) ) );\n        float hot = smoothstep(1.0,0.0,timeP);\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\n        float sFinal = s * sCol * sRow;\n        color += mix(baseColor, brightColor, sFinal*n);\n        if (st.y<0.01){\n        color = baseColor;\n         }\n        if(head ==1.0) { // \u9876\u90E8\u4EAE\u7EBF\n            color = brightColor;\n        }\n        color = color * v_Color.rgb;\n\n        vec3 foggedColor = fog(color,fogColor,depth);\n\n        gl_FragColor = vec4(foggedColor,1.0);\n  }\n\n\n  if(u_circleSweep > 0.0 && v_worldDis < u_cityMinSize) {\n    float r = fract(((v_worldDis/u_cityMinSize) - u_time * u_circleSweepSpeed) * 2.0);\n    gl_FragColor.rgb += r * r * u_circleSweepColor;\n  }\n   \n  gl_FragColor.a *= u_opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var buildVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\n\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n\nvarying vec4 v_Color;\nuniform mat4 u_Mvp;\n\nuniform float u_circleSweep;\nuniform vec2 u_cityCenter;\n\nvarying float v_worldDis;\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n   v_texCoord = a_Uv;\n\n  if(u_circleSweep > 0.0) {\n     vec2 lnglatscale = vec2(0.0);\n    if(u_CoordinateSystem != COORDINATE_SYSTEM_P20_2) {\n      lnglatscale = (a_Position.xy - u_cityCenter) * vec2(0.0, 0.135);\n    }\n    v_worldDis = length(a_Position.xy + lnglatscale - u_cityCenter);\n  }\n \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n";

var CityBuildModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(CityBuildModel, _BaseModel);

  var _super = _createSuper(CityBuildModel);

  function CityBuildModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, CityBuildModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "cityCenter", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "cityMinSize", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(CityBuildModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$baseColor = _ref.baseColor,
          baseColor = _ref$baseColor === void 0 ? 'rgb(16,16,16)' : _ref$baseColor,
          _ref$brightColor = _ref.brightColor,
          brightColor = _ref$brightColor === void 0 ? 'rgb(255,176,38)' : _ref$brightColor,
          _ref$windowColor = _ref.windowColor,
          windowColor = _ref$windowColor === void 0 ? 'rgb(30,60,89)' : _ref$windowColor,
          _ref$time = _ref.time,
          time = _ref$time === void 0 ? 0 : _ref$time,
          _ref$sweep = _ref.sweep,
          sweep = _ref$sweep === void 0 ? {
        enable: false,
        sweepRadius: 1,
        sweepColor: 'rgb(255, 255, 255)',
        sweepSpeed: 0.4,
        sweepCenter: this.cityCenter
      } : _ref$sweep;

      return {
        u_cityCenter: sweep.sweepCenter || this.cityCenter,
        u_cityMinSize: this.cityMinSize * sweep.sweepRadius,
        u_circleSweep: sweep.enable ? 1.0 : 0.0,
        u_circleSweepColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sweep.sweepColor).slice(0, 3),
        u_circleSweepSpeed: sweep.sweepSpeed,
        u_opacity: opacity,
        u_baseColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(baseColor),
        u_brightColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(brightColor),
        u_windowColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(windowColor),
        u_time: this.layer.getLayerAnimateTime() || time
      };
    }
  }, {
    key: "calCityGeo",
    value: function calCityGeo() {
      var _this$layer$getSource = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(this.layer.getSource().extent, 4),
          minLng = _this$layer$getSource[0],
          minLat = _this$layer$getSource[1],
          maxLng = _this$layer$getSource[2],
          maxLat = _this$layer$getSource[3];

      if (this.mapService.version === 'GAODE2.x') {
        this.cityCenter = this.mapService.lngLatToCoord([(maxLng + minLng) / 2, (maxLat + minLat) / 2]);
        var l1 = this.mapService.lngLatToCoord([maxLng, maxLat]);
        var l2 = this.mapService.lngLatToCoord([minLng, minLat]);
        this.cityMinSize = Math.sqrt(Math.pow(l1[0] - l2[0], 2) + Math.pow(l1[1] - l2[1], 2)) / 4;
      } else {
        var w = maxLng - minLng;
        var h = maxLat - minLat;
        this.cityCenter = [(maxLng + minLng) / 2, (maxLat + minLat) / 2];
        this.cityMinSize = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)) / 4;
      }
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.calCityGeo();
      this.startModelAnimate();
      return [this.layer.buildLayerModel({
        moduleName: 'cityBuilding',
        vertexShader: buildVert,
        fragmentShader: buildFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PolygonExtrudeTriangulation,
        cull: {
          enable: true,
          face: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.BACK
        }
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 10 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var size = feature.size;
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return CityBuildModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=build.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/BaseLayer.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BaseLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var lodash_isUndefined__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js");
/* harmony import */ var lodash_isUndefined__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash_isUndefined__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js");
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @antv/async-hook */ "./node_modules/@antv/async-hook/es/index.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _utils_blend__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../utils/blend */ "./node_modules/@antv/l7-layers/es/utils/blend.js");
/* harmony import */ var _utils_dataMappingStyle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utils/dataMappingStyle */ "./node_modules/@antv/l7-layers/es/utils/dataMappingStyle.js");
/* harmony import */ var _utils_layerData__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utils/layerData */ "./node_modules/@antv/l7-layers/es/utils/layerData.js");
/* harmony import */ var _utils_multiPassRender__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../utils/multiPassRender */ "./node_modules/@antv/l7-layers/es/utils/multiPassRender.js");
/* harmony import */ var _utils_updateShape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../utils/updateShape */ "./node_modules/@antv/l7-layers/es/utils/updateShape.js");















var _excluded = ["passes"],
    _excluded2 = ["moduleName", "vertexShader", "fragmentShader", "triangulation", "segmentNumber"];

var _dec, _class, _descriptor;



function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











var layerIdCounter = 0;
var BaseLayer = (_dec = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.lazyInject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IGlobalConfigService), (_class = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__.default)(BaseLayer, _EventEmitter);

  var _super = _createSuper(BaseLayer);

  function BaseLayer() {
    var _this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__.default)(this, BaseLayer);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "id", "".concat(layerIdCounter++));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "name", "".concat(layerIdCounter));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "type", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "visible", true);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "zIndex", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "minZoom", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "maxZoom", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "inited", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerModelNeedUpdate", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "pickedFeatureID", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "selectedFeatureID", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "styleNeedUpdate", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "rendering", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "clusterZoom", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerType", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "triangulation", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "dataState", {
      dataSourceNeedUpdate: false,
      dataMappingNeedUpdate: false,
      filterNeedUpdate: false,
      featureScaleNeedUpdate: false,
      StyleAttrNeedUpdate: false
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "hooks", {
      init: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncBailHook(),
      afterInit: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncBailHook(),
      beforeRender: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncBailHook(),
      beforeRenderData: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncWaterfallHook(),
      afterRender: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      beforePickingEncode: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      afterPickingEncode: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      beforeHighlight: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(['pickedColor']),
      afterHighlight: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      beforeSelect: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(['pickedColor']),
      afterSelect: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      beforeDestroy: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook(),
      afterDestroy: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_16__.SyncHook()
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "models", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "multiPassRenderer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "plugins", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "sourceOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerModel", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "shapeOption", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "sceneContainer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "tileLayer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerChildren", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "masks", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "isVector", false);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_2__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "configService", _descriptor, (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "shaderModuleService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "cameraService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "coordinateService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "iconService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "fontService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "pickingService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "rendererService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "interactionService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "styleAttributeService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "layerSource", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "postProcessingPassFactory", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "normalPassFactory", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "animateOptions", {
      enable: false
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "container", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "encodedData", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "configSchema", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "currentPickId", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "rawConfig", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "needUpdateConfig", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "pendingStyleAttributes", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "scaleOptions", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "animateStartTime", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "aniamateStatus", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "bottomColor", 'rgba(0, 0, 0, 0)');

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "isDestroied", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), "sourceEvent", function () {
      _this.dataState.dataSourceNeedUpdate = true;

      var _this$getLayerConfig = _this.getLayerConfig(),
          autoFit = _this$getLayerConfig.autoFit,
          fitBoundsOptions = _this$getLayerConfig.fitBoundsOptions;

      if (autoFit) {
        _this.fitBounds(fitBoundsOptions);
      }

      _this.reRender();
    });

    _this.name = config.name || _this.id;
    _this.zIndex = config.zIndex || 0;
    _this.rawConfig = config;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__.default)(BaseLayer, [{
    key: "addMaskLayer",
    value: function addMaskLayer(maskLayer) {
      this.masks.push(maskLayer);
    }
  }, {
    key: "removeMaskLayer",
    value: function removeMaskLayer(maskLayer) {
      var layerIndex = this.masks.indexOf(maskLayer);

      if (layerIndex > -1) {
        this.masks.splice(layerIndex, 1);
      }

      maskLayer.destroy();
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.styleAttributeService.getLayerStyleAttribute(name);
    }
  }, {
    key: "getLayerConfig",
    value: function getLayerConfig() {
      return this.configService.getLayerConfig(this.id);
    }
  }, {
    key: "updateLayerConfig",
    value: function updateLayerConfig(configToUpdate) {
      this.updateRawConfig(configToUpdate);

      if (!this.inited) {
        this.needUpdateConfig = _objectSpread(_objectSpread({}, this.needUpdateConfig), configToUpdate);
      } else {
        var sceneId = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.SceneID);
        (0,_utils_dataMappingStyle__WEBPACK_IMPORTED_MODULE_21__.handleStyleDataMapping)(configToUpdate, this);
        this.configService.setLayerConfig(sceneId, this.id, _objectSpread(_objectSpread(_objectSpread({}, this.configService.getLayerConfig(this.id)), this.needUpdateConfig), configToUpdate));
        this.needUpdateConfig = {};
      }
    }
  }, {
    key: "setContainer",
    value: function setContainer(container, sceneContainer) {
      this.container = container;
      this.sceneContainer = sceneContainer;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }
  }, {
    key: "setBottomColor",
    value: function setBottomColor(color) {
      this.bottomColor = color;
    }
  }, {
    key: "getBottomColor",
    value: function getBottomColor() {
      return this.bottomColor;
    }
  }, {
    key: "addPlugin",
    value: function addPlugin(plugin) {
      this.plugins.push(plugin);
      return this;
    }
  }, {
    key: "init",
    value: function init() {
      var _this2 = this;

      var sceneId = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.SceneID);
      this.configService.setLayerConfig(sceneId, this.id, this.rawConfig);
      this.layerType = this.rawConfig.layerType;
      this.iconService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IIconService);
      this.fontService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IFontService);
      this.rendererService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IRendererService);
      this.layerService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.ILayerService);
      this.interactionService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IInteractionService);
      this.pickingService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IPickingService);
      this.mapService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IMapService);

      var _this$getLayerConfig2 = this.getLayerConfig(),
          enableMultiPassRenderer = _this$getLayerConfig2.enableMultiPassRenderer,
          passes = _this$getLayerConfig2.passes;

      if (enableMultiPassRenderer && passes !== null && passes !== void 0 && passes.length && passes.length > 0) {
        this.mapService.on('mapAfterFrameChange', function () {
          _this2.renderLayers();
        });
      }

      this.cameraService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.ICameraService);
      this.coordinateService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.ICoordinateSystemService);
      this.shaderModuleService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IShaderModuleService);
      this.postProcessingPassFactory = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IFactoryPostProcessingPass);
      this.normalPassFactory = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IFactoryNormalPass);
      this.styleAttributeService = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IStyleAttributeService);
      this.multiPassRenderer = this.container.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.IMultiPassRenderer);
      this.multiPassRenderer.setLayer(this);
      this.pendingStyleAttributes.forEach(function (_ref) {
        var attributeName = _ref.attributeName,
            attributeField = _ref.attributeField,
            attributeValues = _ref.attributeValues,
            updateOptions = _ref.updateOptions;

        _this2.styleAttributeService.updateStyleAttribute(attributeName, {
          scale: _objectSpread({
            field: attributeField
          }, _this2.splitValuesAndCallbackInAttribute(attributeValues, _this2.getLayerConfig()[attributeName]))
        }, updateOptions);
      });
      this.pendingStyleAttributes = [];
      this.plugins = this.container.getAll(_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.TYPES.ILayerPlugin);

      var _iterator = _createForOfIteratorHelper(this.plugins),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var plugin = _step.value;
          plugin.apply(this, {
            rendererService: this.rendererService,
            mapService: this.mapService,
            styleAttributeService: this.styleAttributeService,
            normalPassFactory: this.normalPassFactory,
            postProcessingPassFactory: this.postProcessingPassFactory
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.hooks.init.call();
      this.hooks.afterInit.call();
      this.emit('inited', {
        target: this,
        type: 'inited'
      });
      this.emit('add', {
        target: this,
        type: 'add'
      });
      return this;
    }
  }, {
    key: "updateModelData",
    value: function updateModelData(data) {
      if (data.attributes && data.elements) {
        this.models.map(function (m) {
          m.updateAttributesAndElements(data.attributes, data.elements);
        });
      } else {
        console.warn('data error');
      }
    }
  }, {
    key: "createModelData",
    value: function createModelData(data, option) {
      if (this.layerModel.createModelData) {
        return this.layerModel.createModelData(option);
      }

      var calEncodeData = this.calculateEncodeData(data, option);
      var triangulation = this.triangulation;

      if (calEncodeData && triangulation) {
        return this.styleAttributeService.createAttributesAndIndices(calEncodeData, triangulation);
      } else {
        return {
          attributes: undefined,
          elements: undefined
        };
      }
    }
  }, {
    key: "calculateEncodeData",
    value: function calculateEncodeData(data, option) {
      if (this.inited) {
        return (0,_utils_layerData__WEBPACK_IMPORTED_MODULE_22__.calculateData)(this, this.fontService, this.mapService, this.styleAttributeService, data, option);
      } else {
        console.warn('layer not inited!');
        return null;
      }
    }
  }, {
    key: "prepareBuildModel",
    value: function prepareBuildModel() {
      this.inited = true;
      this.updateLayerConfig(_objectSpread(_objectSpread({}, this.getDefaultConfig()), this.rawConfig));

      var _this$getLayerConfig3 = this.getLayerConfig(),
          animateOption = _this$getLayerConfig3.animateOption;

      if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
        this.layerService.startAnimate();
        this.aniamateStatus = true;
      }
    }
  }, {
    key: "color",
    value: function color(field, values, updateOptions) {
      this.updateStyleAttribute('color', field, values, updateOptions);
      return this;
    }
  }, {
    key: "texture",
    value: function texture(field, values, updateOptions) {
      this.updateStyleAttribute('texture', field, values, updateOptions);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(field, values, updateOptions) {
      this.updateStyleAttribute('rotate', field, values, updateOptions);
      return this;
    }
  }, {
    key: "size",
    value: function size(field, values, updateOptions) {
      this.updateStyleAttribute('size', field, values, updateOptions);
      return this;
    }
  }, {
    key: "filter",
    value: function filter(field, values, updateOptions) {
      this.updateStyleAttribute('filter', field, values, updateOptions);
      return this;
    }
  }, {
    key: "shape",
    value: function shape(field, values, updateOptions) {
      var _this$styleAttributeS, _this$styleAttributeS2, _this$styleAttributeS3;

      var lastShape = (_this$styleAttributeS = this.styleAttributeService) === null || _this$styleAttributeS === void 0 ? void 0 : (_this$styleAttributeS2 = _this$styleAttributeS.getLayerStyleAttribute('shape')) === null || _this$styleAttributeS2 === void 0 ? void 0 : (_this$styleAttributeS3 = _this$styleAttributeS2.scale) === null || _this$styleAttributeS3 === void 0 ? void 0 : _this$styleAttributeS3.field;
      var currentShape = field;
      this.shapeOption = {
        field: field,
        values: values
      };
      this.updateStyleAttribute('shape', field, values, updateOptions);

      if (!this.tileLayer) {
        (0,_utils_updateShape__WEBPACK_IMPORTED_MODULE_23__.updateShape)(this, lastShape, currentShape);
      }

      return this;
    }
  }, {
    key: "label",
    value: function label(field, values, updateOptions) {
      this.pendingStyleAttributes.push({
        attributeName: 'label',
        attributeField: field,
        attributeValues: values,
        updateOptions: updateOptions
      });
      return this;
    }
  }, {
    key: "animate",
    value: function animate(options) {
      var rawAnimate = {};

      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options)) {
        rawAnimate.enable = true;
        rawAnimate = _objectSpread(_objectSpread({}, rawAnimate), options);
      } else {
        rawAnimate.enable = options;
      }

      this.updateLayerConfig({
        animateOption: rawAnimate
      });
      return this;
    }
  }, {
    key: "source",
    value: function source(data, options) {
      if (data !== null && data !== void 0 && data.data) {
        this.setSource(data);
        return this;
      }

      this.sourceOption = {
        data: data,
        options: options
      };
      this.clusterZoom = 0;
      return this;
    }
  }, {
    key: "setData",
    value: function setData(data, options) {
      var _this3 = this;

      if (this.inited) {
        this.layerSource.setData(data, options);
      } else {
        this.on('inited', function () {
          var currentSource = _this3.getSource();

          if (!currentSource) {
            _this3.source(new _antv_l7_source__WEBPACK_IMPORTED_MODULE_18__.default(data, options));

            _this3.sourceEvent();
          } else {
            _this3.layerSource.setData(data, options);
          }
        });
      }

      return this;
    }
  }, {
    key: "style",
    value: function style(options) {
      var _this4 = this;

      var lastConfig = this.getLayerConfig();

      var passes = options.passes,
          rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__.default)(options, _excluded);

      if (passes) {
        (0,_utils_multiPassRender__WEBPACK_IMPORTED_MODULE_24__.normalizePasses)(passes).forEach(function (pass) {
          var postProcessingPass = _this4.multiPassRenderer.getPostProcessor().getPostProcessingPassByName(pass[0]);

          if (postProcessingPass) {
            postProcessingPass.updateOptions(pass[1]);
          }
        });
      }

      this.rawConfig = _objectSpread(_objectSpread({}, this.rawConfig), rest);

      if (this.container) {
        this.updateLayerConfig(this.rawConfig);
        this.styleNeedUpdate = true;
      }

      if (lastConfig && lastConfig.mask === true && options.mask === false) {
        this.clearModels();
        this.models = this.layerModel.buildModels();
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale(field, cfg) {
      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(field)) {
        this.scaleOptions = _objectSpread(_objectSpread({}, this.scaleOptions), field);
      } else {
        this.scaleOptions[field] = cfg;
      }

      return this;
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      this.rendering = true;
      this.layerService.renderLayers();
      this.rendering = false;
    }
  }, {
    key: "render",
    value: function render() {
      if (this.tileLayer !== undefined) {
        this.tileLayer.render();
        return this;
      }

      if (this.getEncodedData().length !== 0) {
        this.renderModels();
      }

      return this;
    }
  }, {
    key: "renderMultiPass",
    value: function () {
      var _renderMultiPass = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15___default().mark(function _callee() {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.getEncodedData().length !== 0)) {
                  _context.next = 7;
                  break;
                }

                if (!(this.multiPassRenderer && this.multiPassRenderer.getRenderFlag())) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return this.multiPassRenderer.render();

              case 4:
                _context.next = 7;
                break;

              case 6:
                if (this.multiPassRenderer) {
                  this.renderModels();
                } else {
                  this.renderModels();
                }

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function renderMultiPass() {
        return _renderMultiPass.apply(this, arguments);
      }

      return renderMultiPass;
    }()
  }, {
    key: "active",
    value: function active(options) {
      var activeOption = {};
      activeOption.enableHighlight = lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? true : options;

      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options)) {
        activeOption.enableHighlight = true;

        if (options.color) {
          activeOption.highlightColor = options.color;
        }

        if (options.mix) {
          activeOption.activeMix = options.mix;
        }
      } else {
        activeOption.enableHighlight = !!options;
      }

      this.updateLayerConfig(activeOption);
      return this;
    }
  }, {
    key: "setActive",
    value: function setActive(id, options) {
      var _this5 = this;

      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(id)) {
        var _id$x = id.x,
            x = _id$x === void 0 ? 0 : _id$x,
            _id$y = id.y,
            y = _id$y === void 0 ? 0 : _id$y;
        this.updateLayerConfig({
          highlightColor: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.color : this.getLayerConfig().highlightColor,
          activeMix: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.mix : this.getLayerConfig().activeMix
        });
        this.pick({
          x: x,
          y: y
        });
      } else {
        this.updateLayerConfig({
          pickedFeatureID: id,
          highlightColor: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.color : this.getLayerConfig().highlightColor,
          activeMix: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.mix : this.getLayerConfig().activeMix
        });
        this.hooks.beforeSelect.call((0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_19__.encodePickingColor)(id)).then(function () {
          setTimeout(function () {
            _this5.reRender();
          }, 1);
        });
      }
    }
  }, {
    key: "select",
    value: function select(option) {
      var activeOption = {};
      activeOption.enableSelect = lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(option) ? true : option;

      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(option)) {
        activeOption.enableSelect = true;

        if (option.color) {
          activeOption.selectColor = option.color;
        }

        if (option.mix) {
          activeOption.selectMix = option.mix;
        }
      } else {
        activeOption.enableSelect = !!option;
      }

      this.updateLayerConfig(activeOption);
      return this;
    }
  }, {
    key: "setSelect",
    value: function setSelect(id, options) {
      var _this6 = this;

      if (lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(id)) {
        var _id$x2 = id.x,
            x = _id$x2 === void 0 ? 0 : _id$x2,
            _id$y2 = id.y,
            y = _id$y2 === void 0 ? 0 : _id$y2;
        this.updateLayerConfig({
          selectColor: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.color : this.getLayerConfig().selectColor,
          selectMix: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.mix : this.getLayerConfig().selectMix
        });
        this.pick({
          x: x,
          y: y
        });
      } else {
        this.updateLayerConfig({
          pickedFeatureID: id,
          selectColor: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.color : this.getLayerConfig().selectColor,
          selectMix: lodash_isObject__WEBPACK_IMPORTED_MODULE_13___default()(options) ? options.mix : this.getLayerConfig().selectMix
        });
        this.hooks.beforeSelect.call((0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_19__.encodePickingColor)(id)).then(function () {
          setTimeout(function () {
            _this6.reRender();
          }, 1);
        });
      }
    }
  }, {
    key: "setBlend",
    value: function setBlend(type) {
      this.updateLayerConfig({
        blend: type
      });
      this.layerModelNeedUpdate = true;
      this.reRender();
      return this;
    }
  }, {
    key: "show",
    value: function show() {
      this.updateLayerConfig({
        visible: true
      });
      this.reRender();
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      if (this.type === 'CanvasLayer' && this.layerModel.clearCanvas) {
        this.layerModel.clearCanvas();
      }

      this.updateLayerConfig({
        visible: false
      });
      this.reRender();
      return this;
    }
  }, {
    key: "setIndex",
    value: function setIndex(index) {
      this.zIndex = index;
      this.layerService.updateLayerRenderList();
      this.layerService.renderLayers();
      return this;
    }
  }, {
    key: "setCurrentPickId",
    value: function setCurrentPickId(id) {
      this.currentPickId = id;
    }
  }, {
    key: "getCurrentPickId",
    value: function getCurrentPickId() {
      return this.currentPickId;
    }
  }, {
    key: "setCurrentSelectedId",
    value: function setCurrentSelectedId(id) {
      this.selectedFeatureID = id;
    }
  }, {
    key: "getCurrentSelectedId",
    value: function getCurrentSelectedId() {
      return this.selectedFeatureID;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      var zoom = this.mapService.getZoom();

      var _this$getLayerConfig4 = this.getLayerConfig(),
          visible = _this$getLayerConfig4.visible,
          _this$getLayerConfig5 = _this$getLayerConfig4.minZoom,
          minZoom = _this$getLayerConfig5 === void 0 ? -Infinity : _this$getLayerConfig5,
          _this$getLayerConfig6 = _this$getLayerConfig4.maxZoom,
          maxZoom = _this$getLayerConfig6 === void 0 ? Infinity : _this$getLayerConfig6;

      return !!visible && zoom >= minZoom && zoom <= maxZoom;
    }
  }, {
    key: "setMultiPass",
    value: function setMultiPass(enableMultiPass, currentPasses) {
      this.updateLayerConfig({
        enableMultiPassRenderer: enableMultiPass
      });

      if (currentPasses) {
        this.updateLayerConfig({
          passes: currentPasses
        });
      }

      if (enableMultiPass) {
        var _this$getLayerConfig7 = this.getLayerConfig(),
            _this$getLayerConfig8 = _this$getLayerConfig7.passes,
            passes = _this$getLayerConfig8 === void 0 ? [] : _this$getLayerConfig8;

        this.multiPassRenderer = (0,_utils_multiPassRender__WEBPACK_IMPORTED_MODULE_24__.createMultiPassRenderer)(this, passes, this.postProcessingPassFactory, this.normalPassFactory);
        this.multiPassRenderer.setRenderFlag(true);

        var _this$rendererService = this.rendererService.getViewportSize(),
            width = _this$rendererService.width,
            height = _this$rendererService.height;

        this.multiPassRenderer.resize(width, height);
      }

      return this;
    }
  }, {
    key: "setMinZoom",
    value: function setMinZoom(minZoom) {
      this.updateLayerConfig({
        minZoom: minZoom
      });
      return this;
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      var _this$getLayerConfig9 = this.getLayerConfig(),
          minZoom = _this$getLayerConfig9.minZoom;

      return minZoom;
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      var _this$getLayerConfig10 = this.getLayerConfig(),
          maxZoom = _this$getLayerConfig10.maxZoom;

      return maxZoom;
    }
  }, {
    key: "get",
    value: function get(name) {
      var cfg = this.getLayerConfig();
      return cfg[name];
    }
  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(maxZoom) {
      this.updateLayerConfig({
        maxZoom: maxZoom
      });
      return this;
    }
  }, {
    key: "setAutoFit",
    value: function setAutoFit(autoFit) {
      this.updateLayerConfig({
        autoFit: autoFit
      });
      return this;
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(fitBoundsOptions) {
      if (!this.inited) {
        this.updateLayerConfig({
          autoFit: true
        });
        return this;
      }

      var source = this.getSource();
      var extent = source.extent;
      var isValid = extent.some(function (v) {
        return Math.abs(v) === Infinity;
      });

      if (isValid) {
        return this;
      }

      this.mapService.fitBounds([[extent[0], extent[1]], [extent[2], extent[3]]], fitBoundsOptions);
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$layerModel;

      var refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.isDestroied) {
        return;
      }

      this.layerChildren.map(function (child) {
        return child.destroy();
      });
      this.layerChildren = [];
      this.masks.map(function (mask) {
        return mask.destroy();
      });
      this.masks = [];
      this.hooks.beforeDestroy.call();
      this.layerSource.off('update', this.sourceEvent);
      this.multiPassRenderer.destroy();
      this.styleAttributeService.clearAllAttributes();
      this.hooks.afterDestroy.call();
      (_this$layerModel = this.layerModel) === null || _this$layerModel === void 0 ? void 0 : _this$layerModel.clearModels();
      this.models = [];
      this.layerService.cleanRemove(this, refresh);
      this.emit('remove', {
        target: this,
        type: 'remove'
      });
      this.emit('destroy', {
        target: this,
        type: 'destroy'
      });
      this.removeAllListeners();
      this.isDestroied = true;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.styleAttributeService.clearAllAttributes();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      this.models.forEach(function (model) {
        return model.destroy();
      });
      this.layerModel.clearModels();
      this.models = [];
    }
  }, {
    key: "isDirty",
    value: function isDirty() {
      return !!(this.styleAttributeService.getLayerStyleAttributes() || []).filter(function (attribute) {
        return attribute.needRescale || attribute.needRemapping || attribute.needRegenerateVertices;
      }).length;
    }
  }, {
    key: "setSource",
    value: function setSource(source) {
      if (this.layerSource) {
        this.layerSource.off('update', this.sourceEvent);
      }

      this.layerSource = source;
      this.clusterZoom = 0;

      if (this.inited && this.layerSource.cluster) {
        var zoom = this.mapService.getZoom();
        this.layerSource.updateClusterData(zoom);
      }

      this.layerSource.on('update', this.sourceEvent);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this.layerSource;
    }
  }, {
    key: "getScaleOptions",
    value: function getScaleOptions() {
      return this.scaleOptions;
    }
  }, {
    key: "setEncodedData",
    value: function setEncodedData(encodedData) {
      this.encodedData = encodedData;
    }
  }, {
    key: "getEncodedData",
    value: function getEncodedData() {
      return this.encodedData;
    }
  }, {
    key: "getScale",
    value: function getScale(name) {
      return this.styleAttributeService.getLayerAttributeScale(name);
    }
  }, {
    key: "getLegendItems",
    value: function getLegendItems(name) {
      var scale = this.styleAttributeService.getLayerAttributeScale(name);

      if (!scale) {
        return [];
      }

      if (scale.invertExtent) {
        var items = scale.range().map(function (item) {
          return (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)({
            value: scale.invertExtent(item)
          }, name, item);
        });
        return items;
      } else if (scale.ticks) {
        var _items = scale.ticks().map(function (item) {
          return (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)({
            value: item
          }, name, scale(item));
        });

        return _items;
      } else if (scale !== null && scale !== void 0 && scale.domain) {
        var _items2 = scale.domain().filter(function (item) {
          return !lodash_isUndefined__WEBPACK_IMPORTED_MODULE_12___default()(item);
        }).map(function (item) {
          return (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_9__.default)({
            value: item
          }, name, scale(item));
        });

        return _items2;
      }

      return [];
    }
  }, {
    key: "pick",
    value: function pick(_ref5) {
      var x = _ref5.x,
          y = _ref5.y;
      this.interactionService.triggerHover({
        x: x,
        y: y
      });
    }
  }, {
    key: "boxSelect",
    value: function boxSelect(box, cb) {
      this.pickingService.boxPickLayer(this, box, cb);
    }
  }, {
    key: "buildLayerModel",
    value: function buildLayerModel(options) {
      var moduleName = options.moduleName,
          vertexShader = options.vertexShader,
          fragmentShader = options.fragmentShader,
          triangulation = options.triangulation,
          segmentNumber = options.segmentNumber,
          rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__.default)(options, _excluded2);

      this.shaderModuleService.registerModule(moduleName, {
        vs: vertexShader,
        fs: fragmentShader
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule(moduleName),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var createModel = this.rendererService.createModel;

      var _this$styleAttributeS4 = this.styleAttributeService.createAttributesAndIndices(this.encodedData, triangulation, segmentNumber),
          attributes = _this$styleAttributeS4.attributes,
          elements = _this$styleAttributeS4.elements;

      return createModel(_objectSpread({
        attributes: attributes,
        uniforms: uniforms,
        fs: fs,
        vs: vs,
        elements: elements,
        blend: _utils_blend__WEBPACK_IMPORTED_MODULE_25__.BlendTypes[_antv_l7_core__WEBPACK_IMPORTED_MODULE_17__.BlendType.normal]
      }, rest));
    }
  }, {
    key: "createAttrubutes",
    value: function createAttrubutes(options) {
      var triangulation = options.triangulation;

      var _this$styleAttributeS5 = this.styleAttributeService.createAttributes(this.encodedData, triangulation),
          attributes = _this$styleAttributeS5.attributes;

      return attributes;
    }
  }, {
    key: "getTime",
    value: function getTime() {
      return this.layerService.clock.getDelta();
    }
  }, {
    key: "setAnimateStartTime",
    value: function setAnimateStartTime() {
      this.animateStartTime = this.layerService.clock.getElapsedTime();
    }
  }, {
    key: "stopAnimate",
    value: function stopAnimate() {
      if (this.aniamateStatus) {
        this.layerService.stopAnimate();
        this.aniamateStatus = false;
        this.updateLayerConfig({
          animateOption: {
            enable: false
          }
        });
      }
    }
  }, {
    key: "getLayerAnimateTime",
    value: function getLayerAnimateTime() {
      return this.layerService.clock.getElapsedTime() - this.animateStartTime;
    }
  }, {
    key: "needPick",
    value: function needPick(type) {
      var _this$getLayerConfig11 = this.getLayerConfig(),
          _this$getLayerConfig12 = _this$getLayerConfig11.enableHighlight,
          enableHighlight = _this$getLayerConfig12 === void 0 ? true : _this$getLayerConfig12,
          _this$getLayerConfig13 = _this$getLayerConfig11.enableSelect,
          enableSelect = _this$getLayerConfig13 === void 0 ? true : _this$getLayerConfig13;

      var isPick = this.eventNames().indexOf(type) !== -1 || this.eventNames().indexOf('un' + type) !== -1;

      if ((type === 'click' || type === 'dblclick') && enableSelect) {
        isPick = true;
      }

      if (type === 'mousemove' && (enableHighlight || this.eventNames().indexOf('mouseenter') !== -1 || this.eventNames().indexOf('unmousemove') !== -1 || this.eventNames().indexOf('mouseout') !== -1)) {
        isPick = true;
      }

      return this.isVisible() && isPick;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "renderMulPass",
    value: function () {
      var _renderMulPass = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15___default().mark(function _callee2(multiPassRenderer) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_15___default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return multiPassRenderer.render();

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function renderMulPass(_x) {
        return _renderMulPass.apply(this, arguments);
      }

      return renderMulPass;
    }()
  }, {
    key: "renderModels",
    value: function renderModels(isPicking) {
      var _this7 = this;

      if (this.getEncodedData().length > 0) {
        if (this.layerModelNeedUpdate && this.layerModel) {
          this.models = this.layerModel.buildModels();
          this.hooks.beforeRender.call();
          this.layerModelNeedUpdate = false;
        }

        if (this.layerModel.renderUpdate) {
          this.layerModel.renderUpdate();
        }

        this.models.forEach(function (model) {
          model.draw({
            uniforms: _this7.layerModel.getUninforms()
          }, isPicking);
        });
      }

      return this;
    }
  }, {
    key: "updateStyleAttribute",
    value: function updateStyleAttribute(type, field, values, updateOptions) {
      if (!this.inited) {
        this.pendingStyleAttributes.push({
          attributeName: type,
          attributeField: field,
          attributeValues: values,
          updateOptions: updateOptions
        });
      } else {
        this.styleAttributeService.updateStyleAttribute(type, {
          scale: _objectSpread({
            field: field
          }, this.splitValuesAndCallbackInAttribute(values, this.getLayerConfig()[field]))
        }, updateOptions);
      }
    }
  }, {
    key: "getShaderPickStat",
    value: function getShaderPickStat() {
      return this.layerService.getShaderPickStat();
    }
  }, {
    key: "setEarthTime",
    value: function setEarthTime(time) {
      console.warn('empty fn');
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {};
    }
  }, {
    key: "updateRawConfig",
    value: function updateRawConfig(configToUpdate) {
      var _this8 = this;

      Object.keys(configToUpdate).map(function (key) {
        if (_this8.rawConfig[key] && _this8.rawConfig[key] !== configToUpdate[key]) {
          _this8.rawConfig[key] = configToUpdate[key];
        }
      });
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (this.inited) {
        this.layerService.updateLayerRenderList();
        this.layerService.renderLayers();
      }
    }
  }, {
    key: "splitValuesAndCallbackInAttribute",
    value: function splitValuesAndCallbackInAttribute(valuesOrCallback, defaultValues) {
      return {
        values: lodash_isFunction__WEBPACK_IMPORTED_MODULE_14___default()(valuesOrCallback) ? undefined : valuesOrCallback || defaultValues,
        callback: lodash_isFunction__WEBPACK_IMPORTED_MODULE_14___default()(valuesOrCallback) ? valuesOrCallback : undefined
      };
    }
  }]);

  return BaseLayer;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_20__.EventEmitter), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_10__.default)(_class.prototype, "configService", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class));

//# sourceMappingURL=BaseLayer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/BaseModel.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/BaseModel.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BaseModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _utils_blend__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/blend */ "./node_modules/@antv/l7-layers/es/utils/blend.js");











var _dec, _class, _descriptor;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





var BaseModel = (_dec = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.lazyInject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IGlobalConfigService), (_class = function () {
  function BaseModel(layer) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, BaseModel);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "triangulation", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "createTexture2D", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "layer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "dataTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "DATA_TEXTURE_WIDTH", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "rowCount", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cacheStyleProperties", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cellLength", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cellProperties", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cellTypeLayout", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "stylePropertyesExist", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "dataTextureTest", void 0);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(this, "configService", _descriptor, this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "shaderModuleService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "rendererService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "iconService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "fontService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "styleAttributeService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cameraService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "pickingService", void 0);

    this.layer = layer;
    this.rendererService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IRendererService);
    this.pickingService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IPickingService);
    this.shaderModuleService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IShaderModuleService);
    this.styleAttributeService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IStyleAttributeService);
    this.mapService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IMapService);
    this.iconService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IIconService);
    this.fontService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.IFontService);
    this.cameraService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.ICameraService);
    this.layerService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.TYPES.ILayerService);
    this.registerBuiltinAttributes();
    this.startModelAnimate();
    var createTexture2D = this.rendererService.createTexture2D;
    this.createTexture2D = createTexture2D;
    this.DATA_TEXTURE_WIDTH = 1024;
    this.rowCount = 1;
    this.cellLength = 0;
    this.cellProperties = [];
    this.cacheStyleProperties = {
      thetaOffset: undefined,
      opacity: undefined,
      strokeOpacity: undefined,
      strokeWidth: undefined,
      stroke: undefined,
      offsets: undefined
    };
    this.stylePropertyesExist = {
      hasThetaOffset: 0,
      hasOpacity: 0,
      hasStrokeOpacity: 0,
      hasStrokeWidth: 0,
      hasStroke: 0,
      hasOffsets: 0
    };
    this.dataTextureTest = this.layerService.getOESTextureFloat();

    if (!this.dataTextureTest) {
      this.dataTexture = this.createTexture2D({
        data: new Uint8Array(4),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.NEAREST,
        width: 1,
        height: 1
      });
    }
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(BaseModel, [{
    key: "clearLastCalRes",
    value: function clearLastCalRes() {
      this.cellProperties = [];
      this.cellLength = 0;
      this.stylePropertyesExist = {
        hasThetaOffset: 0,
        hasOpacity: 0,
        hasStrokeOpacity: 0,
        hasStrokeWidth: 0,
        hasStroke: 0,
        hasOffsets: 0
      };
    }
  }, {
    key: "getCellTypeLayout",
    value: function getCellTypeLayout() {
      if (this.dataTextureTest) {
        return [this.rowCount, this.DATA_TEXTURE_WIDTH, 0.0, 0.0, this.stylePropertyesExist.hasOpacity, this.stylePropertyesExist.hasStrokeOpacity, this.stylePropertyesExist.hasStrokeWidth, this.stylePropertyesExist.hasStroke, this.stylePropertyesExist.hasOffsets, this.stylePropertyesExist.hasThetaOffset, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0];
      } else {
        return [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0];
      }
    }
  }, {
    key: "dataTextureNeedUpdate",
    value: function dataTextureNeedUpdate(options) {
      var isUpdate = false;

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.thetaOffset, this.cacheStyleProperties.thetaOffset)) {
        isUpdate = true;
        this.cacheStyleProperties.thetaOffset = options.thetaOffset;
      }

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.opacity, this.cacheStyleProperties.opacity)) {
        isUpdate = true;
        this.cacheStyleProperties.opacity = options.opacity;
      }

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.strokeOpacity, this.cacheStyleProperties.strokeOpacity)) {
        isUpdate = true;
        this.cacheStyleProperties.strokeOpacity = options.strokeOpacity;
      }

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.strokeWidth, this.cacheStyleProperties.strokeWidth)) {
        isUpdate = true;
        this.cacheStyleProperties.strokeWidth = options.strokeWidth;
      }

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.stroke, this.cacheStyleProperties.stroke)) {
        isUpdate = true;
        this.cacheStyleProperties.stroke = options.stroke;
      }

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_9___default()(options.offsets, this.cacheStyleProperties.offsets)) {
        isUpdate = true;
        this.cacheStyleProperties.offsets = options.offsets;
      }

      if (this.dataTexture === undefined) {
        isUpdate = true;
      }

      return isUpdate;
    }
  }, {
    key: "judgeStyleAttributes",
    value: function judgeStyleAttributes(options) {
      this.clearLastCalRes();

      if (options.opacity !== undefined && !lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(options.opacity)) {
        this.cellProperties.push({
          attr: 'opacity',
          count: 1
        });
        this.stylePropertyesExist.hasOpacity = 1;
        this.cellLength += 1;
      }

      if (options.strokeOpacity !== undefined && !lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(options.strokeOpacity)) {
        this.cellProperties.push({
          attr: 'strokeOpacity',
          count: 1
        });
        this.stylePropertyesExist.hasStrokeOpacity = 1;
        this.cellLength += 1;
      }

      if (options.strokeWidth !== undefined && !lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(options.strokeWidth)) {
        this.cellProperties.push({
          attr: 'strokeWidth',
          count: 1
        });
        this.stylePropertyesExist.hasStrokeWidth = 1;
        this.cellLength += 1;
      }

      if (options.stroke !== undefined && !this.isStaticColor(options.stroke)) {
        this.cellProperties.push({
          attr: 'stroke',
          count: 4
        });
        this.stylePropertyesExist.hasStroke = 1;
        this.cellLength += 4;
      }

      if (options.offsets !== undefined && !this.isOffsetStatic(options.offsets)) {
        this.cellProperties.push({
          attr: 'offsets',
          count: 2
        });
        this.stylePropertyesExist.hasOffsets = 1;
        this.cellLength += 2;
      }

      if (options.thetaOffset !== undefined && !lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(options.thetaOffset)) {
        this.cellProperties.push({
          attr: 'thetaOffset',
          count: 1
        });
        this.stylePropertyesExist.hasThetaOffset = 1;
        this.cellLength += 1;
      }
    }
  }, {
    key: "isStaticColor",
    value: function isStaticColor(stroke) {
      if (lodash_isString__WEBPACK_IMPORTED_MODULE_7___default()(stroke)) {
        if ((0,d3_color__WEBPACK_IMPORTED_MODULE_12__.default)(stroke)) {
          return true;
        } else {
          return false;
        }
      }

      return false;
    }
  }, {
    key: "getStrokeColor",
    value: function getStrokeColor(stroke) {
      if (this.isStaticColor(stroke)) {
        var strokeColor = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.rgb2arr)(stroke);
        strokeColor[0] = strokeColor[0] ? strokeColor[0] : 0;
        strokeColor[1] = strokeColor[1] ? strokeColor[1] : 0;
        strokeColor[2] = strokeColor[2] ? strokeColor[2] : 0;
        strokeColor[3] = strokeColor[3] ? strokeColor[3] : 0;
        return strokeColor;
      } else {
        return [0, 0, 0, 0];
      }
    }
  }, {
    key: "isOffsetStatic",
    value: function isOffsetStatic(offsets) {
      if (Array.isArray(offsets) && offsets.length === 2 && lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(offsets[0]) && lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(offsets[1])) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "patchMod",
    value: function patchMod(d, count) {
      for (var i = 0; i < count; i++) {
        d.push(-1);
      }
    }
  }, {
    key: "patchData",
    value: function patchData(d, cellData, cellPropertiesLayouts) {
      var _iterator = _createForOfIteratorHelper(cellPropertiesLayouts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var layout = _step.value;
          var attr = layout.attr,
              count = layout.count;
          var value = cellData[attr];

          if (value !== undefined) {
            if (attr === 'stroke') {
              d.push.apply(d, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)((0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.rgb2arr)(value)));
            } else if (attr === 'offsets') {
              if (this.isOffsetStatic(value)) {
                d.push(-value[0], value[1]);
              } else {
                d.push(0, 0);
              }
            } else {
              d.push(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(value) ? value : 1.0);
            }
          } else {
            this.patchMod(d, count);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "calDataFrame",
    value: function calDataFrame(cellLength, encodeData, cellPropertiesLayouts) {
      var encodeDatalength = encodeData.length;
      var rowCount = Math.ceil(encodeDatalength * cellLength / this.DATA_TEXTURE_WIDTH);
      var totalLength = rowCount * this.DATA_TEXTURE_WIDTH;
      var d = [];

      for (var i = 0; i < encodeDatalength; i++) {
        var cellData = encodeData[i];
        this.patchData(d, cellData, cellPropertiesLayouts);
      }

      for (var _i = d.length; _i < totalLength; _i++) {
        d.push(-1);
      }

      return {
        data: d,
        width: this.DATA_TEXTURE_WIDTH,
        height: rowCount
      };
    }
  }, {
    key: "getBlend",
    value: function getBlend() {
      var _this$layer$getLayerC = this.layer.getLayerConfig(),
          _this$layer$getLayerC2 = _this$layer$getLayerC.blend,
          blend = _this$layer$getLayerC2 === void 0 ? 'normal' : _this$layer$getLayerC2;

      return _utils_blend__WEBPACK_IMPORTED_MODULE_13__.BlendTypes[_antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.BlendType[blend]];
    }
  }, {
    key: "getDefaultStyle",
    value: function getDefaultStyle() {
      return {};
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      return {};
    }
  }, {
    key: "needUpdate",
    value: function needUpdate() {
      return false;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function initModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      return;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "render",
    value: function render() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "animateOption2Array",
    value: function animateOption2Array(option) {
      return [option.enable ? 0 : 1.0, option.duration || 4.0, option.interval || 0.2, option.trailLength || 0.1];
    }
  }, {
    key: "startModelAnimate",
    value: function startModelAnimate() {
      var _ref = this.layer.getLayerConfig(),
          animateOption = _ref.animateOption;

      if (animateOption.enable) {
        this.layer.setAnimateStartTime();
      }
    }
  }]);

  return BaseModel;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_5__.default)(_class.prototype, "configService", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class));

//# sourceMappingURL=BaseModel.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/interface.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/interface.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lineStyleType": function() { return /* binding */ lineStyleType; },
/* harmony export */   "CanvasUpdateType": function() { return /* binding */ CanvasUpdateType; }
/* harmony export */ });
var lineStyleType;

(function (lineStyleType) {
  lineStyleType[lineStyleType["solid"] = 0] = "solid";
  lineStyleType[lineStyleType["dash"] = 1] = "dash";
})(lineStyleType || (lineStyleType = {}));

var CanvasUpdateType;

(function (CanvasUpdateType) {
  CanvasUpdateType["ALWAYS"] = "always";
  CanvasUpdateType["DRAGEND"] = "dragend";
})(CanvasUpdateType || (CanvasUpdateType = {}));
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/shape/Path.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/shape/Path.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShapeType3D": function() { return /* binding */ ShapeType3D; },
/* harmony export */   "ShapeType2D": function() { return /* binding */ ShapeType2D; },
/* harmony export */   "polygonPath": function() { return /* binding */ polygonPath; },
/* harmony export */   "circle": function() { return /* binding */ circle; },
/* harmony export */   "square": function() { return /* binding */ square; },
/* harmony export */   "triangle": function() { return /* binding */ triangle; },
/* harmony export */   "hexagon": function() { return /* binding */ hexagon; },
/* harmony export */   "pentagon": function() { return /* binding */ pentagon; },
/* harmony export */   "geometryShape": function() { return /* binding */ geometryShape; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");


var _geometryShape;

var ShapeType3D;

(function (ShapeType3D) {
  ShapeType3D["CYLINDER"] = "cylinder";
  ShapeType3D["SQUARECOLUMN"] = "squareColumn";
  ShapeType3D["TRIANGLECOLUMN"] = "triangleColumn";
  ShapeType3D["HEXAGONCOLUMN"] = "hexagonColumn";
  ShapeType3D["PENTAGONCOLUMN"] = "pentagonColumn";
})(ShapeType3D || (ShapeType3D = {}));

var ShapeType2D;

(function (ShapeType2D) {
  ShapeType2D["CIRCLE"] = "circle";
  ShapeType2D["SQUARE"] = "square";
  ShapeType2D["TRIANGLE"] = "triangle";
  ShapeType2D["HEXAGON"] = "hexagon";
  ShapeType2D["PENTAGON"] = "pentagon";
})(ShapeType2D || (ShapeType2D = {}));

function polygonPath(pointCount) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var step = Math.PI * 2 / pointCount;
  var line = [];

  for (var i = 0; i < pointCount; i++) {
    line.push(step * i + start * Math.PI / 12);
  }

  var path = line.map(function (t) {
    var x = Math.sin(t + Math.PI / 4);
    var y = Math.cos(t + Math.PI / 4);
    return [x, y, 0];
  });
  return path;
}
function circle() {
  return polygonPath(30);
}
function square() {
  return polygonPath(4);
}
function triangle() {
  return polygonPath(3);
}
function hexagon() {
  return polygonPath(6, 1);
}
function pentagon() {
  return polygonPath(5);
}
var geometryShape = (_geometryShape = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType2D.CIRCLE, circle), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType2D.HEXAGON, hexagon), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType2D.TRIANGLE, triangle), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType2D.SQUARE, square), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType2D.PENTAGON, pentagon), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType3D.CYLINDER, circle), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType3D.HEXAGONCOLUMN, hexagon), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType3D.TRIANGLECOLUMN, triangle), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType3D.SQUARECOLUMN, square), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_geometryShape, ShapeType3D.PENTAGONCOLUMN, pentagon), _geometryShape);
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/shape/extrude.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/shape/extrude.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ extrudePolygon; },
/* harmony export */   "fillPolygon": function() { return /* binding */ fillPolygon; },
/* harmony export */   "extrude_PolygonNormal": function() { return /* binding */ extrude_PolygonNormal; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");




function extrudePolygon(path) {
  var p1 = path[0][0];
  var p2 = path[0][path[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }

  var n = path[0].length;
  var flattengeo = earcut__WEBPACK_IMPORTED_MODULE_2___default().flatten(path);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions;
  var positions = [];
  var indexArray = [];

  for (var j = 0; j < vertices.length / dimensions; j++) {
    if (dimensions === 2) {
      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);
    } else {
      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);
    }
  }

  var triangles = earcut__WEBPACK_IMPORTED_MODULE_2___default()(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(triangles));

  var _loop = function _loop(i) {
    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);

    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }

    var indexOffset = positions.length / 3;
    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);
    indexArray.push.apply(indexArray, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)([0, 2, 1, 2, 3, 1].map(function (v) {
      return v + indexOffset;
    })));
  };

  for (var i = 0; i < n; i++) {
    _loop(i);
  }

  return {
    positions: positions,
    index: indexArray
  };
}
function fillPolygon(points) {
  var flattengeo = earcut__WEBPACK_IMPORTED_MODULE_2___default().flatten(points);
  var triangles = earcut__WEBPACK_IMPORTED_MODULE_2___default()(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  return {
    positions: flattengeo.vertices,
    index: triangles
  };
}
function extrude_PolygonNormal(path) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var p1 = path[0][0];
  var p2 = path[0][path[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }

  var n = path[0].length;
  var flattengeo = earcut__WEBPACK_IMPORTED_MODULE_2___default().flatten(path);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions;
  var positions = [];
  var indexArray = [];
  var normals = [];

  for (var j = 0; j < vertices.length / dimensions; j++) {
    if (dimensions === 2) {
      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1, -1, -1);
    } else {
      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1, -1, -1);
    }

    normals.push(0, 0, 1);
  }

  var triangles = earcut__WEBPACK_IMPORTED_MODULE_2___default()(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(triangles));

  var _loop2 = function _loop2(i) {
    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);

    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }

    var indexOffset = positions.length / 5;
    positions.push(prePoint[0], prePoint[1], 1, 0, 0, nextPoint[0], nextPoint[1], 1, 0.1, 0, prePoint[0], prePoint[1], 0, 0, 0.8, nextPoint[0], nextPoint[1], 0, 0.1, 0.8);
    var normal = computeVertexNormals([nextPoint[0], nextPoint[1], 1], [prePoint[0], prePoint[1], 0], [prePoint[0], prePoint[1], 1], needFlat);
    normals.push.apply(normals, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(normal).concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(normal), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(normal), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(normal)));
    indexArray.push.apply(indexArray, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)([1, 2, 0, 3, 2, 1].map(function (v) {
      return v + indexOffset;
    })));
  };

  for (var i = 0; i < n; i++) {
    _loop2(i);
  }

  return {
    positions: positions,
    index: indexArray,
    normals: normals
  };
}

function computeVertexNormals(p1, p2, p3) {
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var cb = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
  var ab = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
  var normal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();

  if (needFlat) {
    p1 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.lngLatToMeters)(p1);
    p2 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.lngLatToMeters)(p2);
    p3 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.lngLatToMeters)(p3);
  }

  var pA = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.fromValues.apply(gl_matrix__WEBPACK_IMPORTED_MODULE_3__, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(p1));
  var pB = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.fromValues.apply(gl_matrix__WEBPACK_IMPORTED_MODULE_3__, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(p2));
  var pC = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.fromValues.apply(gl_matrix__WEBPACK_IMPORTED_MODULE_3__, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(p3));
  gl_matrix__WEBPACK_IMPORTED_MODULE_3__.sub(cb, pC, pB);
  gl_matrix__WEBPACK_IMPORTED_MODULE_3__.sub(ab, pA, pB);
  gl_matrix__WEBPACK_IMPORTED_MODULE_3__.cross(normal, cb, ab);
  var newNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
  gl_matrix__WEBPACK_IMPORTED_MODULE_3__.normalize(newNormal, normal);
  return newNormal;
}
//# sourceMappingURL=extrude.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/core/triangulation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/core/triangulation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointFillTriangulation": function() { return /* binding */ PointFillTriangulation; },
/* harmony export */   "GlobelPointFillTriangulation": function() { return /* binding */ GlobelPointFillTriangulation; },
/* harmony export */   "PointExtrudeTriangulation": function() { return /* binding */ PointExtrudeTriangulation; },
/* harmony export */   "PointImageTriangulation": function() { return /* binding */ PointImageTriangulation; },
/* harmony export */   "LineTriangulation": function() { return /* binding */ LineTriangulation; },
/* harmony export */   "SimpleLineTriangulation": function() { return /* binding */ SimpleLineTriangulation; },
/* harmony export */   "polygonTriangulation": function() { return /* binding */ polygonTriangulation; },
/* harmony export */   "polygonTriangulationWithCenter": function() { return /* binding */ polygonTriangulationWithCenter; },
/* harmony export */   "PolygonExtrudeTriangulation": function() { return /* binding */ PolygonExtrudeTriangulation; },
/* harmony export */   "HeatmapGridTriangulation": function() { return /* binding */ HeatmapGridTriangulation; },
/* harmony export */   "RasterImageTriangulation": function() { return /* binding */ RasterImageTriangulation; },
/* harmony export */   "LineArcTriangulation": function() { return /* binding */ LineArcTriangulation; },
/* harmony export */   "HeatmapTriangulation": function() { return /* binding */ HeatmapTriangulation; },
/* harmony export */   "earthTriangulation": function() { return /* binding */ earthTriangulation; },
/* harmony export */   "earthOuterTriangulation": function() { return /* binding */ earthOuterTriangulation; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _earth_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../earth/utils */ "./node_modules/@antv/l7-layers/es/earth/utils.js");
/* harmony import */ var _utils_extrude_polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/extrude_polyline */ "./node_modules/@antv/l7-layers/es/utils/extrude_polyline.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/geo */ "./node_modules/@antv/l7-layers/es/utils/geo.js");
/* harmony import */ var _shape_extrude__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shape/extrude */ "./node_modules/@antv/l7-layers/es/core/shape/extrude.js");
/* harmony import */ var _shape_Path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shape/Path */ "./node_modules/@antv/l7-layers/es/core/shape/Path.js");










var GeometryCache = {};
function PointFillTriangulation(feature) {
  var coordinates = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_4__.calculateCentroid)(feature.coordinates);
  return {
    vertices: [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}
function GlobelPointFillTriangulation(feature) {
  var coordinates = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_4__.calculateCentroid)(feature.coordinates);
  var xyz = (0,_earth_utils__WEBPACK_IMPORTED_MODULE_5__.lglt2xyz)(coordinates);
  return {
    vertices: [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(xyz), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(xyz), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(xyz), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(xyz)),
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}
function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;

  var _getGeometry = getGeometry(shape, false),
      positions = _getGeometry.positions,
      index = _getGeometry.index,
      normals = _getGeometry.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}
function PointImageTriangulation(feature) {
  var coordinates = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_4__.calculateCentroid)(feature.coordinates);
  return {
    vertices: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}
function LineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new _utils_extrude_polyline__WEBPACK_IMPORTED_MODULE_6__.default({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.extrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.extrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    indexes: linebuffer.indexes,
    size: 6
  };
}
function SimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new _utils_extrude_polyline__WEBPACK_IMPORTED_MODULE_6__.default({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.simpleExtrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.simpleExtrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}
function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut__WEBPACK_IMPORTED_MODULE_3___default().flatten(coordinates);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: earcut__WEBPACK_IMPORTED_MODULE_3___default()(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}
function polygonTriangulationWithCenter(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut__WEBPACK_IMPORTED_MODULE_3___default().flatten(coordinates);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: earcut__WEBPACK_IMPORTED_MODULE_3___default()(vertices, holes, dimensions),
    vertices: getVerticesWithCenter(vertices),
    size: dimensions + 4
  };
}

function getVerticesWithCenter(vertices) {
  var verticesWithCenter = [];

  var _calculatePointsCente = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_4__.calculatePointsCenterAndRadius)(vertices),
      center = _calculatePointsCente.center,
      radius = _calculatePointsCente.radius;

  for (var i = 0; i < vertices.length; i += 2) {
    var lng = vertices[i];
    var lat = vertices[i + 1];
    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(center), [radius]));
  }

  return verticesWithCenter;
}

function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;

  var _extrude_PolygonNorma = (0,_shape_extrude__WEBPACK_IMPORTED_MODULE_7__.extrude_PolygonNormal)(coordinates, true),
      positions = _extrude_PolygonNorma.positions,
      index = _extrude_PolygonNorma.index,
      normals = _extrude_PolygonNorma.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}
function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;

  var _getHeatmapGeometry = getHeatmapGeometry(shape),
      positions = _getHeatmapGeometry.positions,
      index = _getHeatmapGeometry.index;

  return {
    vertices: positions,
    indices: index,
    size: 3
  };
}
function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  var positions = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates[1]), [0, 1, 0], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates[0]), [0, 0, 1], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}
function LineArcTriangulation(feature, segmentNumber) {
  var segNum = segmentNumber ? segmentNumber : 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];

  var _loop = function _loop(i) {
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);

    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };

  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }

  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}
function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;

  if (coordinates.length === 2) {
    coordinates.push(0);
  }

  var size = feature.size;
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  var positions = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(dir), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(dir2), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(dir3), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(coordinates), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }

  var path = _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape[shape] ? _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape[shape]() : _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape.cylinder();
  var geometry = (0,_shape_extrude__WEBPACK_IMPORTED_MODULE_7__.extrude_PolygonNormal)([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}

function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;
  var cb = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
  var ab = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
  var normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();

  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];

    if (needFlat) {
      p1 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.lngLatToMeters)(p1);
      p2 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.lngLatToMeters)(p2);
      p3 = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.lngLatToMeters)(p3);
    }

    var _p = p1,
        _p2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_p, 2),
        ax = _p2[0],
        ay = _p2[1];

    var pA = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.fromValues(ax, ay, positions[vA + 2]);

    var _p3 = p2,
        _p4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_p3, 2),
        bx = _p4[0],
        by = _p4[1];

    var pB = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.fromValues(bx, by, positions[vB + 2]);

    var _p5 = p3,
        _p6 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_p5, 2),
        cx = _p6[0],
        cy = _p6[1];

    var pC = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.fromValues(cx, cy, positions[vC + 2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__.sub(cb, pC, pB);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__.sub(ab, pA, pB);
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__.cross(normal, cb, ab);
    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }

  normalizeNormals(normals);
  return normals;
}

function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.fromValues(normals[i], normals[i + 1], normals[i + 2]);
    var newNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_9__.normalize(newNormal, normal);
    normals.set(newNormal, i);
  }
}

function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}

function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape[shape] ? _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape[shape]() : _shape_Path__WEBPACK_IMPORTED_MODULE_8__.geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? (0,_shape_extrude__WEBPACK_IMPORTED_MODULE_7__.fillPolygon)([path]) : (0,_shape_extrude__WEBPACK_IMPORTED_MODULE_7__.default)([path]);
  return geometry;
}

function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}

function earthTriangulation() {
  var earthmesh = (0,_earth_utils__WEBPACK_IMPORTED_MODULE_5__.primitiveSphere)(_earth_utils__WEBPACK_IMPORTED_MODULE_5__.EARTH_RADIUS, {
    segments: _earth_utils__WEBPACK_IMPORTED_MODULE_5__.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
function earthOuterTriangulation() {
  var earthmesh = (0,_earth_utils__WEBPACK_IMPORTED_MODULE_5__.primitiveSphere)(_earth_utils__WEBPACK_IMPORTED_MODULE_5__.EARTH_RADIUS + _earth_utils__WEBPACK_IMPORTED_MODULE_5__.EARTH_RADIUS_OUTER, {
    segments: _earth_utils__WEBPACK_IMPORTED_MODULE_5__.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
//# sourceMappingURL=triangulation.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/earth/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/earth/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ EarthLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_atmosphere__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./models/atmosphere */ "./node_modules/@antv/l7-layers/es/earth/models/atmosphere.js");
/* harmony import */ var _models_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/base */ "./node_modules/@antv/l7-layers/es/earth/models/base.js");
/* harmony import */ var _models_bloomsphere__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./models/bloomsphere */ "./node_modules/@antv/l7-layers/es/earth/models/bloomsphere.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var EarthModels = {
  base: _models_base__WEBPACK_IMPORTED_MODULE_7__.default,
  atomSphere: _models_atmosphere__WEBPACK_IMPORTED_MODULE_8__.default,
  bloomSphere: _models_bloomsphere__WEBPACK_IMPORTED_MODULE_9__.default
};
var earthLayerTypes = ['base', 'atomSphere', 'bloomSphere'];

var EarthLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(EarthLayer, _BaseLayer);

  var _super = _createSuper(EarthLayer);

  function EarthLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, EarthLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'EarthLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(EarthLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var shape = this.getModelType();
      this.layerModel = new EarthModels[shape](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "setEarthTime",
    value: function setEarthTime(time) {
      if (this.layerModel && this.layerModel.setEarthTime) {
        this.layerModel.setEarthTime(time);
      } else {
        console.error(' scene loaded ');
      }
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var _shapeAttribute$scale;

      var shapeAttribute = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shape = (shapeAttribute === null || shapeAttribute === void 0 ? void 0 : (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field) || 'base';

      if (earthLayerTypes.indexOf(shape) < 0) {
        shape = 'base';
      }

      return shape;
    }
  }]);

  return EarthLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_10__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/earth/models/atmosphere.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/earth/models/atmosphere.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ EarthAtomSphereModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var atmoSphereFrag = "\nuniform float u_opacity;\nuniform vec3 u_CameraPosition;\n\nvarying vec3 vVertexNormal;\nvarying float v_offset;\nvarying vec4 v_Color;\nvoid main() {\n    \n    \n    // float intensity = pow(0.5 + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    float intensity = pow(v_offset + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    // TODO: \u53BB\u9664\u80CC\u9762\n    if(intensity > 1.0) intensity = 0.0;\n\n    gl_FragColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\n}\n";
var atmoSphereVert = "\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute vec2 a_Uv;\nattribute vec4 a_Color;\nuniform vec3 u_CameraPosition;\nvarying float v_CamreaDistance;\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_ViewMatrix;\n\nvarying vec3 vVertexNormal;\nvarying vec4 v_Color;\nvarying float v_offset;\n\nvoid main() {\n    float EARTH_RADIUS = 100.0;\n    \n    v_Color = a_Color;\n\n    v_offset = min(((length(u_CameraPosition) - EARTH_RADIUS)/600.0) * 0.5 + 0.4, 1.0);\n    vVertexNormal = a_Normal;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n";

var EarthAtomSphereModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(EarthAtomSphereModel, _BaseModel);

  var _super = _createSuper(EarthAtomSphereModel);

  function EarthAtomSphereModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, EarthAtomSphereModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(EarthAtomSphereModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;

      return {
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      return '';
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      this.layer.zIndex = -997;
      return [this.layer.buildLayerModel({
        moduleName: 'earthAtmoSphere',
        vertexShader: atmoSphereVert,
        fragmentShader: atmoSphereFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.earthTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return EarthAtomSphereModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=atmosphere.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/earth/models/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/earth/models/base.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BaseEarthModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var baseFrag = "\nuniform sampler2D u_texture;\n\nvarying vec2 v_texCoord;\nvarying float v_lightWeight;\n\n\nvoid main() {\n\n    vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n    color.xyz = color.xyz * v_lightWeight;\n    gl_FragColor = color;\n}\n";
var baseVert = "// attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n\n// attribute vec2 a_Extrude;\n// attribute float a_Size;\n// attribute float a_Shape;\n\nuniform vec3 u_CameraPosition;\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform float u_ambientRatio : 0.5;\nuniform float u_diffuseRatio : 0.3;\nuniform float u_specularRatio : 0.2;\nuniform vec3 u_sunLight: [1.0, -10.5, 12.0];\n\n\n\nfloat calc_lighting(vec4 pos) {\n\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\n\n    vec3 worldNormal = a_Normal;\n\n    // cal light weight\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\n\n    vec3 lightDir = normalize(u_sunLight);\n\n    vec3 halfDir = normalize(viewDir+lightDir);\n    // lambert\n    float lambert = dot(worldNormal, lightDir);\n    // specular\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\n    //sum to light weight\n    float lightWeight = u_ambientRatio + u_diffuseRatio * lambert + u_specularRatio * specular;\n\n    return lightWeight;\n}\n\nvarying float v_lightWeight;\nvoid main() {\n\n    v_texCoord = a_Uv;\n\n    float lightWeight = calc_lighting(vec4(a_Position, 1.0));\n    v_lightWeight = lightWeight;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n";

var BaseEarthModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(BaseEarthModel, _BaseModel);

  var _super = _createSuper(BaseEarthModel);

  function BaseEarthModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, BaseEarthModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "earthTime", 3.4);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sunX", 1000);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sunY", 1000);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sunZ", 1000);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sunRadius", Math.sqrt(_this.sunX * _this.sunX + _this.sunY * _this.sunY + _this.sunZ * _this.sunZ));

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(BaseEarthModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _this$layer$getLayerC = this.layer.getLayerConfig(),
          animateOption = _this$layer$getLayerC.animateOption,
          globelOtions = _this$layer$getLayerC.globelOtions;

      if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
        this.mapService.rotateY({
          reg: 0.002
        });
        this.earthTime += 0.02;
        this.sunY = 10;
        this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
        this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
      }

      return {
        u_ambientRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.ambientRatio) || 0.6,
        u_diffuseRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.diffuseRatio) || 0.4,
        u_specularRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.specularRatio) || 0.1,
        u_sunLight: [this.sunX, this.sunY, this.sunZ],
        u_texture: this.texture
      };
    }
  }, {
    key: "setEarthTime",
    value: function setEarthTime(time) {
      this.earthTime = time;
      this.sunY = 10;
      this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
      this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
      this.layerService.renderLayers();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this2 = this;

      var _this$layer$getLayerC2 = this.layer.getLayerConfig(),
          globelOtions = _this$layer$getLayerC2.globelOtions;

      if ((globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.earthTime) !== undefined) {
        this.setEarthTime(globelOtions.earthTime);
      }

      var source = this.layer.getSource();
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      source.data.images.then(function (imageData) {
        _this2.texture = createTexture2D({
          data: imageData[0],
          width: imageData[0].width,
          height: imageData[0].height
        });

        _this2.layerService.updateLayerRenderList();

        _this2.layerService.renderLayers();
      });
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      return '';
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      this.layer.zIndex = -998;
      return [this.layer.buildLayerModel({
        moduleName: 'baseEarth',
        vertexShader: baseVert,
        fragmentShader: baseFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.earthTriangulation,
        depth: {
          enable: true
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return BaseEarthModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/earth/models/bloomsphere.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/earth/models/bloomsphere.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ EarthBloomSphereModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var bloomSphereFrag = "\nuniform float u_opacity;\nuniform vec3 u_CameraPosition;\nvarying vec3 vVertexNormal;\n\nvarying vec4 v_Color;\nvoid main() {\n\n\n    float intensity =  - dot(normalize(vVertexNormal), normalize(u_CameraPosition));\n    // TODO: \u53BB\u9664\u80CC\u9762\n    if(intensity > 1.0) intensity = 0.0;\n\n    gl_FragColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\n}\n";
var bloomSphereVert = "\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute vec2 a_Uv;\nattribute vec4 a_Color;\nuniform vec3 u_CameraPosition;\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_ViewMatrix;\n\nvarying vec3 vVertexNormal;\nvarying vec4 v_Color;\n\nvoid main() {\n    v_Color = a_Color;\n\n    vVertexNormal = a_Normal;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n";

var EarthBloomSphereModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(EarthBloomSphereModel, _BaseModel);

  var _super = _createSuper(EarthBloomSphereModel);

  function EarthBloomSphereModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, EarthBloomSphereModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(EarthBloomSphereModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;

      return {
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      return '';
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      this.layer.zIndex = -999;
      return [this.layer.buildLayerModel({
        moduleName: 'earthBloomSphere',
        vertexShader: bloomSphereVert,
        fragmentShader: bloomSphereFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.earthOuterTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return EarthBloomSphereModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=bloomsphere.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/earth/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/earth/utils.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EARTH_RADIUS": function() { return /* binding */ EARTH_RADIUS; },
/* harmony export */   "EARTH_SEGMENTS": function() { return /* binding */ EARTH_SEGMENTS; },
/* harmony export */   "EARTH_RADIUS_OUTER": function() { return /* binding */ EARTH_RADIUS_OUTER; },
/* harmony export */   "lglt2xyz": function() { return /* binding */ lglt2xyz; },
/* harmony export */   "primitiveSphere": function() { return /* binding */ primitiveSphere; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");


var EARTH_RADIUS = 100;
var EARTH_SEGMENTS = 36;
var EARTH_RADIUS_OUTER = 40;

function torad(deg) {
  return deg / 180 * Math.acos(-1);
}

function lglt2xyz(lnglat) {
  var lng = torad(lnglat[0]) + Math.PI / 2;
  var lat = torad(lnglat[1]);
  var radius = EARTH_RADIUS + Math.random() * 0.4;
  var z = radius * Math.cos(lat) * Math.cos(lng);
  var x = radius * Math.cos(lat) * Math.sin(lng);
  var y = radius * Math.sin(lat);
  return [x, y, z];
}
function primitiveSphere(radius, opt) {
  var matRotY = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
  var matRotZ = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
  var up = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  var tmpVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 0);
  opt = opt || {};
  radius = typeof radius !== 'undefined' ? radius : 1;
  var segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;
  var totalZRotationSteps = 2 + segments;
  var totalYRotationSteps = 2 * totalZRotationSteps;
  var indices = [];
  var indicesArr = [];
  var positions = [];
  var positionsArr = [];
  var normalArr = [];
  var uvs = [];

  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    var normalizedZ = zRotationStep / totalZRotationSteps;
    var angleZ = normalizedZ * Math.PI;

    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      var normalizedY = yRotationStep / totalYRotationSteps;
      var angleY = normalizedY * Math.PI * 2;
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__.identity(matRotZ);
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateZ(matRotZ, matRotZ, -angleZ);
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__.identity(matRotY);
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateY(matRotY, matRotY, angleY);
      gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformMat4(tmpVec3, up, matRotZ);
      gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformMat4(tmpVec3, tmpVec3, matRotY);
      gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(tmpVec3, tmpVec3, -radius);
      positions.push(tmpVec3.slice());
      positionsArr.push.apply(positionsArr, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(tmpVec3.slice()));
      gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpVec3, tmpVec3);
      normalArr.push.apply(normalArr, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(tmpVec3.slice()));
      uvs.push([normalizedY, 1 - normalizedZ]);
      positionsArr.push(normalizedY, 1 - normalizedZ);
    }

    if (zRotationStep > 0) {
      var verticesCount = positions.length;
      var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);

      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);
        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);
        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);
        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);
      }
    }
  }

  return {
    cells: indices,
    positions: positions,
    uvs: uvs,
    positionsArr: positionsArr,
    indicesArr: indicesArr,
    normalArr: normalArr
  };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ HeatMapLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models */ "./node_modules/@antv/l7-layers/es/heatmap/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var HeatMapLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(HeatMapLayer, _BaseLayer);

  var _super = _createSuper(HeatMapLayer);

  function HeatMapLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, HeatMapLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'HeatMapLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(HeatMapLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var shape = this.getModelType();
      this.layerModel = new _models__WEBPACK_IMPORTED_MODULE_7__.default[shape](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "renderModels",
    value: function renderModels() {
      var _this2 = this;

      var shape = this.getModelType();

      if (shape === 'heatmap') {
        if (this.layerModel) {
          this.layerModel.render();
        }

        return this;
      }

      if (this.layerModelNeedUpdate) {
        this.models = this.layerModel.buildModels();
        this.layerModelNeedUpdate = false;
      }

      this.models.forEach(function (model) {
        return model.draw({
          uniforms: _this2.layerModel.getUninforms()
        });
      });
      return this;
    }
  }, {
    key: "updateModelData",
    value: function updateModelData(data) {
      if (data.attributes && data.elements) {
        this.models[0].updateAttributesAndElements(data.attributes, data.elements);
      } else {
        console.warn('data error');
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var _shapeAttribute$scale;

      var shapeAttribute = this.styleAttributeService.getLayerStyleAttribute('shape');

      var _this$getLayerConfig = this.getLayerConfig(),
          shape3d = _this$getLayerConfig.shape3d;

      var source = this.getSource();
      var sourceType = source.data.type;
      var shape = (shapeAttribute === null || shapeAttribute === void 0 ? void 0 : (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field) || 'heatmap';

      if (shape === 'heatmap' || shape === 'heatmap3d') {
        return 'heatmap';
      }

      if (sourceType === 'hexagon') {
        return (shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) === -1 ? 'hexagon' : 'grid3d';
      }

      if (sourceType === 'grid') {
        return (shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) === -1 ? 'grid' : 'grid3d';
      }

      return 'heatmap';
    }
  }]);

  return HeatMapLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/models/grid.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/models/grid.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ GridModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var heatmapGridVert = "precision highp float;\r\n// \u591A\u8FB9\u5F62\u9876\u70B9\u5750\u6807\r\nattribute vec3 a_Position;\r\n// \u591A\u8FB9\u5F62\u7ECF\u7EAC\u5EA6\u5750\u6807\r\nattribute vec3 a_Pos;\r\nattribute float a_Size;\r\nattribute vec4 a_Color;\r\nuniform vec2 u_radius;\r\nuniform float u_coverage: 0.9;\r\nuniform float u_angle: 0;\r\nuniform mat4 u_ModelMatrix;\r\nuniform mat4 u_Mvp;\r\nvarying vec4 v_color;\r\n\r\nuniform vec2 u_SceneCenterMKT;\r\n\r\n#pragma include \"projection\"\r\n#pragma include \"project\"\r\n#pragma include \"picking\"\r\n\r\nvoid main() {\r\n  v_color = a_Color;\r\n\r\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\r\n  vec2 offset = a_Position.xy * u_radius * rotationMatrix * u_coverage ;\r\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n  // gl_Position = project_common_position_to_clipspace(project_pos);\r\n\r\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\r\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // \u5C06\u7ECF\u7EAC\u5EA6\u8F6C\u6362\u4E3A\u9AD8\u5FB72.0\u9700\u8981\u7684\u5E73\u9762\u5750\u6807\r\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\r\n    gl_Position = u_Mvp * (project_pos);\r\n  } else {\r\n     vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\r\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\r\n    gl_Position = project_common_position_to_clipspace(project_pos);\r\n  }\r\n\r\n  setPickingColor(a_PickingColor);\r\n}\r\n";
var heatmapGridFrag = "precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include \"picking\"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";

var GridModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(GridModel, _BaseModel);

  var _super = _createSuper(GridModel);

  function GridModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, GridModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(GridModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity,
          coverage = _ref.coverage,
          angle = _ref.angle;

      return {
        u_opacity: opacity || 1.0,
        u_coverage: coverage || 0.9,
        u_angle: angle || 0,
        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'gridheatmap',
        vertexShader: heatmapGridVert,
        fragmentShader: heatmapGridFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.HeatmapGridTriangulation,
        depth: {
          enable: false
        },
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.TRIANGLES,
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'pos',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Pos',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx) {
            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;
            return [coordinates[0], coordinates[1], 0];
          }
        }
      });
    }
  }]);

  return GridModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/models/grid3d.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/models/grid3d.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Grid3DModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var heatmapGrid3dVert = "precision highp float;\n// \u591A\u8FB9\u5F62\u9876\u70B9\u5750\u6807\nattribute vec3 a_Position;\n// \u591A\u8FB9\u5F62\u7ECF\u7EAC\u5EA6\u5750\u6807\nattribute vec3 a_Pos;\n\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec4 a_Color;\nuniform vec2 u_radius;\nuniform float u_coverage: 0.9;\nuniform float u_angle: 0;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform vec2 u_SceneCenterMKT;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \u5B9E\u9645\u7684\u7ECF\u7EAC\u5EA6\n  // vec2 lnglat = (a_Pos.xy + offset); \n  // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n  // gl_Position = project_common_position_to_clipspace(project_pos);\n  // float lightWeight = calc_lighting(project_pos);\n  // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // vec2 lnglat = (a_Pos.xy + offset); \n    // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n\n    // float lightWeight = calc_lighting(project_pos);\n    // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n  \n    // gl_Position = u_Mvp * vec4(lnglat , a_Position.z * a_Size, 1.0);\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \u7ECF\u7EAC\u5EA6\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // \u5C06\u7ECF\u7EAC\u5EA6\u8F6C\u6362\u4E3A\u9AD8\u5FB72.0\u9700\u8981\u7684\u5E73\u9762\u5750\u6807\n    vec4 project_pos = project_position(vec4(customLnglat, a_Position.z * a_Size, 1.0));\n\n    float lightWeight = calc_lighting(project_pos);\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n  \n    gl_Position = u_Mvp * vec4(customLnglat , a_Position.z * a_Size, 1.0);\n  } else {\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \u5B9E\u9645\u7684\u7ECF\u7EAC\u5EA6\n    vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n    \n    float lightWeight = calc_lighting(project_pos);\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\n    \n    gl_Position = project_common_position_to_clipspace(project_pos);\n  }\n\n\n\n  setPickingColor(a_PickingColor);\n}\n";
var heatmapGridFrag = "precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include \"picking\"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";

var Grid3DModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(Grid3DModel, _BaseModel);

  var _super = _createSuper(Grid3DModel);

  function Grid3DModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Grid3DModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Grid3DModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity,
          coverage = _ref.coverage,
          angle = _ref.angle;

      return {
        u_opacity: opacity || 1.0,
        u_coverage: coverage || 1.0,
        u_angle: angle || 0,
        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'grid3dheatmap',
        vertexShader: heatmapGrid3dVert,
        fragmentShader: heatmapGridFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.PointExtrudeTriangulation,
        depth: {
          enable: true
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var size = feature.size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'pos',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Pos',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx) {
            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;
            return [coordinates[0], coordinates[1], 0];
          }
        }
      });
    }
  }]);

  return Grid3DModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=grid3d.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/models/heatmap.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/models/heatmap.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ HeatMapModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _triangulation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../triangulation */ "./node_modules/@antv/l7-layers/es/heatmap/triangulation.js");









var _dec, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








var heatmap3DFrag = "uniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_opacity;\nvarying vec2 v_texCoord;\nvarying float v_intensity;\n\nvoid main(){\n   \n     float intensity = texture2D(u_texture, v_texCoord).r;\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\n    gl_FragColor = color;\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\n     gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n}\n";
var heatmap3DVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_InverseViewProjectionMatrix;\nuniform mat4 u_ViewProjectionMatrixUncentered;\nvarying float v_intensity;\n\n\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    float t2 = t * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\n}\nvec2 toBezier(float t, vec4 p){\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\n}\n#pragma include \"projection\"\nvoid main() {\n  v_texCoord = a_Uv;\n\n  vec2 pos = a_Uv * vec2(2.0) - vec2(1.0); // \u5C06\u539F\u672C 0 -> 1 \u7684 uv \u8F6C\u6362\u4E3A -1 -> 1 \u7684\u6807\u51C6\u5750\u6807\u7A7A\u95F4\uFF08NDC\uFF09\n\n  vec4 p1 = vec4(pos, 0.0, 1.0); // x/y \u5E73\u9762\u4E0A\u7684\u70B9\uFF08z == 0\uFF09\u53EF\u4EE5\u8BA4\u4E3A\u662F\u4E09\u7EF4\u4E0A\u7684\u70B9\u88AB\u6295\u5F71\u5230\u5E73\u9762\u540E\u7684\u70B9\n\tvec4 p2 = vec4(pos, 1.0, 1.0); // \u5E73\u884C\u4E8Ex/y\u5E73\u9762\u3001z==1 \u7684\u5E73\u9762\u4E0A\u7684\u70B9\n\n\tvec4 inverseP1 = u_InverseViewProjectionMatrix * p1; // \u6839\u636E\u89C6\u56FE\u6295\u5F71\u77E9\u9635\u7684\u9006\u77E9\u9635\u5E73\u9762\u4E0A\u7684\u53CD\u7B97\u51FA\u4E09\u7EF4\u7A7A\u95F4\u4E2D\u7684\u70B9\uFF08p1\u5E73\u9762\u4E0A\u7684\u70B9\uFF09\n\tvec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\n\n  inverseP1 = inverseP1 / inverseP1.w; // \u5F52\u4E00\u5316\u64CD\u4F5C\uFF08\u5F52\u4E00\u5316\u540E\u4E3A\u4E16\u754C\u5750\u6807\uFF09\n\tinverseP2 = inverseP2 / inverseP2.w;\n\n\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z); // ??\n\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\n\n  vec4 b= vec4(0.5000, 0.0, 1.0, 0.5000);\n  float fh;\n\n  v_intensity = texture2D(u_texture, v_texCoord).r;\n  fh = toBezier(v_intensity, b).y;\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.), 1.0);\n \n}\n";
var heatmapColorFrag = "uniform sampler2D u_texture;        // \u70ED\u529B\u5F3A\u5EA6\u56FE\nuniform sampler2D u_colorTexture;   // \u6839\u636E\u5F3A\u5EA6\u5206\u5E03\u7684\u8272\u5E26\nuniform float u_opacity;\nvarying vec2 v_texCoord;\n\nuniform vec2 u_ViewportSize;\n\nfloat getBlurIndusty() {\n    float vW = 2.0/u_ViewportSize.x;\n    float vH = 2.0/u_ViewportSize.y;\n    vec2 vUv = v_texCoord;\n    float i11 = texture2D( u_texture, vec2( vUv.x - 1.0 * vW, vUv.y + 1.0 * vH) ).r;\n    float i12 = texture2D( u_texture, vec2( vUv.x - 0.0 * vW, vUv.y + 1.0 * vH) ).r;\n    float i13 = texture2D( u_texture, vec2( vUv.x + 1.0 * vW, vUv.y + 1.0 * vH) ).r;\n\n    float i21 = texture2D( u_texture, vec2( vUv.x - 1.0 * vW, vUv.y) ).r;\n    float i22 = texture2D( u_texture, vec2( vUv.x , vUv.y) ).r;\n    float i23 = texture2D( u_texture, vec2( vUv.x + 1.0 * vW, vUv.y) ).r;\n\n    float i31 = texture2D( u_texture, vec2( vUv.x - 1.0 * vW, vUv.y-1.0*vH) ).r;\n    float i32 = texture2D( u_texture, vec2( vUv.x - 0.0 * vW, vUv.y-1.0*vH) ).r;\n    float i33 = texture2D( u_texture, vec2( vUv.x + 1.0 * vW, vUv.y-1.0*vH) ).r;\n\n    return(\n        i11 + \n        i12 + \n        i13 + \n        i21 + \n        i21 + \n        i22 + \n        i23 + \n        i31 + \n        i32 + \n        i33\n        )/9.0;\n}\n\n\nvoid main(){\n    // float intensity = texture2D(u_texture, v_texCoord).r;\n    float intensity = getBlurIndusty();\n    vec4 color = texture2D(u_colorTexture, vec2(intensity, 0.0));\n\n    gl_FragColor =color;\n    gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n\n}\n";
var heatmapColorVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = a_Uv;\n\n  gl_Position = vec4(a_Position.xy, 0, 1.);\n}\n";
var heatmapFramebufferFrag = "precision highp float;\nuniform float u_intensity;\nvarying float v_weight;\nvarying vec2 v_extrude;\n#define GAUSS_COEF  0.3989422804014327\nvoid main(){\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\n    gl_FragColor = vec4(val, 1., 1., 1.);\n}\n";
var heatmapFramebufferVert = "precision highp float;\nattribute vec3 a_Position;\nattribute float a_Size;\nattribute vec2 a_Dir;\nuniform float u_intensity;\nuniform float u_radius;\nvarying vec2 v_extrude;\nvarying float v_weight;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\n#define GAUSS_COEF  0.3989422804014327\n\n#pragma include \"projection\"\n\nvoid main(){\n    v_weight = a_Size;\n    float ZERO = 1.0 / 255.0 / 16.0;\n    float extrude_x = a_Dir.x * 2.0 -1.0;\n    float extrude_y = a_Dir.y * 2.0 -1.0;\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 2.5;\n    v_extrude = extrude_dir * S;\n\n    vec2 offset = project_pixel(v_extrude * u_radius);\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n    // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n        gl_Position = u_Mvp * (vec4(project_pos.xy + offset, 0.0, 1.0));\n    } else {\n        gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n    }\n}\n";

var HeatMapModel = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_10__.injectable)(), _dec(_class = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(HeatMapModel, _BaseModel);

  var _super = _createSuper(HeatMapModel);

  function HeatMapModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, HeatMapModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "colorTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "heatmapFramerBuffer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "intensityModel", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "colorModel", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "shapeType", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(HeatMapModel, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$rendererService = this.rendererService,
          clear = _this$rendererService.clear,
          useFramebuffer = _this$rendererService.useFramebuffer;
      useFramebuffer(this.heatmapFramerBuffer, function () {
        clear({
          color: [0, 0, 0, 0],
          depth: 1,
          stencil: 0,
          framebuffer: _this2.heatmapFramerBuffer
        });

        _this2.drawIntensityMode();
      });

      if (this.layer.styleNeedUpdate) {
        this.updateColorTexture();
      }

      this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _shapeAttr$scale;

      var _this$rendererService2 = this.rendererService,
          createFramebuffer = _this$rendererService2.createFramebuffer,
          clear = _this$rendererService2.clear,
          getViewportSize = _this$rendererService2.getViewportSize,
          createTexture2D = _this$rendererService2.createTexture2D,
          useFramebuffer = _this$rendererService2.useFramebuffer;
      var shapeAttr = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shapeType = (shapeAttr === null || shapeAttr === void 0 ? void 0 : (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || 'heatmap';
      this.shapeType = shapeType;
      this.intensityModel = this.buildHeatMapIntensity();
      this.colorModel = shapeType === 'heatmap' ? this.buildHeatmapColor() : this.build3dHeatMap();

      var _getViewportSize = getViewportSize(),
          width = _getViewportSize.width,
          height = _getViewportSize.height;

      this.heatmapFramerBuffer = createFramebuffer({
        color: createTexture2D({
          width: Math.floor(width / 4),
          height: Math.floor(height / 4),
          wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
          wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
          min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LINEAR,
          mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LINEAR
        }),
        depth: false
      });
      this.updateColorTexture();
      return [this.intensityModel, this.colorModel];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'dir',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Dir',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return [size];
          }
        }
      });
    }
  }, {
    key: "buildHeatMapIntensity",
    value: function buildHeatMapIntensity() {
      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_12__.HeatmapTriangulation;
      return this.layer.buildLayerModel({
        moduleName: 'heatmapintensity',
        vertexShader: heatmapFramebufferVert,
        fragmentShader: heatmapFramebufferFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_12__.HeatmapTriangulation,
        depth: {
          enable: false
        },
        cull: {
          enable: true,
          face: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getCullFace)(this.mapService.version)
        },
        blend: {
          enable: true,
          func: {
            srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.ONE,
            srcAlpha: 1,
            dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.ONE,
            dstAlpha: 1
          }
        }
      });
    }
  }, {
    key: "buildHeatmapColor",
    value: function buildHeatmapColor() {
      var _ref = this.layer.getLayerConfig(),
          _ref$mask = _ref.mask,
          mask = _ref$mask === void 0 ? false : _ref$mask,
          _ref$maskInside = _ref.maskInside,
          maskInside = _ref$maskInside === void 0 ? true : _ref$maskInside;

      this.shaderModuleService.registerModule('heatmapColor', {
        vs: heatmapColorVert,
        fs: heatmapColorFrag
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule('heatmapColor'),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var _this$rendererService3 = this.rendererService,
          createAttribute = _this$rendererService3.createAttribute,
          createElements = _this$rendererService3.createElements,
          createBuffer = _this$rendererService3.createBuffer,
          createModel = _this$rendererService3.createModel;
      return createModel({
        vs: vs,
        fs: fs,
        attributes: {
          a_Position: createAttribute({
            buffer: createBuffer({
              data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
            }),
            size: 3
          }),
          a_Uv: createAttribute({
            buffer: createBuffer({
              data: [0, 1, 1, 1, 0, 0, 1, 0],
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
            }),
            size: 2
          })
        },
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        count: 6,
        elements: createElements({
          data: [0, 2, 1, 2, 3, 1],
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.UNSIGNED_INT,
          count: 6
        }),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      });
    }
  }, {
    key: "drawIntensityMode",
    value: function drawIntensityMode() {
      var _ref2 = this.layer.getLayerConfig(),
          opacity = _ref2.opacity,
          _ref2$intensity = _ref2.intensity,
          intensity = _ref2$intensity === void 0 ? 10 : _ref2$intensity,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 5 : _ref2$radius;

      this.intensityModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_radius: radius,
          u_intensity: intensity
        }
      });
    }
  }, {
    key: "drawColorMode",
    value: function drawColorMode() {
      var _ref3 = this.layer.getLayerConfig(),
          opacity = _ref3.opacity;

      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_colorTexture: this.colorTexture,
          u_texture: this.heatmapFramerBuffer
        }
      });
    }
  }, {
    key: "draw3DHeatMap",
    value: function draw3DHeatMap() {
      var _ref4 = this.layer.getLayerConfig(),
          opacity = _ref4.opacity;

      var invert = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_13__.invert(invert, this.cameraService.getViewProjectionMatrixUncentered());
      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_colorTexture: this.colorTexture,
          u_texture: this.heatmapFramerBuffer,
          u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),
          u_InverseViewProjectionMatrix: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(invert)
        }
      });
    }
  }, {
    key: "build3dHeatMap",
    value: function build3dHeatMap() {
      var _ref5 = this.layer.getLayerConfig(),
          _ref5$mask = _ref5.mask,
          mask = _ref5$mask === void 0 ? false : _ref5$mask,
          _ref5$maskInside = _ref5.maskInside,
          maskInside = _ref5$maskInside === void 0 ? true : _ref5$maskInside;

      var getViewportSize = this.rendererService.getViewportSize;

      var _getViewportSize2 = getViewportSize(),
          width = _getViewportSize2.width,
          height = _getViewportSize2.height;

      var triangulation = (0,_triangulation__WEBPACK_IMPORTED_MODULE_14__.heatMap3DTriangulation)(width / 4.0, height / 4.0);
      this.shaderModuleService.registerModule('heatmap3dColor', {
        vs: heatmap3DVert,
        fs: heatmap3DFrag
      });

      var _this$shaderModuleSer2 = this.shaderModuleService.getModule('heatmap3dColor'),
          vs = _this$shaderModuleSer2.vs,
          fs = _this$shaderModuleSer2.fs,
          uniforms = _this$shaderModuleSer2.uniforms;

      var _this$rendererService4 = this.rendererService,
          createAttribute = _this$rendererService4.createAttribute,
          createElements = _this$rendererService4.createElements,
          createBuffer = _this$rendererService4.createBuffer,
          createModel = _this$rendererService4.createModel;
      return createModel({
        vs: vs,
        fs: fs,
        attributes: {
          a_Position: createAttribute({
            buffer: createBuffer({
              data: triangulation.vertices,
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
            }),
            size: 3
          }),
          a_Uv: createAttribute({
            buffer: createBuffer({
              data: triangulation.uvs,
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
            }),
            size: 2
          })
        },
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: true
        },
        blend: {
          enable: true,
          func: {
            srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.SRC_ALPHA,
            srcAlpha: 1,
            dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.ONE_MINUS_SRC_ALPHA,
            dstAlpha: 1
          }
        },
        elements: createElements({
          data: triangulation.indices,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.UNSIGNED_INT,
          count: triangulation.indices.length
        }),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      });
    }
  }, {
    key: "updateStyle",
    value: function updateStyle() {
      this.updateColorTexture();
    }
  }, {
    key: "updateColorTexture",
    value: function updateColorTexture() {
      var createTexture2D = this.rendererService.createTexture2D;

      if (this.texture) {
        this.texture.destroy();
      }

      var _ref6 = this.layer.getLayerConfig(),
          rampColors = _ref6.rampColors;

      var imageData = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.generateColorRamp)(rampColors);
      this.colorTexture = createTexture2D({
        data: new Uint8Array(imageData.data),
        width: imageData.width,
        height: imageData.height,
        wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
        wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        flipY: false
      });
    }
  }]);

  return HeatMapModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_15__.default)) || _class);

//# sourceMappingURL=heatmap.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/models/hexagon.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/models/hexagon.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ HexagonModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var heatmapGridFrag = "precision highp float;\nvarying vec4 v_color;\nuniform float u_opacity: 1;\n\n#pragma include \"picking\"\n\nvoid main() {\n  gl_FragColor = v_color;\n  gl_FragColor.a *= u_opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var heatmapGridVert = "precision highp float;\n// \u591A\u8FB9\u5F62\u9876\u70B9\u5750\u6807\nattribute vec3 a_Position;\n// \u591A\u8FB9\u5F62\u7ECF\u7EAC\u5EA6\u5750\u6807\nattribute vec3 a_Pos;\nattribute float a_Size;\nattribute vec4 a_Color;\nuniform vec2 u_radius;\nuniform float u_coverage: 0.9;\nuniform float u_angle: 0;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform vec2 u_SceneCenterMKT;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_color = a_Color;\n    \n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\n \n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xy, 0., 1.0));\n    // gl_Position = u_Mvp * (vec4(a_Pos.xy + offset, 0., 1.0));\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT;\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\n    gl_Position = u_Mvp * vec4(project_pos.xy, 0.0, 1.0);\n  } else {\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n";

var HexagonModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(HexagonModel, _BaseModel);

  var _super = _createSuper(HexagonModel);

  function HexagonModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, HexagonModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(HexagonModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity,
          coverage = _ref.coverage,
          angle = _ref.angle;

      return {
        u_opacity: opacity || 1.0,
        u_coverage: coverage || 0.9,
        u_angle: angle || 0,
        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'hexagonheatmap',
        vertexShader: heatmapGridVert,
        fragmentShader: heatmapGridFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.HeatmapGridTriangulation,
        depth: {
          enable: false
        },
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.TRIANGLES,
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'pos',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Pos',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx) {
            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;
            return [coordinates[0], coordinates[1], 0];
          }
        }
      });
    }
  }]);

  return HexagonModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=hexagon.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/models/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/models/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/l7-layers/es/heatmap/models/grid.js");
/* harmony import */ var _grid3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grid3d */ "./node_modules/@antv/l7-layers/es/heatmap/models/grid3d.js");
/* harmony import */ var _heatmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heatmap */ "./node_modules/@antv/l7-layers/es/heatmap/models/heatmap.js");
/* harmony import */ var _hexagon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hexagon */ "./node_modules/@antv/l7-layers/es/heatmap/models/hexagon.js");




var HeatMapModels = {
  heatmap: _heatmap__WEBPACK_IMPORTED_MODULE_0__.default,
  heatmap3d: _heatmap__WEBPACK_IMPORTED_MODULE_0__.default,
  grid: _grid__WEBPACK_IMPORTED_MODULE_1__.default,
  grid3d: _grid3d__WEBPACK_IMPORTED_MODULE_2__.default,
  hexagon: _hexagon__WEBPACK_IMPORTED_MODULE_3__.default
};
/* harmony default export */ __webpack_exports__["default"] = (HeatMapModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/heatmap/triangulation.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/heatmap/triangulation.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "heatMap3DTriangulation": function() { return /* binding */ heatMap3DTriangulation; }
/* harmony export */ });
function heatMap3DTriangulation(width, height) {
  var indices = [];
  var vertices = [];
  var uvs = [];
  var gridX1 = width + 1;
  var gridY1 = height + 1;
  var widthHalf = width / 2;
  var heightHalf = height / 2;

  for (var iy = 0; iy < gridY1; iy++) {
    var y = iy - heightHalf;

    for (var ix = 0; ix < gridX1; ix++) {
      var x = ix - widthHalf;
      vertices.push(x / widthHalf, -y / heightHalf, 0);
      uvs.push(ix / width);
      uvs.push(1 - iy / height);
    }
  }

  for (var _iy = 0; _iy < height; _iy++) {
    for (var _ix = 0; _ix < width; _ix++) {
      var a = _ix + gridX1 * _iy;
      var b = _ix + gridX1 * (_iy + 1);
      var c = _ix + 1 + gridX1 * (_iy + 1);
      var d = _ix + 1 + gridX1 * _iy;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }

  return {
    vertices: vertices,
    indices: indices,
    uvs: uvs
  };
}
//# sourceMappingURL=triangulation.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/image/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/image/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ImageLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/index */ "./node_modules/@antv/l7-layers/es/image/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var ImageLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(ImageLayer, _BaseLayer);

  var _super = _createSuper(ImageLayer);

  function ImageLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ImageLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'ImageLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ImageLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models_index__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        image: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return 'image';
    }
  }]);

  return ImageLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/image/models/image.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/image/models/image.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ImageModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var ImageFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}\n";
var ImageVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n#pragma include \"projection\"\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy,0., 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   }\n}\n";

var ImageModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(ImageModel, _BaseModel);

  var _super = _createSuper(ImageModel);

  function ImageModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ImageModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ImageModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity;

      return {
        u_opacity: opacity || 1,
        u_texture: this.texture
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this2 = this;

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      var source = this.layer.getSource();
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });

      if (_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.isMini) {
        var canvas = this.layerService.sceneService.getSceneConfig().canvas;
        var img = canvas.createImage();
        img.crossOrigin = 'anonymous';
        img.src = source.data.originData;

        img.onload = function () {
          _this2.texture = createTexture2D({
            data: img,
            width: img.width,
            height: img.height
          });

          _this2.layerService.updateLayerRenderList();

          _this2.layerService.renderLayers();
        };
      } else {
        source.data.images.then(function (imageData) {
          _this2.texture = createTexture2D({
            data: imageData[0],
            width: imageData[0].width,
            height: imageData[0].height
          });

          _this2.layerService.updateLayerRenderList();

          _this2.layerService.renderLayers();
        });
      }

      return [this.layer.buildLayerModel({
        moduleName: 'RasterImage',
        vertexShader: ImageVert,
        fragmentShader: ImageFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_9__.RasterImageTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.TRIANGLES,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return ImageModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_10__.default);


//# sourceMappingURL=image.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/image/models/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/image/models/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image */ "./node_modules/@antv/l7-layers/es/image/models/image.js");

var ImageModels = {
  image: _image__WEBPACK_IMPORTED_MODULE_0__.default
};
/* harmony default export */ __webpack_exports__["default"] = (ImageModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseLayer": function() { return /* reexport safe */ _core_BaseLayer__WEBPACK_IMPORTED_MODULE_14__.default; },
/* harmony export */   "PointLayer": function() { return /* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_15__.default; },
/* harmony export */   "PolygonLayer": function() { return /* reexport safe */ _polygon__WEBPACK_IMPORTED_MODULE_16__.default; },
/* harmony export */   "LineLayer": function() { return /* reexport safe */ _line_index__WEBPACK_IMPORTED_MODULE_17__.default; },
/* harmony export */   "CityBuildingLayer": function() { return /* reexport safe */ _citybuliding_building__WEBPACK_IMPORTED_MODULE_18__.default; },
/* harmony export */   "GeometryLayer": function() { return /* reexport safe */ _Geometry__WEBPACK_IMPORTED_MODULE_19__.default; },
/* harmony export */   "CanvasLayer": function() { return /* reexport safe */ _canvas__WEBPACK_IMPORTED_MODULE_20__.default; },
/* harmony export */   "ImageLayer": function() { return /* reexport safe */ _image__WEBPACK_IMPORTED_MODULE_21__.default; },
/* harmony export */   "RasterLayer": function() { return /* reexport safe */ _raster__WEBPACK_IMPORTED_MODULE_22__.default; },
/* harmony export */   "HeatmapLayer": function() { return /* reexport safe */ _heatmap__WEBPACK_IMPORTED_MODULE_23__.default; },
/* harmony export */   "EarthLayer": function() { return /* reexport safe */ _earth__WEBPACK_IMPORTED_MODULE_24__.default; },
/* harmony export */   "WindLayer": function() { return /* reexport safe */ _wind__WEBPACK_IMPORTED_MODULE_25__.default; },
/* harmony export */   "MaskLayer": function() { return /* reexport safe */ _mask__WEBPACK_IMPORTED_MODULE_26__.default; },
/* harmony export */   "CanvasUpdateType": function() { return /* reexport safe */ _core_interface__WEBPACK_IMPORTED_MODULE_27__.CanvasUpdateType; },
/* harmony export */   "lineStyleType": function() { return /* reexport safe */ _core_interface__WEBPACK_IMPORTED_MODULE_27__.lineStyleType; }
/* harmony export */ });
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./canvas */ "./node_modules/@antv/l7-layers/es/canvas/index.js");
/* harmony import */ var _citybuliding_building__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./citybuliding/building */ "./node_modules/@antv/l7-layers/es/citybuliding/building.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Geometry */ "./node_modules/@antv/l7-layers/es/Geometry/index.js");
/* harmony import */ var _heatmap__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./heatmap */ "./node_modules/@antv/l7-layers/es/heatmap/index.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./image */ "./node_modules/@antv/l7-layers/es/image/index.js");
/* harmony import */ var _line_index__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./line/index */ "./node_modules/@antv/l7-layers/es/line/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/l7-layers/es/point/index.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./polygon */ "./node_modules/@antv/l7-layers/es/polygon/index.js");
/* harmony import */ var _raster__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raster */ "./node_modules/@antv/l7-layers/es/raster/index.js");
/* harmony import */ var _earth__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./earth */ "./node_modules/@antv/l7-layers/es/earth/index.js");
/* harmony import */ var _mask__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./mask */ "./node_modules/@antv/l7-layers/es/mask/index.js");
/* harmony import */ var _wind__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./wind */ "./node_modules/@antv/l7-layers/es/wind/index.js");
/* harmony import */ var _plugins_DataMappingPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/DataMappingPlugin */ "./node_modules/@antv/l7-layers/es/plugins/DataMappingPlugin.js");
/* harmony import */ var _plugins_DataSourcePlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/DataSourcePlugin */ "./node_modules/@antv/l7-layers/es/plugins/DataSourcePlugin.js");
/* harmony import */ var _plugins_FeatureScalePlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/FeatureScalePlugin */ "./node_modules/@antv/l7-layers/es/plugins/FeatureScalePlugin.js");
/* harmony import */ var _plugins_LayerAnimateStylePlugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/LayerAnimateStylePlugin */ "./node_modules/@antv/l7-layers/es/plugins/LayerAnimateStylePlugin.js");
/* harmony import */ var _plugins_LayerModelPlugin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/LayerModelPlugin */ "./node_modules/@antv/l7-layers/es/plugins/LayerModelPlugin.js");
/* harmony import */ var _plugins_LayerStylePlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/LayerStylePlugin */ "./node_modules/@antv/l7-layers/es/plugins/LayerStylePlugin.js");
/* harmony import */ var _plugins_LightingPlugin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/LightingPlugin */ "./node_modules/@antv/l7-layers/es/plugins/LightingPlugin.js");
/* harmony import */ var _plugins_MultiPassRendererPlugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/MultiPassRendererPlugin */ "./node_modules/@antv/l7-layers/es/plugins/MultiPassRendererPlugin.js");
/* harmony import */ var _plugins_PixelPickingPlugin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/PixelPickingPlugin */ "./node_modules/@antv/l7-layers/es/plugins/PixelPickingPlugin.js");
/* harmony import */ var _plugins_RegisterStyleAttributePlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/RegisterStyleAttributePlugin */ "./node_modules/@antv/l7-layers/es/plugins/RegisterStyleAttributePlugin.js");
/* harmony import */ var _plugins_ShaderUniformPlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/ShaderUniformPlugin */ "./node_modules/@antv/l7-layers/es/plugins/ShaderUniformPlugin.js");
/* harmony import */ var _plugins_UpdateModelPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/UpdateModelPlugin */ "./node_modules/@antv/l7-layers/es/plugins/UpdateModelPlugin.js");
/* harmony import */ var _plugins_UpdateStyleAttributePlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/UpdateStyleAttributePlugin */ "./node_modules/@antv/l7-layers/es/plugins/UpdateStyleAttributePlugin.js");
/* harmony import */ var _core_interface__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./core/interface */ "./node_modules/@antv/l7-layers/es/core/interface.js");




























_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_DataSourcePlugin__WEBPACK_IMPORTED_MODULE_1__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_RegisterStyleAttributePlugin__WEBPACK_IMPORTED_MODULE_2__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_FeatureScalePlugin__WEBPACK_IMPORTED_MODULE_3__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_DataMappingPlugin__WEBPACK_IMPORTED_MODULE_4__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_LayerStylePlugin__WEBPACK_IMPORTED_MODULE_5__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_UpdateStyleAttributePlugin__WEBPACK_IMPORTED_MODULE_6__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_UpdateModelPlugin__WEBPACK_IMPORTED_MODULE_7__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_MultiPassRendererPlugin__WEBPACK_IMPORTED_MODULE_8__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_ShaderUniformPlugin__WEBPACK_IMPORTED_MODULE_9__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_LayerAnimateStylePlugin__WEBPACK_IMPORTED_MODULE_10__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_LightingPlugin__WEBPACK_IMPORTED_MODULE_11__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_PixelPickingPlugin__WEBPACK_IMPORTED_MODULE_12__.default).inRequestScope();
_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.ILayerPlugin).to(_plugins_LayerModelPlugin__WEBPACK_IMPORTED_MODULE_13__.default).inRequestScope();


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LineLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models */ "./node_modules/@antv/l7-layers/es/line/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var LineLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(LineLayer, _BaseLayer);

  var _super = _createSuper(LineLayer);

  function LineLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LineLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'LineLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LineLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var shape = this.getModelType();
      this.layerModel = new _models__WEBPACK_IMPORTED_MODULE_7__.default[shape](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        line: {},
        linearline: {},
        simple: {},
        wall: {},
        arc3d: {
          blend: 'additive'
        },
        arc: {
          blend: 'additive'
        },
        arcmini: {
          blend: 'additive'
        },
        greatcircle: {
          blend: 'additive'
        },
        vectorline: {},
        tileLine: {},
        halfLine: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var _shapeAttribute$scale;

      if (this.layerSource.parser.type === 'mvt') {
        return 'vectorline';
      }

      var shapeAttribute = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shape = shapeAttribute === null || shapeAttribute === void 0 ? void 0 : (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;
      return shape || 'line';
    }
  }]);

  return LineLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/arc.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/arc.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ArcModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var arc_dash_frag = "\nuniform float u_opacity;\n\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float segmentNumber;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].b; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u6BD4\u4F8B\n\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity;\n\n  float flag = 0.;\n  float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n  if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n    flag = 1.;\n  }\n  gl_FragColor.a *=flag;\n  \n  gl_FragColor = filterColor(gl_FragColor);\n}";
var arc_dash_vert = "\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nvarying vec4 v_color;\n\n\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nuniform float u_lineDir: 1.0;\nvarying vec4 v_dash_array;\n\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalThetaOffset\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // \u6B63\u5411\n    return mid;\n  } else { // \u9006\u5411\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  \n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 s = source;\n  vec2 t = target;\n  \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    s = unProjCustomCoord(source);\n    t = unProjCustomCoord(target);\n  }\n  float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n  \n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  \n\n   styleMappingMat[3].b = segmentIndex / segmentNumber;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n";
var arc_line_frag = "\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nuniform float segmentNumber;\nvarying vec2 v_iconMapUV;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_segmentIndex = styleMappingMat[3].r;   // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n  float d_distance_ratio = styleMappingMat[3].b; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u6BD4\u4F8B\n\n  gl_FragColor = v_color;\n  \n  gl_FragColor.a *= opacity;\n\n  if(u_aimate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n  }\n\n  // \u5F53\u5B58\u5728\u8D34\u56FE\u65F6\u5728\u5E95\u8272\u4E0A\u8D34\u4E0A\u8D34\u56FE\n  if(u_line_texture == LineTexture) { // while load texture\n    float arcRadio = smoothstep( 0.0, 1.0, (d_segmentIndex / segmentNumber));\n    // float arcRadio = smoothstep( 0.0, 1.0, d_distance_ratio);\n\n    float count = styleMappingMat[3].g; // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    float time = 0.0;\n    if(u_aimate.x == Animate) {\n      time = u_time / u_aimate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n    float v = styleMappingMat[3].a; // \u6A2A\u5411 v\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n\n    vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_aimate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_aimate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n    \n  } else {\n     gl_FragColor = filterColor(gl_FragColor);\n  }\n  // gl_FragColor = filterColor(gl_FragColor);\n}";
var arc_line_vert = "#define Animate 0.0\n#define LineTexture 1.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n\nuniform float u_lineDir: 1.0;\n\nuniform float u_thetaOffset: 0.314;\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalThetaOffset\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // \u6B63\u5411\n    return mid;\n  } else { // \u9006\u5411\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  \n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n  \n  if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n      if(u_lineDir != 1.0) {\n        d_distance_ratio = 1.0 - d_distance_ratio;\n      }\n  }\n\n   styleMappingMat[3].b = d_distance_ratio;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n\n  float d_segmentIndex = a_Position.x + 1.0; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n  styleMappingMat[3].r = d_segmentIndex;\n\n  if(LineTexture == u_line_texture) { // \u5F00\u542F\u8D34\u56FE\u6A21\u5F0F\n\n    float arcDistrance = length(source - target); // \u8D77\u59CB\u70B9\u548C\u7EC8\u70B9\u7684\u8DDD\u79BB\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20) { // amap\n      arcDistrance *= 1000000.0;\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) { // mapbox\n      // arcDistrance *= 8.0;\n      arcDistrance = project_pixel_allmap(arcDistrance);\n    }\n    v_iconMapUV = a_iconMapUV;\n\n    float pixelLen = project_pixel_texture(u_icon_step); // \u8D34\u56FE\u6CBF\u5F27\u7EBF\u65B9\u5411\u7684\u957F\u5EA6 - \u968F\u5730\u56FE\u7F29\u653E\u6539\u53D8\n    float texCount = floor(arcDistrance/pixelLen); // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n     styleMappingMat[3].g = texCount;\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\n    float linePixelSize = project_pixel(a_Size); // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\n     styleMappingMat[3].a = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n";
var arc_linear_frag = "#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nuniform float segmentNumber;\nvarying vec2 v_iconMapUV;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_segmentIndex = styleMappingMat[3].r;   // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n\n  // \u8BBE\u7F6E\u5F27\u7EBF\u7684\u5E95\u8272\n  gl_FragColor = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}";
var arc_linear_vert = "\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nvarying vec4 v_color;\n\nuniform float u_lineDir: 1.0;\n\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalThetaOffset\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // \u6B63\u5411\n    return mid;\n  } else { // \u9006\u5411\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke -> thetaOffset... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 thetaOffsetAndOffset = calThetaOffsetAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = thetaOffsetAndOffset.r;\n  textureOffset = thetaOffsetAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  \n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n\n   styleMappingMat[3].b = d_distance_ratio;\n\n  // styleMappingMat[0][1] - arcThetaOffset\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, styleMappingMat[0][1]), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n\n  float d_segmentIndex = a_Position.x + 1.0; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n  styleMappingMat[3].r = d_segmentIndex;\n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};

var ArcModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(ArcModel, _BaseModel);

  var _super = _createSuper(ArcModel);

  function ArcModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ArcModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ArcModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$lineType = _ref.lineType,
          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
          _ref$dashArray = _ref.dashArray,
          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray,
          _ref$forward = _ref.forward,
          forward = _ref$forward === void 0 ? true : _ref$forward,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$segmentNumber = _ref.segmentNumber,
          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber,
          _ref$thetaOffset = _ref.thetaOffset,
          thetaOffset = _ref$thetaOffset === void 0 ? 0.314 : _ref$thetaOffset;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        thetaOffset: thetaOffset
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          thetaOffset: thetaOffset
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      if (dashArray.length === 2) {
        dashArray.push(0, 0);
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_thetaOffset: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(thetaOffset) ? thetaOffset : 0.0,
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        segmentNumber: segmentNumber,
        u_line_type: lineStyleObj[lineType || 'solid'],
        u_dash_array: dashArray,
        u_blur: 0.9,
        u_lineDir: forward ? 1 : -1,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref3 = this.layer.getLayerConfig(),
          sourceColor = _ref3.sourceColor,
          targetColor = _ref3.targetColor,
          lineType = _ref3.lineType;

      if (lineType === 'dash') {
        return {
          frag: arc_dash_frag,
          vert: arc_dash_vert,
          type: 'dash'
        };
      }

      if (sourceColor && targetColor) {
        return {
          frag: arc_linear_frag,
          vert: arc_linear_vert,
          type: 'linear'
        };
      } else {
        return {
          frag: arc_line_frag,
          vert: arc_line_vert,
          type: 'normal'
        };
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$segmentNumber = _ref4.segmentNumber,
          segmentNumber = _ref4$segmentNumber === void 0 ? 30 : _ref4$segmentNumber,
          _ref4$mask = _ref4.mask,
          mask = _ref4$mask === void 0 ? false : _ref4$mask,
          _ref4$maskInside = _ref4.maskInside,
          maskInside = _ref4$maskInside === void 0 ? true : _ref4$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: 'arc2dline' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineArcTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        segmentNumber: segmentNumber,
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref5 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref5.x,
                y = _ref5.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return ArcModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=arc.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/arc_3d.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/arc_3d.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Arc3DModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _earth_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../earth/utils */ "./node_modules/@antv/l7-layers/es/earth/utils.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var arc3d_line_frag = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying vec4 v_color;\n\nuniform float u_line_texture: 0.0;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\nvarying float v_segmentIndex;\nuniform float segmentNumber;\n\nvarying vec2 v_iconMapUV;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nvarying mat4 styleMappingMat;\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_distance_ratio = styleMappingMat[3].g; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  gl_FragColor = v_color;\n\n  gl_FragColor.a *= opacity;\n  if(u_line_type == LineTypeDash) {\n    float flag = 0.;\n    float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    gl_FragColor.a *=flag;\n  }\n\n  if(u_aimate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n\n      // u_aimate \n      // x enable\n      // y duration\n      // z interval\n      // w trailLength\n  }\n\n  if(u_line_texture == LineTexture && u_line_type != LineTypeDash) { // while load texture\n    // float arcRadio = smoothstep( 0.0, 1.0, (v_segmentIndex / segmentNumber));\n    float arcRadio = v_segmentIndex / (segmentNumber - 1.0);\n    float count = styleMappingMat[3].b; // // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    float time = 0.0;\n    if(u_aimate.x == Animate) {\n      time = u_time / u_aimate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n\n    float v = styleMappingMat[3].a;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_aimate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_aimate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n          discard;\n        } else {\n          gl_FragColor = filterColor(pattern);\n        }\n    }\n\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n";
var arc3d_line_vert = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform float u_globel;\nuniform float u_globel_radius;\nuniform float u_global_height: 10;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nvarying float v_segmentIndex;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nfloat torad(float deg) {\n  return (deg / 180.0) * acos(-1.0);\n}\n\nvec3 lglt2xyz(vec2 lnglat) {\n  float pi = 3.1415926;\n  // TODO: + Math.PI/2 \u662F\u4E3A\u4E86\u5BF9\u9F50\u5750\u6807\n  float lng = torad(lnglat.x) + pi / 2.0;\n  float lat = torad(lnglat.y);\n\n  // TODO: \u624B\u52A8\u589E\u52A0\u4E00\u4E9B\u504F\u79FB\uFF0C\u51CF\u8F7B\u9762\u7684\u51B2\u7A81\n  float radius = u_globel_radius;\n\n  float z = radius * cos(lat) * cos(lng);\n  float x = radius * cos(lat) * sin(lng);\n  float y = radius * sin(lat);\n  return vec3(x, y, z);\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = a_Color;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  float d_distance_ratio;\n   if(u_line_type == LineTypeDash) {\n    d_distance_ratio = segmentIndex / segmentNumber;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n  }\n  styleMappingMat[3].g = d_distance_ratio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n\n  v_segmentIndex = a_Position.x;\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { // \u5F00\u542F\u8D34\u56FE\u6A21\u5F0F  \n\n    float arcDistrance = length(source - target);\n    float pixelLen =  project_pixel_texture(u_icon_step);\n    styleMappingMat[3].b = floor(arcDistrance/pixelLen); // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    vec2 projectOffset = project_pixel(offset);\n    float lineOffsetWidth = length(projectOffset + projectOffset * sign(a_Position.y)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\n    float linePixelSize = project_pixel(a_Size);  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    v_iconMapUV = a_iconMapUV;\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  }\n\n  // \u5730\u7403\u6A21\u5F0F\n  if(u_globel > 0.0) {\n    vec3 startLngLat = lglt2xyz(a_Instance.rg);\n    vec3 endLngLat = lglt2xyz(a_Instance.ba);\n    float globalRadius = length(startLngLat);\n\n    vec3 lineDir = normalize(endLngLat - startLngLat);\n    vec3 midPointDir = normalize((startLngLat + endLngLat)/2.0);\n\n    // \u7EBF\u7684\u504F\u79FB\n    vec3 lnglatOffset = cross(lineDir, midPointDir) * a_Position.y;\n    // \u8BA1\u7B97\u8D77\u59CB\u70B9\u548C\u7EC8\u6B62\u70B9\u7684\u8DDD\u79BB\n    float lnglatLength = length(a_Instance.rg - a_Instance.ba)/50.0;\n    // \u8BA1\u7B97\u98DE\u7EBF\u5404\u4E2A\u8282\u70B9\u76F8\u5E94\u7684\u9AD8\u5EA6\n    float lineHeight = u_global_height * (-4.0*segmentRatio*segmentRatio + 4.0 * segmentRatio) * lnglatLength;\n    // \u5730\u7403\u70B9\u4F4D\n    vec3 globalPoint = normalize(mix(startLngLat, endLngLat, segmentRatio)) * (globalRadius + lineHeight) + lnglatOffset * a_Size;\n    \n    gl_Position = u_ViewProjectionMatrix * vec4(globalPoint, 1.0);\n  }\n \n\n  setPickingColor(a_PickingColor);\n}\n";
var arc3d_linear_frag = "\n#define Animate 0.0\n\nuniform float u_opacity;\nuniform float u_blur : 0.9;\nvarying float v_segmentIndex;\nuniform float segmentNumber;\n\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_distance_ratio = styleMappingMat[3].g; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  gl_FragColor = mix(u_sourceColor, u_targetColor, v_segmentIndex/segmentNumber);\n\n  gl_FragColor.a *= opacity;\n\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n\n      // u_aimate \n      // x enable\n      // y duration\n      // z interval\n      // w trailLength\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var arc3d_linear_vert = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform float u_globel;\nuniform float u_globel_radius;\nuniform float u_global_height: 10;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\nvarying float v_segmentIndex;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nfloat torad(float deg) {\n  return (deg / 180.0) * acos(-1.0);\n}\n\nvec3 lglt2xyz(vec2 lnglat) {\n  float pi = 3.1415926;\n  // TODO: + Math.PI/2 \u662F\u4E3A\u4E86\u5BF9\u9F50\u5750\u6807\n  float lng = torad(lnglat.x) + pi / 2.0;\n  float lat = torad(lnglat.y);\n\n  // TODO: \u624B\u52A8\u589E\u52A0\u4E00\u4E9B\u504F\u79FB\uFF0C\u51CF\u8F7B\u9762\u7684\u51B2\u7A81\n  float radius = u_globel_radius;\n\n  float z = radius * cos(lat) * cos(lng);\n  float x = radius * cos(lat) * sin(lng);\n  float y = radius * sin(lat);\n  return vec3(x, y, z);\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = a_Color;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  float d_distance_ratio;\n   if(u_line_type == LineTypeDash) {\n    d_distance_ratio = segmentIndex / segmentNumber;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_aimate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n  }\n  styleMappingMat[3].g = d_distance_ratio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n\n  v_segmentIndex = a_Position.x;\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { // \u5F00\u542F\u8D34\u56FE\u6A21\u5F0F  \n\n    float arcDistrance = length(source - target);\n    float pixelLen =  project_pixel_texture(u_icon_step);\n    styleMappingMat[3].b = floor(arcDistrance/pixelLen); // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    vec2 projectOffset = project_pixel(offset);\n    float lineOffsetWidth = length(projectOffset + projectOffset * sign(a_Position.y)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\n    float linePixelSize = project_pixel(a_Size);  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    v_iconMapUV = a_iconMapUV;\n  }\n  \n\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  }\n\n  // \u5730\u7403\u6A21\u5F0F\n  if(u_globel > 0.0) {\n    vec3 startLngLat = lglt2xyz(a_Instance.rg);\n    vec3 endLngLat = lglt2xyz(a_Instance.ba);\n    float globalRadius = length(startLngLat);\n\n    vec3 lineDir = normalize(endLngLat - startLngLat);\n    vec3 midPointDir = normalize((startLngLat + endLngLat)/2.0);\n\n    // \u7EBF\u7684\u504F\u79FB\n    vec3 lnglatOffset = cross(lineDir, midPointDir) * a_Position.y;\n    // \u8BA1\u7B97\u8D77\u59CB\u70B9\u548C\u7EC8\u6B62\u70B9\u7684\u8DDD\u79BB\n    float lnglatLength = length(a_Instance.rg - a_Instance.ba)/50.0;\n    // \u8BA1\u7B97\u98DE\u7EBF\u5404\u4E2A\u8282\u70B9\u76F8\u5E94\u7684\u9AD8\u5EA6\n    float lineHeight = u_global_height * (-4.0*segmentRatio*segmentRatio + 4.0 * segmentRatio) * lnglatLength;\n    // \u5730\u7403\u70B9\u4F4D\n    vec3 globalPoint = normalize(mix(startLngLat, endLngLat, segmentRatio)) * (globalRadius + lineHeight) + lnglatOffset * a_Size;\n    \n    gl_Position = u_ViewProjectionMatrix * vec4(globalPoint, 1.0);\n  }\n \n\n  setPickingColor(a_PickingColor);\n}\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};

var Arc3DModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Arc3DModel, _BaseModel);

  var _super = _createSuper(Arc3DModel);

  function Arc3DModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Arc3DModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Arc3DModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$lineType = _ref.lineType,
          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
          _ref$dashArray = _ref.dashArray,
          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$segmentNumber = _ref.segmentNumber,
          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber,
          _ref$globalArcHeight = _ref.globalArcHeight,
          globalArcHeight = _ref$globalArcHeight === void 0 ? 10 : _ref$globalArcHeight;

      if (dashArray.length === 2) {
        dashArray.push(0, 0);
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_globel: this.mapService.version === 'GLOBEL' ? 1 : 0,
        u_globel_radius: _earth_utils__WEBPACK_IMPORTED_MODULE_10__.EARTH_RADIUS,
        u_global_height: globalArcHeight,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        segmentNumber: segmentNumber,
        u_line_type: lineStyleObj[lineType] || 0.0,
        u_dash_array: dashArray,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref3 = this.layer.getLayerConfig(),
          sourceColor = _ref3.sourceColor,
          targetColor = _ref3.targetColor;

      if (sourceColor && targetColor) {
        return {
          frag: arc3d_linear_frag,
          vert: arc3d_linear_vert,
          type: 'linear'
        };
      } else {
        return {
          frag: arc3d_line_frag,
          vert: arc3d_line_vert,
          type: 'normal'
        };
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$segmentNumber = _ref4.segmentNumber,
          segmentNumber = _ref4$segmentNumber === void 0 ? 30 : _ref4$segmentNumber,
          _ref4$mask = _ref4.mask,
          mask = _ref4$mask === void 0 ? false : _ref4$mask,
          _ref4$maskInside = _ref4.maskInside,
          maskInside = _ref4$maskInside === void 0 ? true : _ref4$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: 'arc3Dline' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.LineArcTriangulation,
        blend: this.getBlend(),
        segmentNumber: segmentNumber,
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref5 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref5.x,
                y = _ref5.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return Arc3DModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=arc_3d.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/arcmini.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/arcmini.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ArcMiniModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_arcmini_frag = "#define Animate 0.0\n\nuniform float u_opacity;\nuniform float u_blur : 0.9;\n// varying vec2 v_normal;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float segmentNumber;\nvarying float v_distance_ratio;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include \"picking\"\n\nvoid main() {\n\n  // \u8BBE\u7F6E\u5F27\u7EBF\u7684\u5E95\u8272\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v_distance_ratio);\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     gl_FragColor = v_color;\n  }\n  \n \n  gl_FragColor.a *= u_opacity;\n\n  if(u_aimate.x == Animate) {\n      float animateSpeed = u_time / u_aimate.y; // \u8FD0\u52A8\u901F\u5EA6\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      gl_FragColor.a *= alpha;\n  }\n}";
var line_arcmini_vert = "#define Animate 0.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n\nuniform float u_lineDir: 1.0;\n\n// \u504F\u79FB\u91CF\nuniform float u_thetaOffset: 0.314;\n\nuniform float u_opacity: 1.0;\nvarying float v_distance_ratio;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = u_thetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // \u6B63\u5411\n    return mid;\n  } else { // \u9006\u5411\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\nvec2 interpolate (vec2 source, vec2 target, float t) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n  \n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  v_distance_ratio = segmentIndex / segmentNumber;\n  \n  if(u_aimate.x == Animate && u_lineDir != 1.0) {\n      v_distance_ratio = 1.0 - v_distance_ratio;\n  }\n\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  //unProjCustomCoord\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  }\n}\n";

var ArcMiniModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(ArcMiniModel, _BaseModel);

  var _super = _createSuper(ArcMiniModel);

  function ArcMiniModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ArcMiniModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ArcMiniModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$forward = _ref.forward,
          forward = _ref$forward === void 0 ? true : _ref$forward,
          _ref$segmentNumber = _ref.segmentNumber,
          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber,
          _ref$thetaOffset = _ref.thetaOffset,
          thetaOffset = _ref$thetaOffset === void 0 ? 0.314 : _ref$thetaOffset;

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      return {
        u_thetaOffset: thetaOffset,
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0,
        segmentNumber: segmentNumber,
        u_blur: 0.9,
        u_lineDir: forward ? 1 : -1,
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$segmentNumber = _ref3.segmentNumber,
          segmentNumber = _ref3$segmentNumber === void 0 ? 30 : _ref3$segmentNumber;

      return [this.layer.buildLayerModel({
        moduleName: 'arc2dminiline',
        vertexShader: line_arcmini_vert,
        fragmentShader: line_arcmini_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.LineArcTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        segmentNumber: segmentNumber
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
    }
  }]);

  return ArcMiniModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=arcmini.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/great_circle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/great_circle.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ GreatCircleModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_arc_frag = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity;\nuniform float u_textureBlend;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\n// varying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying float v_distance_ratio;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\nuniform float u_line_texture: 0.0;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\nuniform float segmentNumber;\n\nvarying vec2 v_iconMapUV;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\n\n#pragma include \"picking\"\n#pragma include \"project\"\n#pragma include \"projection\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0;\n  float d_segmentIndex = styleMappingMat[3].g;\n  \n  // \u8BBE\u7F6E\u5F27\u7EBF\u7684\u5E95\u8272\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     gl_FragColor = v_color;\n  }\n\n  // float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\n  // float blur = smoothstep(1.0, u_blur, length(v_normal.xy));\n  gl_FragColor.a *= opacity;\n  if(u_line_type == LineTypeDash) {\n   float flag = 0.;\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    gl_FragColor.a *=flag;\n  }\n\n  // \u8BBE\u7F6E\u5F27\u7EBF\u7684\u52A8\u753B\u6A21\u5F0F\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n      float alpha =1.0 - fract( mod(1.0- smoothstep(0.0, 1.0, v_distance_ratio), u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  // \u8BBE\u7F6E\u5F27\u7EBF\u7684\u8D34\u56FE\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { \n    float arcRadio = smoothstep( 0.0, 1.0, (d_segmentIndex / (segmentNumber - 1.0)));\n    // float arcRadio = d_segmentIndex / (segmentNumber - 1.0);\n    float count = styleMappingMat[3].b; // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n    float u = fract(arcRadio * count - animateSpeed * count);\n    // float u = fract(arcRadio * count - animateSpeed);\n    if(u_aimate.x == Animate) {\n      u = gl_FragColor.a/opacity;\n    }\n\n    float v = styleMappingMat[3].a; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n    \n    // \u8BBE\u7F6E\u8D34\u56FE\u548C\u5E95\u8272\u7684\u53E0\u52A0\u6A21\u5F0F\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n\n  // gl_FragColor = filterColor(gl_FragColor);\n}";
var line_arc2d_vert = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute float a_Size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\n// varying vec2 v_normal;\n\nvarying float v_distance_ratio;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\nuniform float u_icon_step: 100;\nuniform float u_line_texture: 0.0;\n\nattribute vec2 a_iconMapUV;\nvarying vec2 v_iconMapUV;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n    vec2 x = mix(source, target, ratio);\n    vec2 center = mix(source, target, 0.5);\n    float dSourceCenter = distance(source, center);\n    float dXCenter = distance(x, center);\n    return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n     float vertex_height = paraboloid(source, target, segmentRatio);\n\n    return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n    );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size)/ 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 delta = source - target;\n  vec2 sin_half_delta = sin(delta / 2.0);\n  float a =\n    sin_half_delta.y * sin_half_delta.y +\n    cos(source.y) * cos(target.y) *\n    sin_half_delta.x * sin_half_delta.x;\n  return 2.0 * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvec2 midPoint(vec2 source, vec2 target) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = 0.314;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  return mid;\n}\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\n\nvec2 interpolate (vec2 source, vec2 target, float angularDist, float t) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    vec2 mid = midPoint(source, target);\n    vec3 x = vec3(source.x, mid.x, target.x);\n    vec3 y = vec3(source.y, mid.y, target.y);\n    return vec2(bezier3(x ,t), bezier3(y,t));\n  }else {\n    if(abs(angularDist - PI) < 0.001) {\n      return (1.0 - t) * source + t * target;\n    }\n    float a = sin((1.0 - t) * angularDist) / sin(angularDist);\n    float b = sin(t * angularDist) / sin(angularDist);\n    vec2 sin_source = sin(source);\n    vec2 cos_source = cos(source);\n    vec2 sin_target = sin(target);\n    vec2 cos_target = cos(target);\n    float x = a * cos_source.y * cos_source.x + b * cos_target.y * cos_target.x;\n    float y = a * cos_source.y * sin_source.x + b * cos_target.y * sin_target.x;\n    float z = a * sin_source.y + b * sin_target.y;\n    return vec2(atan(y, x), atan(z, sqrt(x * x + y * y)));\n  }\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // dataset \u6570\u636E\u96C6\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = a_Color;\n  vec2 source = radians(a_Instance.rg);\n  vec2 target = radians(a_Instance.ba);\n  float angularDist = getAngularDist(source, target);\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  if(u_line_type == LineTypeDash) {\n    v_distance_ratio = segmentIndex / segmentNumber;\n    vec2 s = source;\n    vec2 t = target;\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      s = unProjCustomCoord(source);\n      t = unProjCustomCoord(target);\n    }\n    float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n    total_Distance = total_Distance*8.0;\n    // float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba);\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n  if(u_aimate.x == Animate) {\n      v_distance_ratio = segmentIndex / segmentNumber;\n  }\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  v_distance_ratio = segmentIndex / segmentNumber;\n  vec4 curr = project_position(vec4(degrees(interpolate(source, target, angularDist, segmentRatio)), 0.0, 1.0));\n  vec4 next = project_position(vec4(degrees(interpolate(source, target, angularDist, nextSegmentRatio)), 0.0, 1.0));\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n  //  vec4 project_pos = project_position(vec4(curr.xy, 0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\n\n  styleMappingMat[3].g = a_Position.x; // \u8BE5\u9876\u70B9\u5728\u5F27\u7EBF\u4E0A\u7684\u5206\u6BB5\u6392\u5E8F\n  if(LineTexture == u_line_texture) { // \u5F00\u542F\u8D34\u56FE\u6A21\u5F0F  \n    // float mapZoomScale = u_CoordinateSystem !== COORDINATE_SYSTEM_P20_2?10000000.0:1.0;\n    float d_arcDistrance = length(source - target);\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20) { // amap\n      d_arcDistrance = d_arcDistrance * 1000000.0;\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) { // mapbox\n      d_arcDistrance = project_pixel_allmap(d_arcDistrance);\n    }\n    float d_pixelLen = project_pixel(u_icon_step)/8.0;\n    styleMappingMat[3].b = floor(d_arcDistrance/d_pixelLen); // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\n    float linePixelSize = project_pixel(a_Size);  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB\n    styleMappingMat[3].a = lineOffsetWidth/linePixelSize;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    v_iconMapUV = a_iconMapUV;\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, curr.z, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\n  }\n  setPickingColor(a_PickingColor);\n}\n\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};

var GreatCircleModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(GreatCircleModel, _BaseModel);

  var _super = _createSuper(GreatCircleModel);

  function GreatCircleModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, GreatCircleModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(GreatCircleModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$lineType = _ref.lineType,
          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
          _ref$dashArray = _ref.dashArray,
          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$segmentNumber = _ref.segmentNumber,
          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber;

      if (dashArray.length === 2) {
        dashArray.push(0, 0);
      }

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        segmentNumber: segmentNumber,
        u_line_type: lineStyleObj[lineType] || 0.0,
        u_dash_array: dashArray,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'greatcircleline',
        vertexShader: line_arc2d_vert,
        fragmentShader: line_arc_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineArcTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref4 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref4.x,
                y = _ref4.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return GreatCircleModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=great_circle.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/half.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/half.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LineModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_half_frag = "#define COORDINATE_SYSTEM_LNGLAT 1.0        // mapbox\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET 2.0 // mapbox offset\n#define COORDINATE_SYSTEM_VECTOR_TILE 3.0\n#define COORDINATE_SYSTEM_IDENTITY 4.0\n#define COORDINATE_SYSTEM_P20 5.0           // amap\n#define COORDINATE_SYSTEM_P20_OFFSET 6.0    // amap offset\n#define COORDINATE_SYSTEM_METER_OFFSET 7.0\n\n#define COORDINATE_SYSTEM_P20_2 8.0         // amap2.0\nuniform float u_CoordinateSystem;\nvarying vec4 v_color;\nuniform float u_arrow: 0.0;\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include \"picking\"\n\nvarying mat4 styleMappingMat;\nvoid main() {\n  float distanceAndIndex = styleMappingMat[0][3];\n  float miter = styleMappingMat[0][2];\n\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n\n  if(u_arrow > 0.0 && distanceAndIndex < 2.0) { // arrow\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) { \n      if(cross(vec3(styleMappingMat[1].rg, 0.0), vec3(styleMappingMat[1].ba, 0.0)).z < 0.0) { // amap\n        discard;\n      }\n    } else { // amap2 mapbox map\n      if(cross(vec3(styleMappingMat[1].rg, 0.0), vec3(styleMappingMat[1].ba, 0.0)).z > 0.0) { \n        discard;\n      }\n    }\n  } else { // line body\n    if(miter < 0.0) {\n      discard;\n    }\n  }\n\n\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n    gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var line_half_vert = "attribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\n// dash line\nattribute vec4 a_dirPoints;\nattribute vec3 a_DistanceAndIndex;\n\nuniform vec4 u_lineDir;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvarying vec4 v_color;\n\nuniform float u_linearColor: 0;\nuniform float u_arrow: 0.0;\nuniform float u_arrowHeight: 3.0;\nuniform float u_arrowWidth: 2.0;\nuniform float u_tailWidth: 1.0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvec2 calculateArrow(vec2 offset) {\n  /*\n  * \u5728\u652F\u6301\u7BAD\u5934\u7684\u65F6\u5019\uFF0C\u7B2C\u4E8C\u3001\u7B2C\u4E09\u7EC4\u9876\u70B9\u662F\u989D\u5916\u63D2\u5165\u7528\u4E8E\u6784\u5EFA\u9876\u70B9\u7684\n  */\n  float arrowFlag = -1.0;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // \u9AD8\u5FB7 2.0 \u7684\u65CB\u8F6C\u89D2\u5EA6\u4E0D\u540C\n    arrowFlag = 1.0;\n  }\n  float pi = arrowFlag * 3.1415926/2.;\n  if(a_Miter < 0.) {\n    // \u6839\u636E\u7EBF\u7684\u4E24\u4FA7\u504F\u79FB\u4E0D\u540C\u3001\u65CB\u8F6C\u7684\u65B9\u5411\u76F8\u53CD\n    pi = -pi;\n  }\n  highp float angle_sin = sin(pi);\n  highp float angle_cos = cos(pi);\n  // \u8BA1\u7B97\u5782\u76F4\u4E0E\u7EBF\u65B9\u5411\u7684\u65CB\u8F6C\u77E9\u9635\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  float arrowWidth = u_arrowWidth;\n  float arrowHeight = u_arrowHeight;\n\n  vec2 arrowOffset = vec2(0.0);\n  /*\n  * a_DistanceAndIndex.y \u7528\u4E8E\u6807\u8BB0\u5F53\u524D\u9876\u70B9\u5C5E\u4E8E\u54EA\u4E00\u7EC4\uFF08\u4E24\u4E2A\u9876\u70B9\u4E00\u7EC4\uFF0C\u6784\u6210\u7EBF\u7684\u5176\u5B9E\u662F\u77E9\u5F62\uFF0C\u6700\u7B80\u9700\u8981\u56DB\u4E2A\u9876\u70B9\u3001\u4E24\u7EC4\u9876\u70B9\u6784\u6210\uFF09\n  */\n  if(a_DistanceAndIndex.y == 0.0) {\n    // \u7BAD\u5934\u5C16\u90E8\n    offset = vec2(0.0);\n  } else if(a_DistanceAndIndex.y == 1.0) {\n    // \u7BAD\u5934\u4E24\u4FA7\n    arrowOffset = rotation_matrix*(offset * arrowHeight);\n    offset += arrowOffset; // \u6CBF\u7EBF\u504F\u79FB\n    offset = offset * arrowWidth; // \u5782\u76F4\u7EBF\u5411\u5916\u504F\u79FB\uFF08\u662F\u6784\u5EFA\u7BAD\u5934\u4E24\u4FA7\u7684\u9876\u70B9\uFF09\n  } else if(a_DistanceAndIndex.y == 2.0 || a_DistanceAndIndex.y == 3.0 || a_DistanceAndIndex.y == 4.0) {\n    // \u504F\u79FB\u5176\u4F59\u7684\u70B9\u4F4D\uFF08\u5C06\u957F\u5EA6\u8BA9\u4F4D\u7ED9\u7BAD\u5934\uFF09\n    arrowOffset = rotation_matrix*(offset * arrowHeight) * arrowWidth;\n    offset += arrowOffset;// \u6CBF\u7EBF\u504F\u79FB\n  }\n\n  return offset;\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - a_Miter - a_DistanceAndIndex\n    0.0, 0.0, 0.0, 0.0, // originX - originY - vectorX - vectorY\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n  styleMappingMat[0][3] = a_DistanceAndIndex.y;\n  styleMappingMat[0][2] = a_Miter;\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  \n  vec2 offset = project_pixel(size.xy);\n\n  // styleMappingMat[1].rg = a_Position.xy + offset;\n\n  vec2 copyOffset = vec2(offset.x, offset.y);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float total_Distance = a_DistanceAndIndex.z;\n  float currentLinePointRatio = lineDistance / total_Distance;\n \n  if(u_arrow > 0.0) {\n      //  \u8BA1\u7B97\u7BAD\u5934\n    offset = calculateArrow(offset);\n\n    if(a_DistanceAndIndex.y > 4.0) {\n      offset *= mix(1.0, u_tailWidth, currentLinePointRatio);\n    }\n  }\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = currentLinePointRatio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  styleMappingMat[3][1] = lineDistance;       // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z); // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // \u4FDD\u6301\u548C amap/mapbox \u4E00\u81F4\u7684\u6548\u679C\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight, 1.0));\n  }\n  \n  if(u_arrow > 0.0 && a_DistanceAndIndex.y < 2.0) {\n    vec2 startPoint = a_dirPoints.rg;\n    vec2 endPoint = a_dirPoints.ba;\n    vec4 t1 = project_position(vec4(startPoint, 0, 1.0));\n    vec4 t2 = project_position(vec4(endPoint, 0, 1.0));\n    // TODO\uFF1A \u540E\u7EED\u4F18\u5316\u53EF\u4EE5\u628A\u4F4D\u7F6E\u8BA1\u7B97\u653E\u5728 cpu \u4E2D\u5B8C\u6210\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      vec2 p1 = (u_Mvp * vec4(t1.xy, 0.0, 1.0)).xy;\n      vec2 p2 = (u_Mvp * vec4(t2.xy, 0.0, 1.0)).xy;\n      styleMappingMat[1].rg = normalize(p1 - p2);\n      styleMappingMat[1].ba = normalize(gl_Position.xy - p2);\n    } else {\n      vec2 p1 = project_common_position_to_clipspace(vec4(t1.xy, 0.0, 1.0)).xy;\n      vec2 p2 = project_common_position_to_clipspace(vec4(t2.xy, 0.0, 1.0)).xy;\n      styleMappingMat[1].rg = normalize(p1 - p2);\n      styleMappingMat[1].ba = normalize(gl_Position.xy - p2);\n    }\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";

var LineModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(LineModel, _BaseModel);

  var _super = _createSuper(LineModel);

  function LineModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LineModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$arrow = _ref.arrow,
          arrow = _ref$arrow === void 0 ? {
        enable: false,
        arrowWidth: 2,
        arrowHeight: 3,
        tailWidth: 1
      } : _ref$arrow;

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0,
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_arrow: Number(arrow.enable),
        u_arrowHeight: arrow.arrowHeight || 3,
        u_arrowWidth: arrow.arrowWidth || 2,
        u_tailWidth: arrow.tailWidth === undefined ? 1 : arrow.tailWidth
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? false : _ref2$depth;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert;

      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.LineTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'line_half',
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.LineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.TRIANGLES,
        blend: this.getBlend(),
        depth: {
          enable: depth
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: line_half_frag,
        vert: line_half_vert,
        type: 'normal'
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'distanceAndIndex',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_DistanceAndIndex',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
            return vertexIndex === undefined ? [vertex[3], 10, vertex[5]] : [vertex[3], vertexIndex, vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'dirPoints',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_dirPoints',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var startPoint = feature.coordinates[0] || [0, 0];
            var endPoint = feature.coordinates[3] || [0, 0];
            return [startPoint[0], startPoint[1], endPoint[0], endPoint[1]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
    }
  }]);

  return LineModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=half.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tile/models/tileModel */ "./node_modules/@antv/l7-layers/es/tile/models/tileModel.js");
/* harmony import */ var _arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc */ "./node_modules/@antv/l7-layers/es/line/models/arc.js");
/* harmony import */ var _arc_3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arc_3d */ "./node_modules/@antv/l7-layers/es/line/models/arc_3d.js");
/* harmony import */ var _arcmini__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arcmini */ "./node_modules/@antv/l7-layers/es/line/models/arcmini.js");
/* harmony import */ var _great_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./great_circle */ "./node_modules/@antv/l7-layers/es/line/models/great_circle.js");
/* harmony import */ var _half__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./half */ "./node_modules/@antv/l7-layers/es/line/models/half.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/l7-layers/es/line/models/line.js");
/* harmony import */ var _linearline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./linearline */ "./node_modules/@antv/l7-layers/es/line/models/linearline.js");
/* harmony import */ var _simpleLine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./simpleLine */ "./node_modules/@antv/l7-layers/es/line/models/simpleLine.js");
/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tile */ "./node_modules/@antv/l7-layers/es/line/models/tile.js");
/* harmony import */ var _wall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wall */ "./node_modules/@antv/l7-layers/es/line/models/wall.js");











var LineModels = {
  arc: _arc__WEBPACK_IMPORTED_MODULE_0__.default,
  arcmini: _arcmini__WEBPACK_IMPORTED_MODULE_1__.default,
  arc3d: _arc_3d__WEBPACK_IMPORTED_MODULE_2__.default,
  greatcircle: _great_circle__WEBPACK_IMPORTED_MODULE_3__.default,
  wall: _wall__WEBPACK_IMPORTED_MODULE_4__.default,
  line: _line__WEBPACK_IMPORTED_MODULE_5__.default,
  halfLine: _half__WEBPACK_IMPORTED_MODULE_6__.default,
  simple: _simpleLine__WEBPACK_IMPORTED_MODULE_7__.default,
  linearline: _linearline__WEBPACK_IMPORTED_MODULE_8__.default,
  vectorline: _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_9__.default,
  tileLine: _tile__WEBPACK_IMPORTED_MODULE_10__.default
};
/* harmony default export */ __webpack_exports__["default"] = (LineModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/line.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/line.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LineModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_dash_frag = "#define LineTypeSolid 0.0\nuniform float u_opacity : 1.0;\n\nvarying vec4 v_color;\n\n// dash\nvarying vec4 v_dash_array;\n\n#pragma include \"picking\"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // \u63A7\u5236\u8FD0\u52A8\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n // dash line\n \n  float flag = 0.;\n  float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n  if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n    flag = 1.;\n  }\n  gl_FragColor.a *=flag;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var line_dash_vert = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_DistanceAndIndex;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\n\nuniform float u_vertexScale: 1.0;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvarying vec4 v_color;\nvarying vec4 v_dash_array;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  vec2 offset = project_pixel(size.xy);\n\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = a_DistanceAndIndex.x / a_Total_Distance; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  styleMappingMat[3][1] = a_DistanceAndIndex.x;       // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, project_pixel(a_Size.y), 1.0));\n  } else {\n    float lineHeight = a_Size.y;\n \n    // #define COORDINATE_SYSTEM_P20 5.0\n    // #define COORDINATE_SYSTEM_P20_OFFSET 6.0\n    // amap1.x\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      lineHeight *= pow(2.0, 20.0 - u_Zoom);\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";
var line_frag = "#define Animate 0.0\n#define LineTexture 1.0\nuniform float u_blur : 0.99;\nuniform float u_opacity : 1.0;\nuniform float u_textureBlend;\n\nuniform float u_borderWidth: 0.0;\nuniform vec4 u_borderColor;\nvarying vec4 v_color;\n\n// line texture\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nvarying vec2 v_iconMapUV;\n\n#pragma include \"picking\"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // \u63A7\u5236\u8FD0\u52A8\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  gl_FragColor = v_color;\n  // anti-alias\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + animateSpeed);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = styleMappingMat[3].g;      // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n    float d_texPixelLen = styleMappingMat[3].b;  // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = styleMappingMat[3].a;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    // v = max(smoothstep(0.95, 1.0, v), v);\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    \n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, vec2(u, v)));\n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, uv));\n     vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor += pattern;\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = pattern;\n    }\n  } \n\n  float v = styleMappingMat[3].a;\n  float borderWidth = min(0.5, u_borderWidth);\n  // \u7ED8\u5236 border\n  if(borderWidth > 0.01) {\n    float borderOuterWidth = borderWidth/2.0;\n\n    if(v >= 1.0 - borderWidth || v <= borderWidth) {\n      if(v > borderWidth) {\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - borderWidth))/borderWidth);\n        gl_FragColor.rgb = mix(gl_FragColor.rgb, u_borderColor.rgb, linear);\n      } else if(v <= borderWidth) {\n        float linear = smoothstep(0.0, 1.0, v/borderWidth);\n        gl_FragColor.rgb = mix(u_borderColor.rgb, gl_FragColor.rgb, linear);\n      }\n    }\n\n    if(v < borderOuterWidth) {\n      gl_FragColor.a = mix(0.0, gl_FragColor.a, v/borderOuterWidth);\n    } else if(v > 1.0 - borderOuterWidth) {\n      gl_FragColor.a = mix(gl_FragColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\n    }\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var line_vert = "\n#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_DistanceAndIndex;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nuniform float u_icon_step: 100;\n\nuniform float u_heightfixed: 0.0;\nuniform float u_vertexScale: 1.0;\nuniform float u_raisingHeight: 0.0;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvarying vec4 v_color;\n\n// texV \u7EBF\u56FE\u5C42 - \u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\uFF08\u7EBF\u7684\u5BBD\u5EA6\u65B9\u5411\uFF09\nvarying vec2 v_iconMapUV;\n\n\nuniform float u_linearColor: 0;\nuniform float u_arrow: 0.0;\nuniform float u_arrowHeight: 3.0;\nuniform float u_arrowWidth: 2.0;\nuniform float u_tailWidth: 1.0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvec2 calculateArrow(vec2 offset) {\n  /*\n  * \u5728\u652F\u6301\u7BAD\u5934\u7684\u65F6\u5019\uFF0C\u7B2C\u4E8C\u3001\u7B2C\u4E09\u7EC4\u9876\u70B9\u662F\u989D\u5916\u63D2\u5165\u7528\u4E8E\u6784\u5EFA\u9876\u70B9\u7684\n  */\n  float arrowFlag = -1.0;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // \u9AD8\u5FB7 2.0 \u7684\u65CB\u8F6C\u89D2\u5EA6\u4E0D\u540C\n    arrowFlag = 1.0;\n  }\n  float pi = arrowFlag * 3.1415926/2.;\n  if(a_Miter < 0.) {\n    // \u6839\u636E\u7EBF\u7684\u4E24\u4FA7\u504F\u79FB\u4E0D\u540C\u3001\u65CB\u8F6C\u7684\u65B9\u5411\u76F8\u53CD\n    pi = -pi;\n  }\n  highp float angle_sin = sin(pi);\n  highp float angle_cos = cos(pi);\n  // \u8BA1\u7B97\u5782\u76F4\u4E0E\u7EBF\u65B9\u5411\u7684\u65CB\u8F6C\u77E9\u9635\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  float arrowWidth = u_arrowWidth;\n  float arrowHeight = u_arrowHeight;\n\n  vec2 arrowOffset = vec2(0.0);\n  /*\n  * a_DistanceAndIndex.y \u7528\u4E8E\u6807\u8BB0\u5F53\u524D\u9876\u70B9\u5C5E\u4E8E\u54EA\u4E00\u7EC4\uFF08\u4E24\u4E2A\u9876\u70B9\u4E00\u7EC4\uFF0C\u6784\u6210\u7EBF\u7684\u5176\u5B9E\u662F\u77E9\u5F62\uFF0C\u6700\u7B80\u9700\u8981\u56DB\u4E2A\u9876\u70B9\u3001\u4E24\u7EC4\u9876\u70B9\u6784\u6210\uFF09\n  */\n  if(a_DistanceAndIndex.y == 0.0) {\n    // \u7BAD\u5934\u5C16\u90E8\n    offset = vec2(0.0);\n  } else if(a_DistanceAndIndex.y == 1.0) {\n    // \u7BAD\u5934\u4E24\u4FA7\n    arrowOffset = rotation_matrix*(offset * arrowHeight);\n    offset += arrowOffset; // \u6CBF\u7EBF\u504F\u79FB\n    offset = offset * arrowWidth; // \u5782\u76F4\u7EBF\u5411\u5916\u504F\u79FB\uFF08\u662F\u6784\u5EFA\u7BAD\u5934\u4E24\u4FA7\u7684\u9876\u70B9\uFF09\n  } else if(a_DistanceAndIndex.y == 2.0 || a_DistanceAndIndex.y == 3.0 || a_DistanceAndIndex.y == 4.0) {\n    // \u504F\u79FB\u5176\u4F59\u7684\u70B9\u4F4D\uFF08\u5C06\u957F\u5EA6\u8BA9\u4F4D\u7ED9\u7BAD\u5934\uFF09\n    arrowOffset = rotation_matrix*(offset * arrowHeight) * arrowWidth;\n    offset += arrowOffset;// \u6CBF\u7EBF\u504F\u79FB\n  }\n\n  return offset;\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  float d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n\n  v_iconMapUV = a_iconMapUV;\n  d_texPixelLen = project_float_pixel(u_icon_step);\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    d_texPixelLen *= 10.0;\n  }\n\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  \n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n \n  if(u_arrow > 0.0) {\n      //  \u8BA1\u7B97\u7BAD\u5934\n    offset = calculateArrow(offset);\n\n    if(a_DistanceAndIndex.y > 4.0) {\n      offset *= mix(1.0, u_tailWidth, currentLinePointRatio);\n    }\n  }\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n  float texV = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = currentLinePointRatio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  styleMappingMat[3][1] = lineDistance;       // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n  styleMappingMat[3][2] = d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n  styleMappingMat[3][3] = texV;             // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // \u4FDD\u6301\u548C amap/mapbox \u4E00\u81F4\u7684\u6548\u679C\n    h *= 0.2;\n    if(u_heightfixed < 1.0) {\n      lineHeight = project_pixel(a_Size.y);\n    }\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight + h + u_raisingHeight, 1.0));\n  } else {\n    // mapbox -  amap\n    \n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // mapbox\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      h *= mapboxZoomScale;\n      h += u_raisingHeight * mapboxZoomScale;\n      if(u_heightfixed > 0.0) {\n        lineHeight *= mapboxZoomScale;\n      }\n      \n    } else {\n      // amap\n      h += u_raisingHeight;\n      // lineHeight \u9876\u70B9\u504F\u79FB\u9AD8\u5EA6\n      if(u_heightfixed < 1.0) {\n        lineHeight *= pow(2.0, 20.0 - u_Zoom);\n      }\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";
var linear_line_frag = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\nuniform float u_blur : 0.99;\nuniform float u_line_type: 0.0;\nuniform float u_opacity : 1.0;\n\nvarying vec4 v_color;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include \"picking\"\n\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};

var LineModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(LineModel, _BaseModel);

  var _super = _createSuper(LineModel);

  function LineModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LineModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$lineType = _ref.lineType,
          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
          _ref$dashArray = _ref.dashArray,
          dashArray = _ref$dashArray === void 0 ? [10, 5, 0, 0] : _ref$dashArray,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$vertexHeightScal = _ref.vertexHeightScale,
          vertexHeightScale = _ref$vertexHeightScal === void 0 ? 20.0 : _ref$vertexHeightScal,
          _ref$borderWidth = _ref.borderWidth,
          borderWidth = _ref$borderWidth === void 0 ? 0.0 : _ref$borderWidth,
          _ref$borderColor = _ref.borderColor,
          borderColor = _ref$borderColor === void 0 ? '#ccc' : _ref$borderColor,
          _ref$raisingHeight = _ref.raisingHeight,
          raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,
          _ref$heightfixed = _ref.heightfixed,
          heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
          _ref$arrow = _ref.arrow,
          arrow = _ref$arrow === void 0 ? {
        enable: false,
        arrowWidth: 2,
        arrowHeight: 3,
        tailWidth: 1
      } : _ref$arrow;

      if (dashArray.length === 2) {
        dashArray.push(0, 0);
      }

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        u_line_type: lineStyleObj[lineType],
        u_dash_array: dashArray,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_borderWidth: borderWidth,
        u_borderColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(borderColor),
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_heightfixed: Number(heightfixed),
        u_vertexScale: vertexHeightScale,
        u_raisingHeight: Number(raisingHeight),
        u_arrow: Number(arrow.enable),
        u_arrowHeight: arrow.arrowHeight || 3,
        u_arrowWidth: arrow.arrowWidth || 2,
        u_tailWidth: arrow.tailWidth === undefined ? 1 : arrow.tailWidth
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside,
          _ref3$depth = _ref3.depth,
          depth = _ref3$depth === void 0 ? false : _ref3$depth;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'line_' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        blend: this.getBlend(),
        depth: {
          enable: depth
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref4 = this.layer.getLayerConfig(),
          sourceColor = _ref4.sourceColor,
          targetColor = _ref4.targetColor,
          lineType = _ref4.lineType;

      if (lineType === 'dash') {
        return {
          frag: line_dash_frag,
          vert: line_dash_vert,
          type: 'dash'
        };
      }

      if (sourceColor && targetColor) {
        return {
          frag: linear_line_frag,
          vert: line_vert,
          type: 'linear'
        };
      } else {
        return {
          frag: line_frag,
          vert: line_vert,
          type: 'normal'
        };
      }
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'distanceAndIndex',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_DistanceAndIndex',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
            return vertexIndex === undefined ? [vertex[3], 10] : [vertex[3], vertexIndex];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref5 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref5.x,
                y = _ref5.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return LineModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=line.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/linearline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/linearline.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LinearLineModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var linear_line_frag = "uniform float u_opacity : 1.0;\nuniform sampler2D u_texture;\n\n#pragma include \"picking\"\n\nvarying mat4 styleMappingMat;\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  gl_FragColor = texture2D(u_texture, vec2(d_distance_ratio, 0.5));\n\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var linear_line_vert = "\nattribute float a_Miter;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_DistanceAndIndex;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_heightfixed: 0.0;\nuniform float u_vertexScale: 1.0;\nuniform float u_raisingHeight: 0.0;\n\nuniform float u_opacity: 1.0;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  \n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n \n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n  float texV = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = currentLinePointRatio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // \u4FDD\u6301\u548C amap/mapbox \u4E00\u81F4\u7684\u6548\u679C\n    h *= 0.2;\n    if(u_heightfixed < 1.0) {\n      lineHeight = project_pixel(a_Size.y);\n    }\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight + h + u_raisingHeight, 1.0));\n  } else {\n    // mapbox -  amap\n    \n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // mapbox\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      h *= mapboxZoomScale;\n      h += u_raisingHeight * mapboxZoomScale;\n      if(u_heightfixed > 0.0) {\n        lineHeight *= mapboxZoomScale;\n      }\n      \n    } else {\n      // amap\n      h += u_raisingHeight;\n      // lineHeight \u9876\u70B9\u504F\u79FB\u9AD8\u5EA6\n      if(u_heightfixed < 1.0) {\n        lineHeight *= pow(2.0, 20.0 - u_Zoom);\n      }\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";

var LinearLineModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(LinearLineModel, _BaseModel);

  var _super = _createSuper(LinearLineModel);

  function LinearLineModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LinearLineModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "colorTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.colorTexture) {
        _this.colorTexture.destroy();
      }

      var _ref = _this.layer.getLayerConfig(),
          rampColors = _ref.rampColors;

      var imageData = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.generateColorRamp)(rampColors);
      _this.colorTexture = createTexture2D({
        data: new Uint8Array(imageData.data),
        width: imageData.width,
        height: imageData.height,
        wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
        wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.CLAMP_TO_EDGE,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        flipY: false
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LinearLineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$opacity = _ref2.opacity,
          opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity,
          _ref2$vertexHeightSca = _ref2.vertexHeightScale,
          vertexHeightScale = _ref2$vertexHeightSca === void 0 ? 20.0 : _ref2$vertexHeightSca,
          _ref2$raisingHeight = _ref2.raisingHeight,
          raisingHeight = _ref2$raisingHeight === void 0 ? 0 : _ref2$raisingHeight,
          _ref2$heightfixed = _ref2.heightfixed,
          heightfixed = _ref2$heightfixed === void 0 ? false : _ref2$heightfixed;

      if (this.rendererService.getDirty()) {
        this.colorTexture.bind();
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_texture: this.colorTexture,
        u_heightfixed: Number(heightfixed),
        u_vertexScale: vertexHeightScale,
        u_raisingHeight: Number(raisingHeight)
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$colorTexture, _this$dataTexture;

      (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 ? void 0 : _this$colorTexture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside,
          _ref3$depth = _ref3.depth,
          depth = _ref3$depth === void 0 ? false : _ref3$depth;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'line_' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        blend: this.getBlend(),
        depth: {
          enable: depth
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: linear_line_frag,
        vert: linear_line_vert,
        type: 'linear_rampColors'
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'distanceAndIndex',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_DistanceAndIndex',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
            return vertexIndex === undefined ? [vertex[3], 10] : [vertex[3], vertexIndex];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
    }
  }]);

  return LinearLineModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=linearline.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/simpleLine.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/simpleLine.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ SimpleLineModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var simle_linear_frag = "uniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nvarying mat4 styleMappingMat;\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  gl_FragColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n}\n";
var simple_line_frag = "\nvarying vec4 v_color;\nvarying mat4 styleMappingMat;\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n\n  gl_FragColor = v_color;\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n}\n";
var simple_line_vert = "attribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Position;\n\nattribute float a_Total_Distance;\nattribute float a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_opacity: 1.0;\nuniform float u_vertexScale: 1.0;\n\n#pragma include \"projection\"\n\nvarying vec4 v_color;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  float d_distance_ratio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  v_color = a_Color;  \n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy, project_pixel(a_Size.y) + h * 0.2, 1.0));\n  } else {\n    float lineHeight = a_Size.y;\n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      h *= 2.0/pow(2.0, 20.0 - u_Zoom);\n    }\n\n    // #define COORDINATE_SYSTEM_P20 5.0\n    // #define COORDINATE_SYSTEM_P20_OFFSET 6.0\n    // amap1.x\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      lineHeight *= pow(2.0, 20.0 - u_Zoom);\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, lineHeight + h, 1.0));\n  }\n}\n";

var SimpleLineModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(SimpleLineModel, _BaseModel);

  var _super = _createSuper(SimpleLineModel);

  function SimpleLineModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, SimpleLineModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(SimpleLineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$vertexHeightScal = _ref.vertexHeightScale,
          vertexHeightScale = _ref$vertexHeightScal === void 0 ? 20.0 : _ref$vertexHeightScal;

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0,
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_vertexScale: vertexHeightScale
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref3 = this.layer.getLayerConfig(),
          sourceColor = _ref3.sourceColor,
          targetColor = _ref3.targetColor;

      if (sourceColor && targetColor) {
        return {
          frag: simle_linear_frag,
          vert: simple_line_vert,
          type: 'simple_linear'
        };
      } else {
        return {
          frag: simple_line_frag,
          vert: simple_line_vert,
          type: 'simple_normal'
        };
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$mask = _ref4.mask,
          mask = _ref4$mask === void 0 ? false : _ref4$mask,
          _ref4$maskInside = _ref4.maskInside,
          maskInside = _ref4$maskInside === void 0 ? true : _ref4$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.SimpleLineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LINES,
        blend: this.getBlend(),
        depth: {
          enable: false
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
    }
  }]);

  return SimpleLineModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=simpleLine.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/tile.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/tile.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LineModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_tile_frag = "#define LineTexture 1.0\nuniform float u_blur : 0.99;\nuniform float u_opacity : 1.0;\nuniform float u_textureBlend;\n\nuniform float u_borderWidth: 0.0;\nuniform vec4 u_borderColor;\nvarying vec4 v_color;\n\n// line texture\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nvarying vec2 v_iconMapUV;\n\n#pragma include \"picking\"\n\nvarying mat4 styleMappingMat;\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  gl_FragColor = v_color;\n  // anti-alias\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = styleMappingMat[3].g;      // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n    float d_texPixelLen = styleMappingMat[3].b;  // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen);\n    float v = styleMappingMat[3].a;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    // v = max(smoothstep(0.95, 1.0, v), v);\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    \n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, vec2(u, v)));\n    // gl_FragColor = filterColor(gl_FragColor + texture2D(u_texture, uv));\n     vec4 pattern = texture2D(u_texture, uv);\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor += pattern;\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = pattern;\n    }\n  } \n\n  float v = styleMappingMat[3].a;\n  float borderWidth = min(0.5, u_borderWidth);\n  // \u7ED8\u5236 border\n  if(borderWidth > 0.01) {\n    float borderOuterWidth = borderWidth/2.0;\n\n    if(v >= 1.0 - borderWidth || v <= borderWidth) {\n      if(v > borderWidth) {\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - borderWidth))/borderWidth);\n        gl_FragColor.rgb = mix(gl_FragColor.rgb, u_borderColor.rgb, linear);\n      } else if(v <= borderWidth) {\n        float linear = smoothstep(0.0, 1.0, v/borderWidth);\n        gl_FragColor.rgb = mix(u_borderColor.rgb, gl_FragColor.rgb, linear);\n      }\n    }\n\n    if(v < borderOuterWidth) {\n      gl_FragColor.a = mix(0.0, gl_FragColor.a, v/borderOuterWidth);\n    } else if(v > 1.0 - borderOuterWidth) {\n      gl_FragColor.a = mix(gl_FragColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\n    }\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var line_tile_vert = "\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\nattribute vec2 a_iconMapUV;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_DistanceAndIndex;\n\nuniform vec2 u_tileOrigin;\nuniform float u_coord;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_icon_step: 100;\n\nuniform float u_heightfixed: 0.0;\nuniform float u_vertexScale: 1.0;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvarying vec4 v_color;\n\n// texV \u7EBF\u56FE\u5C42 - \u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\uFF08\u7EBF\u7684\u5BBD\u5EA6\u65B9\u5411\uFF09\nvarying vec2 v_iconMapUV;\n\n\nuniform float u_linearColor: 0;\nuniform float u_arrow: 0.0;\nuniform float u_arrowHeight: 3.0;\nuniform float u_arrowWidth: 2.0;\nuniform float u_tailWidth: 1.0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\nvec2 calculateArrow(vec2 offset) {\n  /*\n  * \u5728\u652F\u6301\u7BAD\u5934\u7684\u65F6\u5019\uFF0C\u7B2C\u4E8C\u3001\u7B2C\u4E09\u7EC4\u9876\u70B9\u662F\u989D\u5916\u63D2\u5165\u7528\u4E8E\u6784\u5EFA\u9876\u70B9\u7684\n  */\n  float arrowFlag = -1.0;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    // \u9AD8\u5FB7 2.0 \u7684\u65CB\u8F6C\u89D2\u5EA6\u4E0D\u540C\n    arrowFlag = 1.0;\n  }\n  float pi = arrowFlag * 3.1415926/2.;\n  if(a_Miter < 0.) {\n    // \u6839\u636E\u7EBF\u7684\u4E24\u4FA7\u504F\u79FB\u4E0D\u540C\u3001\u65CB\u8F6C\u7684\u65B9\u5411\u76F8\u53CD\n    pi = -pi;\n  }\n  highp float angle_sin = sin(pi);\n  highp float angle_cos = cos(pi);\n  // \u8BA1\u7B97\u5782\u76F4\u4E0E\u7EBF\u65B9\u5411\u7684\u65CB\u8F6C\u77E9\u9635\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  float arrowWidth = u_arrowWidth;\n  float arrowHeight = u_arrowHeight;\n\n  vec2 arrowOffset = vec2(0.0);\n  /*\n  * a_DistanceAndIndex.y \u7528\u4E8E\u6807\u8BB0\u5F53\u524D\u9876\u70B9\u5C5E\u4E8E\u54EA\u4E00\u7EC4\uFF08\u4E24\u4E2A\u9876\u70B9\u4E00\u7EC4\uFF0C\u6784\u6210\u7EBF\u7684\u5176\u5B9E\u662F\u77E9\u5F62\uFF0C\u6700\u7B80\u9700\u8981\u56DB\u4E2A\u9876\u70B9\u3001\u4E24\u7EC4\u9876\u70B9\u6784\u6210\uFF09\n  */\n  if(a_DistanceAndIndex.y == 0.0) {\n    // \u7BAD\u5934\u5C16\u90E8\n    offset = vec2(0.0);\n  } else if(a_DistanceAndIndex.y == 1.0) {\n    // \u7BAD\u5934\u4E24\u4FA7\n    arrowOffset = rotation_matrix*(offset * arrowHeight);\n    offset += arrowOffset; // \u6CBF\u7EBF\u504F\u79FB\n    offset = offset * arrowWidth; // \u5782\u76F4\u7EBF\u5411\u5916\u504F\u79FB\uFF08\u662F\u6784\u5EFA\u7BAD\u5934\u4E24\u4FA7\u7684\u9876\u70B9\uFF09\n  } else if(a_DistanceAndIndex.y == 2.0 || a_DistanceAndIndex.y == 3.0 || a_DistanceAndIndex.y == 4.0) {\n    // \u504F\u79FB\u5176\u4F59\u7684\u70B9\u4F4D\uFF08\u5C06\u957F\u5EA6\u8BA9\u4F4D\u7ED9\u7BAD\u5934\uFF09\n    arrowOffset = rotation_matrix*(offset * arrowHeight) * arrowWidth;\n    offset += arrowOffset;// \u6CBF\u7EBF\u504F\u79FB\n  }\n\n  return offset;\n}\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  float d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n\n  v_iconMapUV = a_iconMapUV;\n  d_texPixelLen = project_float_pixel(u_icon_step);\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    d_texPixelLen *= 10.0;\n  }\n\n  v_color = a_Color;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  \n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n \n  if(u_arrow > 0.0) {\n      //  \u8BA1\u7B97\u7BAD\u5934\n    offset = calculateArrow(offset);\n\n    if(a_DistanceAndIndex.y > 4.0) {\n      offset *= mix(1.0, u_tailWidth, currentLinePointRatio);\n    }\n  }\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n  float texV = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = currentLinePointRatio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  styleMappingMat[3][1] = lineDistance;       // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n  styleMappingMat[3][2] = d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n  styleMappingMat[3][3] = texV;             // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\nif(u_coord > 0.0) {\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // \u4FDD\u6301\u548C amap/mapbox \u4E00\u81F4\u7684\u6548\u679C\n    h *= 0.2;\n    if(u_heightfixed < 1.0) {\n      lineHeight = project_pixel(a_Size.y);\n    }\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  } else {\n    // mapbox -  amap\n    \n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // mapbox\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      h *= mapboxZoomScale;\n      if(u_heightfixed > 0.0) {\n        lineHeight *= mapboxZoomScale;\n      }\n      \n    } else {\n      // amap\n      // lineHeight \u9876\u70B9\u504F\u79FB\u9AD8\u5EA6\n      if(u_heightfixed < 1.0) {\n        lineHeight *= pow(2.0, 20.0 - u_Zoom);\n      }\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  }\n} else {\n  vec2 pointPos = a_Position.xy;\n  vec4 tileWorld = vec4(project_mvt_offset_position(vec4(u_tileOrigin, 0.0, 1.0)).xyz, 1.0); // \u74E6\u7247\u8D77\u59CB\u70B9\u7684\u4E16\u754C\u5750\u6807\n\n  vec2 pointOffset =  pointPos *  pow(2.0, u_Zoom); // \u74E6\u7247\u5185\u7684\u70B9\u7684\u504F\u79FB\u5750\u6807\n  \n  tileWorld.xy += pointOffset;\n\n  tileWorld.xy += offset;\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // Needs to be divided with project_uCommonUnitsPerMeter\n    tileWorld.w *= u_PixelsPerMeter.z;\n  }\n\n  gl_Position = u_ViewProjectionMatrix * tileWorld + u_ViewportCenterProjection;\n}\n\n\n  setPickingColor(a_PickingColor);\n\n\n}\n";

var LineModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(LineModel, _BaseModel);

  var _super = _createSuper(LineModel);

  function LineModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LineModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$vertexHeightScal = _ref.vertexHeightScale,
          vertexHeightScale = _ref$vertexHeightScal === void 0 ? 20.0 : _ref$vertexHeightScal,
          _ref$borderWidth = _ref.borderWidth,
          borderWidth = _ref$borderWidth === void 0 ? 0.0 : _ref$borderWidth,
          _ref$borderColor = _ref.borderColor,
          borderColor = _ref$borderColor === void 0 ? '#ccc' : _ref$borderColor,
          _ref$heightfixed = _ref.heightfixed,
          heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
          _ref$arrow = _ref.arrow,
          arrow = _ref$arrow === void 0 ? {
        enable: false,
        arrowWidth: 2,
        arrowHeight: 3,
        tailWidth: 1
      } : _ref$arrow,
          _ref$coord = _ref.coord,
          coord = _ref$coord === void 0 ? 'lnglat' : _ref$coord,
          tileOrigin = _ref.tileOrigin;

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_tileOrigin: tileOrigin || [0, 0],
        u_coord: coord === 'lnglat' ? 1.0 : 0.0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: Number(opacity),
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_borderWidth: borderWidth,
        u_borderColor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.rgb2arr)(borderColor),
        u_heightfixed: Number(heightfixed),
        u_vertexScale: vertexHeightScale,
        u_arrow: Number(arrow.enable),
        u_arrowHeight: arrow.arrowHeight || 3,
        u_arrowWidth: arrow.arrowWidth || 2,
        u_tailWidth: arrow.tailWidth === undefined ? 1 : arrow.tailWidth
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? false : _ref2$depth;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_9__.LineTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_9__.LineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.TRIANGLES,
        blend: this.getBlend(),
        depth: {
          enable: depth
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: line_tile_frag,
        vert: line_tile_vert,
        type: 'line_tile'
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'distanceAndIndex',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_DistanceAndIndex',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
            return vertexIndex === undefined ? [vertex[3], 10] : [vertex[3], vertexIndex];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref3 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref3.x,
                y = _ref3.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return LineModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_10__.default);


//# sourceMappingURL=tile.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/line/models/wall.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/line/models/wall.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LineWallModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var line_frag = "#define Animate 0.0\n#define LineTexture 1.0\n\nuniform float u_opacity : 1.0;\nuniform float u_textureBlend;\nuniform float u_iconStepCount;\n\nvarying vec4 v_color;\n\n// line texture\nuniform float u_line_texture;\nuniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nvarying vec2 v_iconMapUV;\nvarying float v_blur;\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\n#pragma include \"picking\"\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ]; // \u63A7\u5236\u8FD0\u52A8\n\nvarying mat4 styleMappingMat;\n// [animate, duration, interval, trailLength],\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_distance_ratio = styleMappingMat[3].r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  float v = styleMappingMat[3].a;\n\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v);\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n  if(u_aimate.x == Animate) {\n      animateSpeed = u_time / u_aimate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + animateSpeed);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = styleMappingMat[3].g;      // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n    float d_texPixelLen = styleMappingMat[3].b;  // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = styleMappingMat[3].a;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    // \u8BA1\u7B97\u7EB9\u7406\u95F4\u9694 start\n    float flag = 0.0;\n    if(u > 1.0/u_iconStepCount) {\n      flag = 1.0;\n    }\n    u = fract(u*u_iconStepCount);\n    // \u8BA1\u7B97\u7EB9\u7406\u95F4\u9694 end\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture2D(u_texture, uv);\n\n    // Tip: \u5224\u65AD\u7EB9\u7406\u95F4\u9694\n    if(flag > 0.0) {\n      pattern = vec4(0.0);\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      gl_FragColor = filterColor(gl_FragColor + pattern);\n    } else { // replace\n        pattern.a *= opacity;\n        if(gl_FragColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        gl_FragColor = filterColor(pattern);\n    }\n  }\n  \n\n  // blur - AA\n  if(v < v_blur) {\n    gl_FragColor.a = mix(0.0, gl_FragColor.a, v/v_blur);\n  } else if(v > 1.0 - v_blur) {\n    gl_FragColor.a = mix(gl_FragColor.a, 0.0, (v - (1.0 - v_blur))/v_blur);\n  }\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var line_vert = "#define Animate 0.0\n\nattribute float a_Miter;\nattribute vec4 a_Color;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\nattribute vec2 a_iconMapUV;\n\nattribute float a_Total_Distance;\nattribute float a_Distance;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nuniform float u_icon_step: 100;\nuniform float u_heightfixed;\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvarying vec4 v_color;\nvarying float v_blur;\n\n// texV \u7EBF\u56FE\u5C42 - \u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\uFF08\u7EBF\u7684\u5BBD\u5EA6\u65B9\u5411\uFF09\nvarying vec2 v_iconMapUV;\n\nuniform float u_linearColor: 0;\n\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"light\"\n#pragma include \"styleMappingCalOpacity\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // distance_ratio/distance/pixelLen/texV\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  float d_distance_ratio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  float d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n\n  v_iconMapUV = a_iconMapUV;\n  if(u_heightfixed < 1.0) {     // \u9AD8\u5EA6\u968F zoom \u8C03\u6574\n    d_texPixelLen = project_pixel(u_icon_step);\n  } else {\n    d_texPixelLen = u_icon_step;\n  }\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n    d_texPixelLen *= 10.0;\n  }\n\n  if(u_aimate.x == Animate || u_linearColor == 1.0) {\n      d_distance_ratio = a_Distance / a_Total_Distance;\n  }\n\n  float miter = (a_Miter + 1.0)/2.0;\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n  styleMappingMat[3][0] = d_distance_ratio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  styleMappingMat[3][1] = a_Distance;       // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n  styleMappingMat[3][2] = d_texPixelLen;    // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n  styleMappingMat[3][3] = miter;          // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C 0 - 1\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  float originSize = a_Size.x;  // \u56FA\u5B9A\u9AD8\u5EA6\n  if(u_heightfixed < 1.0) {     // \u9AD8\u5EA6\u968F zoom \u8C03\u6574\n    originSize = project_float_pixel(a_Size.x);\n  }\n\n  float wallHeight = originSize * miter;\n  float lightWeight = calc_lighting(vec4(project_pos.xy, wallHeight, 1.0));\n\n  v_blur = min(project_float_pixel(2.0) / originSize, 0.05);\n\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n  // v_color = a_Color;\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xy, wallHeight, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, wallHeight, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";

var LineWallModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(LineWallModel, _BaseModel);

  var _super = _createSuper(LineWallModel);

  function LineWallModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LineWallModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });

        _this.layer.render();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LineWallModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$textureBlend = _ref.textureBlend,
          textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
          _ref$heightfixed = _ref.heightfixed,
          heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
          _ref$lineTexture = _ref.lineTexture,
          lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
          _ref$iconStep = _ref.iconStep,
          iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
          _ref$iconStepCount = _ref.iconStepCount,
          iconStepCount = _ref$iconStepCount === void 0 ? 1 : _ref$iconStepCount;

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_heightfixed: Number(heightfixed),
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        u_texture: this.texture,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        u_iconStepCount: iconStepCount,
        u_icon_step: iconStep,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return [this.layer.buildLayerModel({
        moduleName: 'linewall',
        vertexShader: line_vert,
        fragmentShader: line_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.LineTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        blend: this.getBlend(),
        depth: {
          enable: false
        }
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var texture = feature.texture;

            var _ref3 = iconMap[texture] || {
              x: 0,
              y: 0
            },
                x = _ref3.x,
                y = _ref3.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return LineWallModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=wall.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/mask/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/mask/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MaskLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models */ "./node_modules/@antv/l7-layers/es/mask/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var MaskLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(MaskLayer, _BaseLayer);

  var _super = _createSuper(MaskLayer);

  function MaskLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, MaskLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'MaskLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(MaskLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var shape = this.getModelType();
      this.layerModel = new _models__WEBPACK_IMPORTED_MODULE_7__.default[shape](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return 'fill';
    }
  }]);

  return MaskLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/mask/models/fill.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/mask/models/fill.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MaskModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var mask_frag = "uniform float u_opacity;\nvarying vec4 v_Color;\n\nvoid main() {\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= u_opacity;\n}\n";
var mask_vert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\n\n#pragma include \"projection\"\n\nvoid main() {\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n}\n\n";

var MaskModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(MaskModel, _BaseModel);

  var _super = _createSuper(MaskModel);

  function MaskModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, MaskModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(MaskModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 0 : _ref$opacity;

      return {
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 0.0
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return [this.layer.buildLayerModel({
        moduleName: 'mask',
        vertexShader: mask_vert,
        fragmentShader: mask_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.polygonTriangulation,
        blend: this.getBlend(),
        depth: {
          enable: false
        },
        stencil: {
          enable: true,
          mask: 0xff,
          func: {
            cmp: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.ALWAYS,
            ref: 1,
            mask: 0xff
          },
          opFront: {
            fail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.REPLACE,
            zfail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.REPLACE,
            zpass: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.REPLACE
          }
        }
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.layerService.clear();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      return '';
    }
  }]);

  return MaskModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=fill.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/mask/models/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/mask/models/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fill */ "./node_modules/@antv/l7-layers/es/mask/models/fill.js");

var MaskModels = {
  fill: _fill__WEBPACK_IMPORTED_MODULE_0__.default
};
/* harmony default export */ __webpack_exports__["default"] = (MaskModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/DataMappingPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/DataMappingPlugin.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ DataMappingPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_10__);








var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }






var DataMappingPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_9__.injectable)(), _dec2 = (0,inversify__WEBPACK_IMPORTED_MODULE_9__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IGlobalConfigService), _dec3 = (0,inversify__WEBPACK_IMPORTED_MODULE_9__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IMapService), _dec4 = (0,inversify__WEBPACK_IMPORTED_MODULE_9__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.TYPES.IFontService), _dec(_class = (_class2 = function () {
  function DataMappingPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, DataMappingPlugin);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "configService", _descriptor, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "mapService", _descriptor2, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "fontService", _descriptor3, this);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(DataMappingPlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var _this = this;

      var styleAttributeService = _ref.styleAttributeService;
      layer.hooks.init.tap('DataMappingPlugin', function () {
        _this.generateMaping(layer, {
          styleAttributeService: styleAttributeService
        });
      });
      layer.hooks.beforeRenderData.tap('DataMappingPlugin', function () {
        layer.dataState.dataMappingNeedUpdate = false;

        _this.generateMaping(layer, {
          styleAttributeService: styleAttributeService
        });

        return true;
      });
      layer.hooks.beforeRender.tap('DataMappingPlugin', function () {
        if (layer.layerModelNeedUpdate) {
          return;
        }

        var bottomColor = layer.getBottomColor();
        var attributes = styleAttributeService.getLayerStyleAttributes() || [];
        var filter = styleAttributeService.getLayerStyleAttribute('filter');
        var dataArray = layer.getSource().data.dataArray;
        var attributesToRemapping = attributes.filter(function (attribute) {
          return attribute.needRemapping;
        });
        var filterData = dataArray;

        if (filter !== null && filter !== void 0 && filter.needRemapping && filter !== null && filter !== void 0 && filter.scale) {
          filterData = dataArray.filter(function (record) {
            return _this.applyAttributeMapping(filter, record, bottomColor)[0];
          });
        }

        if (attributesToRemapping.length) {
          if (filter !== null && filter !== void 0 && filter.needRemapping) {
            layer.setEncodedData(_this.mapping(layer, attributes, filterData, undefined, bottomColor));
            filter.needRemapping = false;
          } else {
            layer.setEncodedData(_this.mapping(layer, attributesToRemapping, filterData, layer.getEncodedData(), bottomColor));
          }

          layer.emit('remapping', null);
        }
      });
    }
  }, {
    key: "generateMaping",
    value: function generateMaping(layer, _ref2) {
      var _this2 = this;

      var styleAttributeService = _ref2.styleAttributeService;
      var bottomColor = layer.getBottomColor();
      var attributes = styleAttributeService.getLayerStyleAttributes() || [];
      var filter = styleAttributeService.getLayerStyleAttribute('filter');
      var dataArray = layer.getSource().data.dataArray;
      var filterData = dataArray;

      if (filter !== null && filter !== void 0 && filter.scale) {
        filterData = dataArray.filter(function (record) {
          return _this2.applyAttributeMapping(filter, record, bottomColor)[0];
        });
      }

      layer.setEncodedData(this.mapping(layer, attributes, filterData, undefined, bottomColor));
      layer.emit('dataUpdate', null);
    }
  }, {
    key: "getArrowPoints",
    value: function getArrowPoints(p1, p2) {
      var dir = [p2[0] - p1[0], p2[1] - p1[1]];
      var normalizeDir = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(dir);
      var arrowPoint = [p1[0] + normalizeDir[0] * 0.0001, p1[1] + normalizeDir[1] * 0.0001];
      return arrowPoint;
    }
  }, {
    key: "mapping",
    value: function mapping(layer, attributes, data, predata, minimumColor) {
      var _this3 = this;

      var _ref3 = layer.getLayerConfig(),
          _ref3$arrow = _ref3.arrow,
          arrow = _ref3$arrow === void 0 ? {
        enable: false
      } : _ref3$arrow;

      var mappedData = data.map(function (record, i) {
        var preRecord = predata ? predata[i] : {};

        var encodeRecord = _objectSpread({
          id: record._id,
          coordinates: record.coordinates
        }, preRecord);

        attributes.filter(function (attribute) {
          return attribute.scale !== undefined;
        }).forEach(function (attribute) {
          var values = _this3.applyAttributeMapping(attribute, record, minimumColor);

          attribute.needRemapping = false;

          if (attribute.name === 'color') {
            values = values.map(function (c) {
              return (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.rgb2arr)(c);
            });
          }

          encodeRecord[attribute.name] = Array.isArray(values) && values.length === 1 ? values[0] : values;

          if (attribute.name === 'shape') {
            encodeRecord.shape = _this3.fontService.getIconFontKey(encodeRecord[attribute.name]);
          }
        });

        if (arrow.enable && (encodeRecord.shape === 'line' || encodeRecord.shape === 'halfLine')) {
          var coords = encodeRecord.coordinates;

          var arrowPoint = _this3.getArrowPoints(coords[0], coords[1]);

          encodeRecord.coordinates.splice(1, 0, arrowPoint, arrowPoint);
        }

        return encodeRecord;
      });
      this.adjustData2Amap2Coordinates(mappedData, layer);
      this.adjustData2SimpleCoordinates(mappedData);
      return mappedData;
    }
  }, {
    key: "adjustData2Amap2Coordinates",
    value: function adjustData2Amap2Coordinates(mappedData, layer) {
      var _this4 = this;

      if (mappedData.length > 0 && this.mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version["GAODE2.x"]) {
        var layerCenter = this.getLayerCenter(layer);

        if (typeof mappedData[0].coordinates[0] === 'number') {
          mappedData.filter(function (d) {
            return !d.originCoordinates;
          }).map(function (d) {
            d.version = _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version["GAODE2.x"];
            d.originCoordinates = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default()(d.coordinates);
            d.coordinates = _this4.mapService.lngLatToCoordByLayer(d.coordinates, layerCenter);
          });
        } else {
          mappedData.filter(function (d) {
            return !d.originCoordinates;
          }).map(function (d) {
            d.version = _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version["GAODE2.x"];
            d.originCoordinates = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default()(d.coordinates);
            d.coordinates = _this4.mapService.lngLatToCoordsByLayer(d.coordinates, layerCenter);
          });
        }
      }
    }
  }, {
    key: "getLayerCenter",
    value: function getLayerCenter(layer) {
      var source = layer.getSource();
      return source.center;
    }
  }, {
    key: "adjustData2SimpleCoordinates",
    value: function adjustData2SimpleCoordinates(mappedData) {
      var _this5 = this;

      if (mappedData.length > 0 && this.mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version.SIMPLE) {
        mappedData.map(function (d) {
          if (!d.simpleCoordinate) {
            d.coordinates = _this5.unProjectCoordinates(d.coordinates);
            d.simpleCoordinate = true;
          }
        });
      }
    }
  }, {
    key: "unProjectCoordinates",
    value: function unProjectCoordinates(coordinates) {
      var _this6 = this;

      if (typeof coordinates[0] === 'number') {
        return this.mapService.simpleMapCoord.unproject(coordinates);
      }

      if (coordinates[0] && coordinates[0][0] instanceof Array) {
        var coords = [];
        coordinates.map(function (coord) {
          var c1 = [];
          coord.map(function (co) {
            c1.push(_this6.mapService.simpleMapCoord.unproject(co));
          });
          coords.push(c1);
        });
        return coords;
      } else {
        var _coords = [];
        coordinates.map(function (coord) {
          _coords.push(_this6.mapService.simpleMapCoord.unproject(coord));
        });
        return _coords;
      }
    }
  }, {
    key: "applyAttributeMapping",
    value: function applyAttributeMapping(attribute, record, minimumColor) {
      var _attribute$scale;

      if (!attribute.scale) {
        return [];
      }

      var scalers = (attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers) || [];
      var params = [];
      scalers.forEach(function (_ref4) {
        var _attribute$scale2;

        var field = _ref4.field;

        if (record.hasOwnProperty(field) || ((_attribute$scale2 = attribute.scale) === null || _attribute$scale2 === void 0 ? void 0 : _attribute$scale2.type) === 'variable') {
          params.push(record[field]);
        }
      });
      var mappingResult = attribute.mapping ? attribute.mapping(params) : [];

      if (attribute.name === 'color' && !(0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.isColor)(mappingResult[0])) {
        return [minimumColor];
      }

      return mappingResult;
    }
  }]);

  return DataMappingPlugin;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "configService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "mapService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "fontService", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

//# sourceMappingURL=DataMappingPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/DataSourcePlugin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/DataSourcePlugin.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ DataSourcePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_6__);




var _dec, _class;





var DataSourcePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_5__.injectable)(), _dec(_class = function () {
  function DataSourcePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, DataSourcePlugin);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "mapService", void 0);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(DataSourcePlugin, [{
    key: "apply",
    value: function apply(layer) {
      var _this = this;

      this.mapService = layer.getContainer().get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.TYPES.IMapService);
      layer.hooks.init.tap('DataSourcePlugin', function () {
        var source = layer.getSource();

        if (!source) {
          var _ref = layer.sourceOption || {
            data: _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_DATA,
            options: _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PARSER
          },
              data = _ref.data,
              options = _ref.options;

          layer.setSource(new _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__.default(data, options));
        }

        _this.updateClusterData(layer);
      });
      layer.hooks.beforeRenderData.tap('DataSourcePlugin', function () {
        var neeUpdateCluster = _this.updateClusterData(layer);

        var dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;
        layer.dataState.dataSourceNeedUpdate = false;
        return neeUpdateCluster || dataSourceNeedUpdate;
      });
    }
  }, {
    key: "updateClusterData",
    value: function updateClusterData(layer) {
      var source = layer.getSource();
      var cluster = source.cluster;
      var _source$clusterOption = source.clusterOptions.zoom,
          zoom = _source$clusterOption === void 0 ? 0 : _source$clusterOption;
      var newZoom = this.mapService.getZoom() - 1;
      var dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;

      if (cluster && dataSourceNeedUpdate) {
        source.updateClusterData(Math.floor(newZoom));
      }

      if (cluster && Math.abs(layer.clusterZoom - newZoom) >= 1) {
        if (zoom !== Math.floor(newZoom)) {
          source.updateClusterData(Math.floor(newZoom));
        }

        layer.clusterZoom = newZoom;
        return true;
      }

      return false;
    }
  }]);

  return DataSourcePlugin;
}()) || _class);

//# sourceMappingURL=DataSourcePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/FeatureScalePlugin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/FeatureScalePlugin.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FeatureScalePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/uniq */ "./node_modules/lodash/uniq.js");
/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_uniq__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNil */ "./node_modules/lodash/isNil.js");
/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNil__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/build/d3-interpolate.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(d3_interpolate__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_14__);










var _scaleMap, _dec, _dec2, _class, _class2, _descriptor;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
var scaleMap = (_scaleMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.LINEAR, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleLinear), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.POWER, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scalePow), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.LOG, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleLog), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.IDENTITY, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleIdentity), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.SEQUENTIAL, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleSequential), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.TIME, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleTime), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTILE, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleQuantile), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTIZE, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleQuantize), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.THRESHOLD, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleThreshold), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleOrdinal), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(_scaleMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.DIVERGING, d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleDiverging), _scaleMap);
var FeatureScalePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_13__.injectable)(), _dec2 = (0,inversify__WEBPACK_IMPORTED_MODULE_13__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.TYPES.IGlobalConfigService), _dec(_class = (_class2 = function () {
  function FeatureScalePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, FeatureScalePlugin);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "configService", _descriptor, this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(this, "scaleCache", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__.default)(this, "scaleOptions", {});
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(FeatureScalePlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var _this = this;

      var styleAttributeService = _ref.styleAttributeService;
      layer.hooks.init.tap('FeatureScalePlugin', function () {
        _this.scaleOptions = layer.getScaleOptions();
        var attributes = styleAttributeService.getLayerStyleAttributes();
        var dataArray = layer.getSource().data.dataArray;

        if (dataArray.length === 0) {
          return;
        }

        _this.caculateScalesForAttributes(attributes || [], dataArray);
      });
      layer.hooks.beforeRenderData.tap('FeatureScalePlugin', function () {
        _this.scaleOptions = layer.getScaleOptions();
        var attributes = styleAttributeService.getLayerStyleAttributes();
        var dataArray = layer.getSource().data.dataArray;

        _this.caculateScalesForAttributes(attributes || [], dataArray);

        layer.layerModelNeedUpdate = true;
        return true;
      });
      layer.hooks.beforeRender.tap('FeatureScalePlugin', function () {
        if (layer.layerModelNeedUpdate) {
          return;
        }

        _this.scaleOptions = layer.getScaleOptions();
        var attributes = styleAttributeService.getLayerStyleAttributes();

        if (attributes) {
          var dataArray = layer.getSource().data.dataArray;

          if (dataArray.length === 0) {
            return;
          }

          var attributesToRescale = attributes.filter(function (attribute) {
            return attribute.needRescale;
          });

          if (attributesToRescale.length) {
            _this.caculateScalesForAttributes(attributesToRescale, dataArray);
          }
        }
      });
    }
  }, {
    key: "isNumber",
    value: function isNumber(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  }, {
    key: "caculateScalesForAttributes",
    value: function caculateScalesForAttributes(attributes, dataArray) {
      var _this2 = this;

      this.scaleCache = {};
      attributes.forEach(function (attribute) {
        if (attribute.scale) {
          var attributeScale = attribute.scale;
          var type = attribute.name;
          attributeScale.names = _this2.parseFields(attribute.scale.field || []);
          var scales = [];
          attributeScale.names.forEach(function (field) {
            var _attribute$scale;

            scales.push(_this2.createScale(field, attribute.name, (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.values, dataArray));
          });

          if (scales.some(function (scale) {
            return scale.type === _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.VARIABLE;
          })) {
            attributeScale.type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.VARIABLE;
            scales.forEach(function (scale) {
              var _scale$option;

              if (!attributeScale.callback && attributeScale.values !== 'text') {
                switch ((_scale$option = scale.option) === null || _scale$option === void 0 ? void 0 : _scale$option.type) {
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.LOG:
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.LINEAR:
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.POWER:
                    if (attributeScale.values && attributeScale.values.length > 2) {
                      var tick = scale.scale.ticks(attributeScale.values.length);
                      scale.scale.domain(tick);
                    }

                    attributeScale.values ? scale.scale.range(attributeScale.values) : scale.scale.range(scale.option.domain);
                    break;

                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTILE:
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTIZE:
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.THRESHOLD:
                    scale.scale.range(attributeScale.values);
                    break;

                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT:
                    attributeScale.values ? scale.scale.range(attributeScale.values) : scale.scale.range(scale.option.domain);
                    break;

                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.DIVERGING:
                  case _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.SEQUENTIAL:
                    scale.scale.interpolator(d3_interpolate__WEBPACK_IMPORTED_MODULE_11__.interpolateRgbBasis(attributeScale.values));
                    break;
                }
              }

              if (attributeScale.values === 'text') {
                var _scale$option2;

                scale.scale.range((_scale$option2 = scale.option) === null || _scale$option2 === void 0 ? void 0 : _scale$option2.domain);
              }
            });
          } else {
            attributeScale.type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.CONSTANT;
            attributeScale.defaultValues = scales.map(function (scale, index) {
              return scale.scale(attributeScale.names[index]);
            });
          }

          attributeScale.scalers = scales.map(function (scale) {
            return {
              field: scale.field,
              func: scale.scale,
              option: scale.option
            };
          });
          attribute.needRescale = false;
        }
      });
    }
  }, {
    key: "parseFields",
    value: function parseFields(field) {
      if (Array.isArray(field)) {
        return field;
      }

      if (lodash_isString__WEBPACK_IMPORTED_MODULE_7___default()(field)) {
        return field.split('*');
      }

      return [field];
    }
  }, {
    key: "createScale",
    value: function createScale(field, name, values, data) {
      var _this$scaleOptions$na, _find;

      var scaleOption = this.scaleOptions[name] && ((_this$scaleOptions$na = this.scaleOptions[name]) === null || _this$scaleOptions$na === void 0 ? void 0 : _this$scaleOptions$na.field) === field ? this.scaleOptions[name] : this.scaleOptions[field];
      var styleScale = {
        field: field,
        scale: undefined,
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.VARIABLE,
        option: scaleOption
      };

      if (!data || !data.length) {
        if (scaleOption && scaleOption.type) {
          styleScale.scale = this.createDefaultScale(scaleOption);
        } else {
          styleScale.scale = d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleOrdinal([field]);
          styleScale.type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.CONSTANT;
        }

        return styleScale;
      }

      var firstValue = (_find = data.find(function (d) {
        return !lodash_isNil__WEBPACK_IMPORTED_MODULE_8___default()(d[field]);
      })) === null || _find === void 0 ? void 0 : _find[field];

      if (this.isNumber(field) || lodash_isNil__WEBPACK_IMPORTED_MODULE_8___default()(firstValue) && !scaleOption) {
        styleScale.scale = d3_scale__WEBPACK_IMPORTED_MODULE_12__.scaleOrdinal([field]);
        styleScale.type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.StyleScaleType.CONSTANT;
      } else {
        var type = scaleOption && scaleOption.type || this.getDefaultType(firstValue);

        if (values === 'text') {
          type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT;
        }

        var cfg = this.createScaleConfig(type, field, scaleOption, data);
        styleScale.scale = this.createDefaultScale(cfg);
        styleScale.option = cfg;
      }

      return styleScale;
    }
  }, {
    key: "getDefaultType",
    value: function getDefaultType(firstValue) {
      var type = _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.LINEAR;

      if (typeof firstValue === 'string') {
        type = dateRegex.test(firstValue) ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.TIME : _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT;
      }

      return type;
    }
  }, {
    key: "createScaleConfig",
    value: function createScaleConfig(type, field, scaleOption, data) {
      var cfg = {
        type: type
      };
      var values = (data === null || data === void 0 ? void 0 : data.map(function (item) {
        return item[field];
      })) || [];

      if (scaleOption !== null && scaleOption !== void 0 && scaleOption.domain) {
        cfg.domain = scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.domain;
      } else if (type !== _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT && type !== _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTILE && type !== _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.DIVERGING) {
        cfg.domain = (0,d3_array__WEBPACK_IMPORTED_MODULE_10__.extent)(values);
      } else if (type === _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.CAT) {
        cfg.domain = lodash_uniq__WEBPACK_IMPORTED_MODULE_6___default()(values);
      } else if (type === _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.QUANTILE) {
        cfg.domain = values;
      } else if (type === _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.ScaleTypes.DIVERGING) {
        var minMax = (0,d3_array__WEBPACK_IMPORTED_MODULE_10__.extent)(values);
        var neutral = (scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.neutral) !== undefined ? scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.neutral : (minMax[0] + minMax[1]) / 2;
        cfg.domain = [minMax[0], neutral, minMax[1]];
      }

      return _objectSpread(_objectSpread({}, cfg), scaleOption);
    }
  }, {
    key: "createDefaultScale",
    value: function createDefaultScale(_ref2) {
      var type = _ref2.type,
          domain = _ref2.domain,
          unknown = _ref2.unknown,
          clamp = _ref2.clamp,
          nice = _ref2.nice;
      var scale = scaleMap[type]();

      if (domain && scale.domain) {
        scale.domain(domain);
      }

      if (unknown) {
        scale.unknown(unknown);
      }

      if (clamp !== undefined && scale.clamp) {
        scale.clamp(clamp);
      }

      if (nice !== undefined && scale.nice) {
        scale.nice(nice);
      }

      return scale;
    }
  }]);

  return FeatureScalePlugin;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_3__.default)(_class2.prototype, "configService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

//# sourceMappingURL=FeatureScalePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/LayerAnimateStylePlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/LayerAnimateStylePlugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LayerAnimateStylePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_8__);







var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var LayerAnimateStylePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_7__.injectable)(), _dec2 = (0,inversify__WEBPACK_IMPORTED_MODULE_7__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.ICameraService), _dec3 = (0,inversify__WEBPACK_IMPORTED_MODULE_7__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.IRendererService), _dec(_class = (_class2 = function () {
  function LayerAnimateStylePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, LayerAnimateStylePlugin);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "cameraService", _descriptor, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "rendererService", _descriptor2, this);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(LayerAnimateStylePlugin, [{
    key: "apply",
    value: function apply(layer) {
      layer.hooks.beforeRender.tap('LayerAnimateStylePlugin', function () {
        layer.models.forEach(function (model) {
          model.addUniforms(_objectSpread({}, layer.layerModel.getAnimateUniforms()));
        });
      });
    }
  }]);

  return LayerAnimateStylePlugin;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "cameraService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "rendererService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

//# sourceMappingURL=LayerAnimateStylePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/LayerModelPlugin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/LayerModelPlugin.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LayerModelPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_3__);



var _dec, _class;



var LayerModelPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_2__.injectable)(), _dec(_class = function () {
  function LayerModelPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LayerModelPlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LayerModelPlugin, [{
    key: "apply",
    value: function apply(layer) {
      layer.hooks.init.tap('LayerModelPlugin', function () {
        layer.prepareBuildModel();
        layer.buildModels();
        layer.styleNeedUpdate = false;
      });
      layer.hooks.beforeRenderData.tap('DataSourcePlugin', function () {
        layer.prepareBuildModel();
        layer.clearModels();
        layer.buildModels();
        layer.layerModelNeedUpdate = false;
        return false;
      });
    }
  }]);

  return LayerModelPlugin;
}()) || _class);

//# sourceMappingURL=LayerModelPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/LayerStylePlugin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/LayerStylePlugin.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ LayerStylePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_3__);



var _dec, _class;



var LayerStylePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_2__.injectable)(), _dec(_class = function () {
  function LayerStylePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LayerStylePlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LayerStylePlugin, [{
    key: "apply",
    value: function apply(layer) {
      layer.hooks.afterInit.tap('LayerStylePlugin', function () {
        layer.updateLayerConfig({});

        var _layer$getLayerConfig = layer.getLayerConfig(),
            autoFit = _layer$getLayerConfig.autoFit,
            fitBoundsOptions = _layer$getLayerConfig.fitBoundsOptions;

        if (autoFit) {
          setTimeout(function () {
            layer.fitBounds(fitBoundsOptions);
          }, 100);
        }
      });
    }
  }]);

  return LayerStylePlugin;
}()) || _class);

//# sourceMappingURL=LayerStylePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/LightingPlugin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/LightingPlugin.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateLightingUniforms": function() { return /* binding */ generateLightingUniforms; },
/* harmony export */   "default": function() { return /* binding */ LightingPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_5__);





var _dec, _class;

var _excluded = ["type"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var lightTypeUniformMap = {
  directional: {
    lights: 'u_DirectionalLights',
    num: 'u_NumOfDirectionalLights'
  },
  spot: {
    lights: 'u_SpotLights',
    num: 'u_NumOfSpotLights'
  }
};
var DEFAULT_LIGHT = {
  type: 'directional',
  direction: [1, 10.5, 12],
  ambient: [0.2, 0.2, 0.2],
  diffuse: [0.6, 0.6, 0.6],
  specular: [0.1, 0.1, 0.1]
};
var DEFAULT_DIRECTIONAL_LIGHT = {
  direction: [0, 0, 0],
  ambient: [0, 0, 0],
  diffuse: [0, 0, 0],
  specular: [0, 0, 0]
};
var DEFAULT_SPOT_LIGHT = {
  position: [0, 0, 0],
  direction: [0, 0, 0],
  ambient: [0, 0, 0],
  diffuse: [0, 0, 0],
  specular: [0, 0, 0],
  constant: 1,
  linear: 0,
  quadratic: 0,
  angle: 14,
  exponent: 40,
  blur: 5
};
var COLOR_ATTRIBUTES = ['ambient', 'diffuse', 'specular'];
function generateLightingUniforms(lights) {
  var lightsMap = {
    u_DirectionalLights: new Array(3).fill(_objectSpread({}, DEFAULT_DIRECTIONAL_LIGHT)),
    u_NumOfDirectionalLights: 0,
    u_SpotLights: new Array(3).fill(_objectSpread({}, DEFAULT_SPOT_LIGHT)),
    u_NumOfSpotLights: 0
  };

  if (!lights || !lights.length) {
    lights = [DEFAULT_LIGHT];
  }

  lights.forEach(function (_ref, i) {
    var _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'directional' : _ref$type,
        rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__.default)(_ref, _excluded);

    var lightsUniformName = lightTypeUniformMap[type].lights;
    var lightsNumUniformName = lightTypeUniformMap[type].num;
    var num = lightsMap[lightsNumUniformName];
    lightsMap[lightsUniformName][num] = _objectSpread(_objectSpread({}, lightsMap[lightsUniformName][num]), rest);
    lightsMap[lightsNumUniformName]++;
  });
  return lightsMap;
}
var LightingPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_4__.injectable)(), _dec(_class = function () {
  function LightingPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, LightingPlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(LightingPlugin, [{
    key: "apply",
    value: function apply(layer) {
      layer.hooks.beforeRender.tap('LightingPlugin', function () {
        var _layer$getLayerConfig = layer.getLayerConfig(),
            enableLighting = _layer$getLayerConfig.enableLighting;

        if (enableLighting) {
          layer.models.forEach(function (model) {
            return model.addUniforms(_objectSpread({}, generateLightingUniforms()));
          });
        }
      });
    }
  }]);

  return LightingPlugin;
}()) || _class);

//# sourceMappingURL=LightingPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/MultiPassRendererPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/MultiPassRendererPlugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MultiPassRendererPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _utils_multiPassRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/multiPassRender */ "./node_modules/@antv/l7-layers/es/utils/multiPassRender.js");







var _dec, _dec2, _class, _class2, _descriptor;





var MultiPassRendererPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_7__.injectable)(), _dec2 = (0,inversify__WEBPACK_IMPORTED_MODULE_7__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.IGlobalConfigService), _dec(_class = (_class2 = function () {
  function MultiPassRendererPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, MultiPassRendererPlugin);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "configService", _descriptor, this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "enabled", void 0);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(MultiPassRendererPlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var _this = this;

      var rendererService = _ref.rendererService,
          postProcessingPassFactory = _ref.postProcessingPassFactory,
          normalPassFactory = _ref.normalPassFactory;
      layer.hooks.init.tap('MultiPassRendererPlugin', function () {
        var _layer$getLayerConfig = layer.getLayerConfig(),
            enableMultiPassRenderer = _layer$getLayerConfig.enableMultiPassRenderer,
            _layer$getLayerConfig2 = _layer$getLayerConfig.passes,
            passes = _layer$getLayerConfig2 === void 0 ? [] : _layer$getLayerConfig2;

        _this.enabled = !!enableMultiPassRenderer && layer.getLayerConfig().enableMultiPassRenderer !== false;

        if (_this.enabled) {
          layer.multiPassRenderer = (0,_utils_multiPassRender__WEBPACK_IMPORTED_MODULE_9__.createMultiPassRenderer)(layer, passes, postProcessingPassFactory, normalPassFactory);
          layer.multiPassRenderer.setRenderFlag(true);
        }
      });
      layer.hooks.beforeRender.tap('MultiPassRendererPlugin', function () {
        if (_this.enabled) {
          var _rendererService$getV = rendererService.getViewportSize(),
              width = _rendererService$getV.width,
              height = _rendererService$getV.height;

          layer.multiPassRenderer.resize(width, height);
        }
      });
    }
  }]);

  return MultiPassRendererPlugin;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "configService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

//# sourceMappingURL=MultiPassRendererPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/PixelPickingPlugin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/PixelPickingPlugin.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PixelPickingPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_5__);



var _dec, _class;





var PickingStage = {
  NONE: 0.0,
  ENCODE: 1.0,
  HIGHLIGHT: 2.0
};
var PixelPickingPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_4__.injectable)(), _dec(_class = function () {
  function PixelPickingPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, PixelPickingPlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(PixelPickingPlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var rendererService = _ref.rendererService,
          styleAttributeService = _ref.styleAttributeService;
      layer.hooks.init.tap('PixelPickingPlugin', function () {
        var enablePicking = true;
        styleAttributeService.registerStyleAttribute({
          name: 'pickingColor',
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.AttributeType.Attribute,
          descriptor: {
            name: 'a_PickingColor',
            buffer: {
              data: [],
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.FLOAT
            },
            size: 3,
            update: function update(feature, featureIdx) {
              var id = feature.id;
              return enablePicking ? (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.encodePickingColor)(id) : [0, 0, 0];
            }
          }
        });
      });
      layer.hooks.beforePickingEncode.tap('PixelPickingPlugin', function () {
        var _layer$getLayerConfig = layer.getLayerConfig(),
            enablePicking = _layer$getLayerConfig.enablePicking;

        if (enablePicking && layer.isVisible()) {
          layer.models.forEach(function (model) {
            return model.addUniforms({
              u_PickingStage: PickingStage.ENCODE
            });
          });
        }
      });
      layer.hooks.afterPickingEncode.tap('PixelPickingPlugin', function () {
        var _layer$getLayerConfig2 = layer.getLayerConfig(),
            enablePicking = _layer$getLayerConfig2.enablePicking;

        if (enablePicking && layer.isVisible()) {
          layer.models.forEach(function (model) {
            return model.addUniforms({
              u_PickingStage: PickingStage.HIGHLIGHT
            });
          });
        }
      });
      layer.hooks.beforeHighlight.tap('PixelPickingPlugin', function (pickedColor) {
        var _layer$getLayerConfig3 = layer.getLayerConfig(),
            highlightColor = _layer$getLayerConfig3.highlightColor,
            _layer$getLayerConfig4 = _layer$getLayerConfig3.activeMix,
            activeMix = _layer$getLayerConfig4 === void 0 ? 0 : _layer$getLayerConfig4;

        var highlightColorInArray = typeof highlightColor === 'string' ? (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.rgb2arr)(highlightColor) : highlightColor || [1, 0, 0, 1];
        layer.updateLayerConfig({
          pickedFeatureID: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.decodePickingColor)(new Uint8Array(pickedColor))
        });
        layer.models.forEach(function (model) {
          return model.addUniforms({
            u_PickingStage: PickingStage.HIGHLIGHT,
            u_PickingColor: pickedColor,
            u_HighlightColor: highlightColorInArray.map(function (c) {
              return c * 255;
            }),
            u_activeMix: activeMix
          });
        });
      });
      layer.hooks.beforeSelect.tap('PixelPickingPlugin', function (pickedColor) {
        var _layer$getLayerConfig5 = layer.getLayerConfig(),
            selectColor = _layer$getLayerConfig5.selectColor,
            _layer$getLayerConfig6 = _layer$getLayerConfig5.selectMix,
            selectMix = _layer$getLayerConfig6 === void 0 ? 0 : _layer$getLayerConfig6;

        var highlightColorInArray = typeof selectColor === 'string' ? (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.rgb2arr)(selectColor) : selectColor || [1, 0, 0, 1];
        layer.updateLayerConfig({
          pickedFeatureID: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.decodePickingColor)(new Uint8Array(pickedColor))
        });
        layer.models.forEach(function (model) {
          return model.addUniforms({
            u_PickingStage: PickingStage.HIGHLIGHT,
            u_PickingColor: pickedColor,
            u_HighlightColor: highlightColorInArray.map(function (c) {
              return c * 255;
            }),
            u_activeMix: selectMix,
            u_CurrentSelectedId: pickedColor,
            u_SelectColor: highlightColorInArray.map(function (c) {
              return c * 255;
            }),
            u_EnableSelect: 1
          });
        });
      });
    }
  }]);

  return PixelPickingPlugin;
}()) || _class);

//# sourceMappingURL=PixelPickingPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/RegisterStyleAttributePlugin.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/RegisterStyleAttributePlugin.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RegisterStyleAttributePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_4__);



var _dec, _class;




var RegisterStyleAttributePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_3__.injectable)(), _dec(_class = function () {
  function RegisterStyleAttributePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RegisterStyleAttributePlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RegisterStyleAttributePlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var _this = this;

      var styleAttributeService = _ref.styleAttributeService;
      layer.hooks.init.tap('RegisterStyleAttributePlugin', function () {
        _this.registerBuiltinAttributes(styleAttributeService);
      });
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes(styleAttributeService) {
      styleAttributeService.registerStyleAttribute({
        name: 'position',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Position',
          buffer: {
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex) {
            return vertex.length === 2 ? [vertex[0], vertex[1], 0] : [vertex[0], vertex[1], vertex[2]];
          }
        }
      });
      styleAttributeService.registerStyleAttribute({
        name: 'filter',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.AttributeType.Attribute,
        descriptor: {
          name: 'filter',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx) {
            var filter = feature.filter;
            return filter ? [1] : [0];
          }
        }
      });
      styleAttributeService.registerStyleAttribute({
        name: 'color',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Color',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx) {
            var color = feature.color;
            return !color || !color.length ? [1, 1, 1, 1] : color;
          }
        }
      });
      styleAttributeService.registerStyleAttribute({
        name: 'vertexId',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.AttributeType.Attribute,
        descriptor: {
          name: 'a_vertexId',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_2__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [featureIdx];
          }
        }
      });
    }
  }]);

  return RegisterStyleAttributePlugin;
}()) || _class);

//# sourceMappingURL=RegisterStyleAttributePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/ShaderUniformPlugin.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/ShaderUniformPlugin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ShaderUniformPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/initializerDefineProperty */ "./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/applyDecoratedDescriptor */ "./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js");
/* harmony import */ var _babel_runtime_helpers_initializerWarningHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/initializerWarningHelper */ "./node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_9__);







var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;





var ShaderUniformPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_8__.injectable)(), _dec2 = (0,inversify__WEBPACK_IMPORTED_MODULE_8__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.ICameraService), _dec3 = (0,inversify__WEBPACK_IMPORTED_MODULE_8__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.ICoordinateSystemService), _dec4 = (0,inversify__WEBPACK_IMPORTED_MODULE_8__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.IRendererService), _dec5 = (0,inversify__WEBPACK_IMPORTED_MODULE_8__.inject)(_antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.TYPES.IMapService), _dec(_class = (_class2 = function () {
  function ShaderUniformPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, ShaderUniformPlugin);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "cameraService", _descriptor, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "coordinateSystemService", _descriptor2, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "rendererService", _descriptor3, this);

    (0,_babel_runtime_helpers_initializerDefineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(this, "mapService", _descriptor4, this);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(ShaderUniformPlugin, [{
    key: "apply",
    value: function apply(layer) {
      var _this = this;

      var version = this.mapService.version;
      var mvp = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      var sceneCenterMKT = [0, 0];
      layer.hooks.beforeRender.tap('ShaderUniformPlugin', function () {
        var offset = layer.getLayerConfig().tileOrigin;

        _this.coordinateSystemService.refresh(offset);

        if (version === 'GAODE2.x') {
          var layerCenter = _this.getLayerCenter(layer);

          _this.mapService.map.customCoords.setCenter(layerCenter);

          _this.mapService.setCustomCoordCenter(layerCenter);

          mvp = _this.mapService.map.customCoords.getMVPMatrix();
          sceneCenterMKT = _this.mapService.getCustomCoordCenter();
        }

        var _this$rendererService = _this.rendererService.getViewportSize(),
            width = _this$rendererService.width,
            height = _this$rendererService.height;

        layer.models.forEach(function (model) {
          var _model$addUniforms;

          model.addUniforms((_model$addUniforms = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.ProjectionMatrix, _this.cameraService.getProjectionMatrix()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.ViewMatrix, _this.cameraService.getViewMatrix()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.ViewProjectionMatrix, _this.cameraService.getViewProjectionMatrix()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.Zoom, _this.cameraService.getZoom()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.ZoomScale, _this.cameraService.getZoomScale()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.FocalDistance, _this.cameraService.getFocalDistance()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CameraUniform.CameraPosition, _this.cameraService.getCameraPosition()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.CoordinateSystem, _this.coordinateSystemService.getCoordinateSystem()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.ViewportCenter, _this.coordinateSystemService.getViewportCenter()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.ViewportCenterProjection, _this.coordinateSystemService.getViewportCenterProjection()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.PixelsPerDegree, _this.coordinateSystemService.getPixelsPerDegree()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.PixelsPerDegree2, _this.coordinateSystemService.getPixelsPerDegree2()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.PixelsPerMeter, _this.coordinateSystemService.getPixelsPerMeter()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.CoordinateUniform.Mvp, mvp), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_SceneCenterMKT", sceneCenterMKT), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_ViewportSize", [width, height]), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_ModelMatrix", _this.cameraService.getModelMatrix()), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_DevicePixelRatio", _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.$window.devicePixelRatio), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_PickingBuffer", layer.getLayerConfig().pickingBuffer || 0), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(_model$addUniforms, "u_shaderPick", Number(layer.getShaderPickStat())), _model$addUniforms));
        });
      });
    }
  }, {
    key: "getLayerCenter",
    value: function getLayerCenter(layer) {
      var source = layer.getSource();
      return source.center;
    }
  }]);

  return ShaderUniformPlugin;
}(), (_descriptor = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "cameraService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "coordinateSystemService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "rendererService", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = (0,_babel_runtime_helpers_applyDecoratedDescriptor__WEBPACK_IMPORTED_MODULE_4__.default)(_class2.prototype, "mapService", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);

//# sourceMappingURL=ShaderUniformPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/UpdateModelPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/UpdateModelPlugin.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ UpdateModelPlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_3__);



var _dec, _class;



var UpdateModelPlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_2__.injectable)(), _dec(_class = function () {
  function UpdateModelPlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, UpdateModelPlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(UpdateModelPlugin, [{
    key: "apply",
    value: function apply(layer) {
      layer.hooks.beforeRender.tap('UpdateModelPlugin', function () {
        if (layer.layerModel) {
          layer.layerModel.needUpdate();
        }
      });
    }
  }]);

  return UpdateModelPlugin;
}()) || _class);

//# sourceMappingURL=UpdateModelPlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/plugins/UpdateStyleAttributePlugin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/plugins/UpdateStyleAttributePlugin.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ UpdateStyleAttributePlugin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_3__);



var _dec, _class;



var UpdateStyleAttributePlugin = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_2__.injectable)(), _dec(_class = function () {
  function UpdateStyleAttributePlugin() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, UpdateStyleAttributePlugin);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(UpdateStyleAttributePlugin, [{
    key: "apply",
    value: function apply(layer, _ref) {
      var _this = this;

      var styleAttributeService = _ref.styleAttributeService;
      layer.hooks.init.tap('UpdateStyleAttributePlugin', function () {
        _this.initStyleAttribute(layer, {
          styleAttributeService: styleAttributeService
        });
      });
      layer.hooks.beforeRender.tap('UpdateStyleAttributePlugin', function () {
        if (layer.layerModelNeedUpdate) {
          return;
        }

        _this.updateStyleAtrribute(layer, {
          styleAttributeService: styleAttributeService
        });
      });
    }
  }, {
    key: "updateStyleAtrribute",
    value: function updateStyleAtrribute(layer, _ref2) {
      var styleAttributeService = _ref2.styleAttributeService;
      var attributes = styleAttributeService.getLayerStyleAttributes() || [];
      var filter = styleAttributeService.getLayerStyleAttribute('filter');
      var shape = styleAttributeService.getLayerStyleAttribute('shape');

      if (filter && filter.needRegenerateVertices) {
        layer.layerModelNeedUpdate = true;
        attributes.forEach(function (attr) {
          return attr.needRegenerateVertices = false;
        });
        return;
      }

      attributes.filter(function (attribute) {
        return attribute.needRegenerateVertices;
      }).forEach(function (attribute) {
        styleAttributeService.updateAttributeByFeatureRange(attribute.name, layer.getEncodedData(), attribute.featureRange.startIndex, attribute.featureRange.endIndex);
        attribute.needRegenerateVertices = false;
      });
    }
  }, {
    key: "initStyleAttribute",
    value: function initStyleAttribute(layer, _ref3) {
      var styleAttributeService = _ref3.styleAttributeService;
      var attributes = styleAttributeService.getLayerStyleAttributes() || [];
      attributes.filter(function (attribute) {
        return attribute.needRegenerateVertices;
      }).forEach(function (attribute) {
        styleAttributeService.updateAttributeByFeatureRange(attribute.name, layer.getEncodedData(), attribute.featureRange.startIndex, attribute.featureRange.endIndex);
        attribute.needRegenerateVertices = false;
      });
    }
  }]);

  return UpdateStyleAttributePlugin;
}()) || _class);

//# sourceMappingURL=UpdateStyleAttributePlugin.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PointLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/index */ "./node_modules/@antv/l7-layers/es/point/models/index.js");








function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PointLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(PointLayer, _BaseLayer);

  var _super = _createSuper(PointLayer);

  function PointLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, PointLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'PointLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(PointLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models_index__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getModelTypeWillEmptyData",
    value: function getModelTypeWillEmptyData() {
      if (this.shapeOption) {
        var _this$shapeOption = this.shapeOption,
            field = _this$shapeOption.field,
            values = _this$shapeOption.values;

        var _this$getLayerConfig = this.getLayerConfig(),
            shape2d = _this$getLayerConfig.shape2d,
            shape3d = _this$getLayerConfig.shape3d;

        var iconMap = this.iconService.getIconMap();

        if (field && (shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(field)) !== -1) {
          return 'fill';
        }

        if (values && values instanceof Array) {
          var _iterator = _createForOfIteratorHelper(values),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var v = _step.value;

              if (typeof v === 'string' && iconMap.hasOwnProperty(v)) {
                return 'image';
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }

      return 'normal';
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        fillImage: {},
        normal: {
          blend: 'additive'
        },
        radar: {},
        simplePoint: {},
        fill: {
          blend: 'normal'
        },
        extrude: {},
        image: {},
        icon: {},
        text: {
          blend: 'normal'
        },
        vectorpoint: {},
        tile: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var PointTypes = ['fillImage', 'fill', 'radar', 'image', 'normal', 'simplePoint', 'extrude', 'text', 'icon', 'vectorpoint', 'tile'];

      if (this.layerSource.parser.type === 'mvt') {
        return 'vectorpoint';
      }

      if (this.layerType && PointTypes.includes(this.layerType)) {
        return this.layerType;
      }

      var layerData = this.getEncodedData();

      var _this$getLayerConfig2 = this.getLayerConfig(),
          shape2d = _this$getLayerConfig2.shape2d,
          shape3d = _this$getLayerConfig2.shape3d;

      var iconMap = this.iconService.getIconMap();
      var item = layerData.find(function (fe) {
        return fe.hasOwnProperty('shape');
      });

      if (!item) {
        return this.getModelTypeWillEmptyData();
      } else {
        var shape = item.shape;

        if (shape === 'dot') {
          return 'normal';
        }

        if (shape === 'simple') {
          return 'simplePoint';
        }

        if (shape === 'radar') {
          return 'radar';
        }

        if (shape === 'fillImage') {
          return 'fillImage';
        }

        if ((shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(shape)) !== -1) {
          return 'fill';
        }

        if ((shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) !== -1) {
          return 'extrude';
        }

        if (iconMap.hasOwnProperty(shape)) {
          return 'image';
        }

        if (this.fontService.getGlyph(shape) !== '') {
          return 'icon';
        }

        return 'text';
      }
    }
  }]);

  return PointLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/extrude.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/extrude.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ExtrudeModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _earth_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../earth/utils */ "./node_modules/@antv/l7-layers/es/earth/utils.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/geo */ "./node_modules/@antv/l7-layers/es/utils/geo.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var pointExtrudeFrag = "varying vec4 v_color;\nuniform float u_opacity: 1.0;\n\nuniform float u_pickLight: 0.0;\n\n#pragma include \"picking\"\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nuniform float u_linearColor: 0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\n\nuniform float u_opacitylinear: 0.0;\nuniform float u_opacitylinear_dir: 1.0;\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float lightWeight = styleMappingMat[1][3];\n  float barLinearZ = styleMappingMat[2][3];\n\n  // \u8BBE\u7F6E\u5706\u67F1\u7684\u5E95\u8272\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    gl_FragColor = mix(u_sourceColor, u_targetColor, barLinearZ);\n    gl_FragColor.rgb *= lightWeight;\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     gl_FragColor = v_color;\n  }\n\n  // \u5E94\u7528\u900F\u660E\u5EA6\n  gl_FragColor.a *= opacity;\n\n  // \u5F00\u542F\u900F\u660E\u5EA6\u6E10\u53D8\n  if(u_opacitylinear > 0.0) {\n    gl_FragColor.a *= u_opacitylinear_dir > 0.0 ? (1.0 - barLinearZ): barLinearZ;\n  }\n\n  // picking\n  if(u_pickLight > 0.0) {\n    gl_FragColor = filterColorAlpha(gl_FragColor, lightWeight);\n  } else {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n";
var pointExtrudeVert = "precision highp float;\n\n#define pi 3.1415926535\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec3 a_Position;\nattribute vec3 a_Pos;\nattribute vec4 a_Color;\nattribute vec3 a_Size;\nattribute vec3 a_Normal;\n\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_globel;\nuniform float u_r;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform float u_lightEnable: 1;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nfloat getYRadian(float x, float z) {\n  if(x > 0.0 && z > 0.0) {\n    return atan(x/z);\n  } else if(x > 0.0 && z <= 0.0){\n    return atan(-z/x) + pi/2.0;\n  } else if(x <= 0.0 && z <= 0.0) {\n    return  pi + atan(x/z); //atan(x/z) + \n  } else {\n    return atan(z/-x) + pi*3.0/2.0;\n  }\n}\n\nfloat getXRadian(float y, float r) {\n  return atan(y/r);\n}\n\nvoid main() {\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA - lightWeight\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1] - linearZ(\u5782\u76F4\u65B9\u5411 0 - 1 \u7684\u503C)\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  vec3 size = a_Size * a_Position;\n\n  // a_Position.z \u662F\u5728\u6784\u5EFA\u7F51\u683C\u7684\u65F6\u5019\u4F20\u5165\u7684\u6807\u51C6\u503C 0 - 1\uFF0C\u5728\u63D2\u503C\u5668\u63D2\u503C\u53EF\u4EE5\u83B7\u53D6 0\uFF5E1 \u7EBF\u6027\u6E10\u53D8\u7684\u503C\n  styleMappingMat[2][3] =  a_Position.z;\n\n  vec3 offset = size; // \u63A7\u5236\u5706\u67F1\u4F53\u7684\u5927\u5C0F - \u4ECE\u6807\u51C6\u5355\u4F4D\u5706\u67F1\u4F53\u8FDB\u884C\u504F\u79FB\n  if(u_heightfixed < 1.0) { // \u5706\u67F1\u4F53\u4E0D\u56FA\u5B9A\u9AD8\u5EA6\n    \n    if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\n      // P20 \u5750\u6807\u7CFB\u4E0B\uFF0C\u4E3A\u4E86\u548C Web \u58A8\u5361\u6258\u5750\u6807\u7CFB\u7EDF\u4E00\uFF0Czoom \u9ED8\u8BA4\u51CF1\n      offset = offset * pow(2.0, (19.0 - u_Zoom));\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\n      // P20_2 \u5750\u6807\u7CFB\u4E0B\uFF0C\u4E3A\u4E86\u548C Web \u58A8\u5361\u6258\u5750\u6807\u7CFB\u7EDF\u4E00\uFF0Czoom \u9ED8\u8BA4\u51CF3\n      offset = offset * pow(2.0, (19.0 - 3.0 - u_Zoom));\n    }\n  } else {// \u5706\u67F1\u4F53\u56FA\u5B9A\u9AD8\u5EA6 \uFF08 \u5904\u7406 mapbox \uFF09\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      offset *= 4.0/pow(2.0, 21.0 - u_Zoom);\n    }\n  }\n\n\n  vec4 project_pos = project_position(vec4(a_Pos.xy, 0., 1.0));\n\n  // u_r \u63A7\u5236\u5706\u67F1\u7684\u751F\u957F\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\n\n  // \u5706\u67F1\u5149\u7167\u6548\u679C\n  float lightWeight = 1.0;\n  if(u_lightEnable > 0.0) { // \u53D6\u6D88\u4E09\u5143\u8868\u8FBE\u5F0F\uFF0C\u589E\u5F3A\u5065\u58EE\u6027\n    lightWeight = calc_lighting(pos);\n  }\n  styleMappingMat[1][3] = lightWeight;\n\n  v_color =vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  // gl_Position = project_common_position_to_clipspace(pos);\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * pos;\n  } else {\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  \n  if(u_globel > 0.0) {\n    // \u5728\u5730\u7403\u6A21\u5F0F\u4E0B\uFF0C\u5C06\u539F\u672C\u5782\u76F4\u4E8E xy \u5E73\u9762\u7684\u5706\u67F1\u8C03\u6574\u59FF\u6001\u5230\u9002\u5E94\u5706\u7684\u89D2\u5EA6\n    //\u65CB\u8F6C\u77E9\u9635mx\uFF0C\u521B\u5EFA\u7ED5x\u8F74\u65CB\u8F6C\u77E9\u9635\n    float r = sqrt(a_Pos.z*a_Pos.z + a_Pos.x*a_Pos.x);\n    float xRadian = getXRadian(a_Pos.y, r);\n    float xcos = cos(xRadian);//\u6C42\u89E3\u65CB\u8F6C\u89D2\u5EA6\u4F59\u5F26\u503C\n    float xsin = sin(xRadian);//\u6C42\u89E3\u65CB\u8F6C\u89D2\u5EA6\u6B63\u5F26\u503C\n    mat4 mx = mat4(\n      1,0,0,0,  \n      0,xcos,-xsin,0,  \n      0,xsin,xcos,0,  \n      0,0,0,1);\n\n    //\u65CB\u8F6C\u77E9\u9635my\uFF0C\u521B\u5EFA\u7ED5y\u8F74\u65CB\u8F6C\u77E9\u9635\n    float yRadian = getYRadian(a_Pos.x, a_Pos.z);\n    float ycos = cos(yRadian);//\u6C42\u89E3\u65CB\u8F6C\u89D2\u5EA6\u4F59\u5F26\u503C\n    float ysin = sin(yRadian);//\u6C42\u89E3\u65CB\u8F6C\u89D2\u5EA6\u6B63\u5F26\u503C\n    mat4 my = mat4(\n      ycos,0,-ysin,0,  \n      0,1,0,0,  \n      ysin,0,ycos,0,  \n      0,0,0,1);\n\n    gl_Position = u_ViewProjectionMatrix * vec4(( my * mx *  vec4(a_Position * a_Size, 1.0)).xyz + a_Pos, 1.0);\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";

var ExtrudeModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(ExtrudeModel, _BaseModel);

  var _super = _createSuper(ExtrudeModel);

  function ExtrudeModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ExtrudeModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "raiseCount", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "raiserepeat", 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ExtrudeModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$animateOption = _ref.animateOption,
          animateOption = _ref$animateOption === void 0 ? {
        enable: false,
        speed: 0.01,
        repeat: false
      } : _ref$animateOption,
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor,
          _ref$pickLight = _ref.pickLight,
          pickLight = _ref$pickLight === void 0 ? false : _ref$pickLight,
          _ref$heightfixed = _ref.heightfixed,
          heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
          _ref$opacityLinear = _ref.opacityLinear,
          opacityLinear = _ref$opacityLinear === void 0 ? {
        enable: false,
        dir: 'up'
      } : _ref$opacityLinear,
          _ref$lightEnable = _ref.lightEnable,
          lightEnable = _ref$lightEnable === void 0 ? true : _ref$lightEnable;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      var useLinearColor = 0;
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      if (this.raiseCount < 1 && this.raiserepeat > 0) {
        if (animateOption.enable) {
          var _animateOption$speed = animateOption.speed,
              speed = _animateOption$speed === void 0 ? 0.01 : _animateOption$speed,
              _animateOption$repeat = animateOption.repeat,
              repeat = _animateOption$repeat === void 0 ? false : _animateOption$repeat;
          this.raiseCount += speed;

          if (this.raiseCount >= 1) {
            if (this.raiserepeat > 1) {
              this.raiseCount = 0;
              this.raiserepeat--;
            } else {
              this.raiseCount = 1;
            }
          }
        }
      }

      return {
        u_pickLight: Number(pickLight),
        u_heightfixed: Number(heightfixed),
        u_r: animateOption.enable && this.raiserepeat > 0 ? this.raiseCount : 1.0,
        u_globel: this.mapService.version === 'GLOBEL' ? 1 : 0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_opacitylinear: Number(opacityLinear.enable),
        u_opacitylinear_dir: opacityLinear.dir === 'up' ? 1.0 : 0.0,
        u_lightEnable: Number(lightEnable)
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? true : _ref2$depth,
          _ref2$animateOption$r = _ref2.animateOption.repeat,
          repeat = _ref2$animateOption$r === void 0 ? 1 : _ref2$animateOption$r;

      this.raiserepeat = repeat;
      return [this.layer.buildLayerModel({
        moduleName: 'pointExtrude2',
        vertexShader: pointExtrudeVert,
        fragmentShader: pointExtrudeFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PointExtrudeTriangulation,
        blend: this.getBlend(),
        cull: {
          enable: true,
          face: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getCullFace)(this.mapService.version)
        },
        depth: {
          enable: depth
        }
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var isGlobel = this.mapService.version === 'GLOBEL';
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var size = feature.size;

            if (size) {
              var buffersize = [];

              if (Array.isArray(size)) {
                buffersize = size.length === 2 ? [size[0], size[0], size[1]] : size;
              }

              if (!Array.isArray(size)) {
                buffersize = [size, size, size];
              }

              return buffersize;
            } else {
              return [2, 2, 2];
            }
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'pos',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Pos',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx) {
            var coordinates = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_11__.calculateCentroid)(feature.coordinates);

            if (isGlobel) {
              return (0,_earth_utils__WEBPACK_IMPORTED_MODULE_12__.lglt2xyz)([coordinates[0], coordinates[1]]);
            } else {
              return [coordinates[0], coordinates[1], 0];
            }
          }
        }
      });
    }
  }]);

  return ExtrudeModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_13__.default);


//# sourceMappingURL=extrude.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/fill.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/fill.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FillModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");











function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var waveFillFrag = "\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  \n  outer_df = sdCircle(v_data.xy, 1.0);\n  inner_df = sdCircle(v_data.xy, r);\n\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n  float PI = 3.14159;\n  float N_RINGS = 3.0;\n  float FREQ = 1.0;\n\n gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n\n  float d = length(v_data.xy);\n  if(d > 0.5) {\n    discard;\n  }\n  float intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_aimate.z - u_aimate.y * u_time)), 0.0, 1.0);\n  \n  // TODO: \u6839\u636E\u53E0\u52A0\u6A21\u5F0F\u9009\u62E9\u6548\u679C\n  if(u_additive > 0.0) {\n    gl_FragColor *= intensity;\n    // TODO: \u4F18\u5316\u6C34\u6CE2\u70B9 blend additive \u6A21\u5F0F\u4E0B\u6709\u7684\u62FE\u53D6\u6548\u679C \n    gl_FragColor = filterColorAlpha(gl_FragColor, gl_FragColor.a);\n  } else {\n    gl_FragColor = vec4(gl_FragColor.xyz, gl_FragColor.a * intensity);\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n";
var pointFillFrag = "\nuniform float u_globel;\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n  float stroke_opacity = styleMappingMat[0][1];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 strokeColor = textrueStroke == vec4(0) ? v_color : textrueStroke;\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius + strokeWidth);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  if (shape == 0) {\n    outer_df = sdCircle(v_data.xy, 1.0);\n    inner_df = sdCircle(v_data.xy, r);\n  } else if (shape == 1) {\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n  } else if (shape == 2) {\n    outer_df = sdBox(v_data.xy, vec2(1.));\n    inner_df = sdBox(v_data.xy, vec2(r));\n  } else if (shape == 3) {\n    outer_df = sdPentagon(v_data.xy, 0.8);\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\n  } else if (shape == 4) {\n    outer_df = sdHexagon(v_data.xy, 0.8);\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\n  } else if (shape == 5) {\n    outer_df = sdOctogon(v_data.xy, 1.0);\n    inner_df = sdOctogon(v_data.xy, r);\n  } else if (shape == 6) {\n    outer_df = sdHexagram(v_data.xy, 0.52);\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\n  } else if (shape == 7) {\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\n    inner_df = sdRhombus(v_data.xy, vec2(r));\n  } else if (shape == 8) {\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n  }\n\n  if(u_globel > 0.0) {\n    // TODO: \u5730\u7403\u6A21\u5F0F\u4E0B\u907F\u514D\u591A\u4F59\u7247\u5143\u7ED8\u5236\uFF0C\u540C\u65F6\u4E5F\u80FD\u907F\u514D\u6709\u7528\u7247\u5143\u5728\u900F\u660E\u4E14\u91CD\u53E0\u7684\u60C5\u51B5\u4E0B\u65E0\u6CD5\u5199\u5165\n    // \u4ED8\u51FA\u7684\u4EE3\u4EF7\u662F\u8FB9\u7F18\u4F1A\u6709\u4E00\u4E9B\u952F\u9F7F\n    if(outer_df > antialiasblur + 0.018) discard;\n  }\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = strokeWidth < 0.01 ? 0.0 : smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n\n  if(strokeWidth < 0.01) {\n    gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n  } else {\n    gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), strokeColor * stroke_opacity, color_t);\n  }\n\n  if(u_additive > 0.0) {\n    gl_FragColor *= opacity_t;\n    gl_FragColor = filterColorAlpha(gl_FragColor, gl_FragColor.a);\n  } else {\n    gl_FragColor.a *= opacity_t;\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n";
var pointFillVert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform float u_globel;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_meter2coord;\nuniform float u_meteryScale;\nuniform float u_isMeter;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_opacity : 1;\nuniform float u_stroke_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\nuniform vec2 u_offsets;\n\nuniform float u_blur : 0.0;\nuniform float u_raisingHeight: 0.0;\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalStrokeOpacity\"\n#pragma include \"styleMappingCalStrokeWidth\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  /*\n  *  setPickingSize \u8BBE\u7F6E\u62FE\u53D6\u5927\u5C0F\n  *  u_meter2coord \u5728\u7B49\u9762\u79EF\u5927\u5C0F\u7684\u65F6\u5019\u8BBE\u7F6E\u5355\u4F4D\n  */\n  float newSize = setPickingSize(a_Size) * u_meter2coord;\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 strokeOpacityAndOffset = calStrokeOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = strokeOpacityAndOffset.r;\n  textureOffset = strokeOpacityAndOffset.g;\n\n  vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // TODO: billboard\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // \u4E0D\u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    offset = project_pixel(offset);\n  } else {\n    // \u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    if(newSize * pow(2.0, u_Zoom) < 48.0) {\n      antialiasblur = max(antialiasblur, -0.05);\n    } else if(newSize * pow(2.0, u_Zoom) < 128.0) {\n      antialiasblur = max(antialiasblur, -0.6/pow(u_Zoom, 2.0));\n    } else {\n      antialiasblur = max(antialiasblur, -0.8/pow(u_Zoom, 2.0));\n    }\n    \n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.x += offset.x / u_meteryScale;\n      aPosition.y += offset.y;\n      offset = vec2(0.0);\n    }\n  }\n\n  // TODP: /abs(extrude.x) \u662F\u4E3A\u4E86\u517C\u5BB9\u5730\u7403\u6A21\u5F0F\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  float raiseHeight = u_raisingHeight;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, raiseHeight, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, u_raisingHeight, 1.0));\n  }\n\n  if(u_globel > 0.0) {\n    gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1, 1.0);\n  }\n \n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";



var FillModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__.default)(FillModel, _BaseModel);

  var _super = _createSuper(FillModel);

  function FillModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, FillModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "meter2coord", 1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "meteryScale", 1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "isMeter", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__.default)(_this), "unit", 'l7size');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(FillModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? 'rgba(0,0,0,0)' : _ref$stroke,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets,
          blend = _ref.blend,
          _ref$blur = _ref.blur,
          blur = _ref$blur === void 0 ? 0 : _ref$blur,
          _ref$raisingHeight = _ref.raisingHeight,
          raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,
          _ref$unit = _ref.unit,
          unit = _ref$unit === void 0 ? 'l7size' : _ref$unit;

      this.updateUnit(unit);

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        strokeOpacity: strokeOpacity,
        strokeWidth: strokeWidth,
        stroke: stroke,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          strokeOpacity: strokeOpacity,
          strokeWidth: strokeWidth,
          stroke: stroke,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_raisingHeight: Number(raisingHeight),
        u_meter2coord: this.meter2coord,
        u_meteryScale: this.meteryScale,
        u_isMeter: Number(this.isMeter),
        u_blur: blur,
        u_additive: blend === 'additive' ? 1.0 : 0.0,
        u_globel: this.mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.GLOBEL ? 1 : 0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_9___default()(opacity) ? opacity : 1.0,
        u_stroke_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_9___default()(strokeOpacity) ? strokeOpacity : 1.0,
        u_stroke_width: lodash_isNumber__WEBPACK_IMPORTED_MODULE_9___default()(strokeWidth) ? strokeWidth : 1.0,
        u_stroke_color: this.getStrokeColor(stroke),
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$animateOption = _ref2.animateOption,
          animateOption = _ref2$animateOption === void 0 ? {
        enable: false
      } : _ref2$animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "getAttribute",
    value: function getAttribute() {
      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), _core_triangulation__WEBPACK_IMPORTED_MODULE_13__.PointFillTriangulation);
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateUnit('l7size');
      return this.buildModels();
    }
  }, {
    key: "calMeter2Coord",
    value: function calMeter2Coord() {
      var _this$layer$getSource = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.layer.getSource().extent, 4),
          minLng = _this$layer$getSource[0],
          minLat = _this$layer$getSource[1],
          maxLng = _this$layer$getSource[2],
          maxLat = _this$layer$getSource[3];

      var center = [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
      var version = this.mapService.version;
      var mapboxContext = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.$window === null || _antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.$window === void 0 ? void 0 : _antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.$window.mapboxgl;

      if (version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.MAPBOX && mapboxContext !== null && mapboxContext !== void 0 && mapboxContext.MercatorCoordinate) {
        var coord = mapboxContext.MercatorCoordinate.fromLngLat({
          lng: center[0],
          lat: center[1]
        }, 0);
        var offsetInMercatorCoordinateUnits = coord.meterInMercatorCoordinateUnits();
        var westCoord = new mapboxContext.MercatorCoordinate(coord.x - offsetInMercatorCoordinateUnits, coord.y, coord.z);
        var westLnglat = westCoord.toLngLat();
        var southCoord = new mapboxContext.MercatorCoordinate(coord.x, coord.y - offsetInMercatorCoordinateUnits, coord.z);
        var southLnglat = southCoord.toLngLat();
        this.meter2coord = center[0] - westLnglat.lng;
        this.meteryScale = (southLnglat.lat - center[1]) / this.meter2coord;
        return;
      }

      var m1 = this.mapService.meterToCoord(center, [minLng, minLat]);
      var m2 = this.mapService.meterToCoord(center, [maxLng === minLng ? maxLng + 0.1 : maxLng, maxLat === minLat ? minLat + 0.1 : maxLat]);
      this.meter2coord = (m1 + m2) / 2;

      if (!Boolean(this.meter2coord)) {
        this.meter2coord = 7.70681090738883;
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside,
          _ref3$animateOption = _ref3.animateOption,
          animateOption = _ref3$animateOption === void 0 ? {
        enable: false
      } : _ref3$animateOption;

      var _this$getShaders = this.getShaders(animateOption),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      var isGlobel = this.mapService.version === 'GLOBEL';
      this.layer.triangulation = isGlobel ? _core_triangulation__WEBPACK_IMPORTED_MODULE_13__.GlobelPointFillTriangulation : _core_triangulation__WEBPACK_IMPORTED_MODULE_13__.PointFillTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'pointfill_' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: isGlobel ? _core_triangulation__WEBPACK_IMPORTED_MODULE_13__.GlobelPointFillTriangulation : _core_triangulation__WEBPACK_IMPORTED_MODULE_13__.PointFillTriangulation,
        depth: {
          enable: isGlobel
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_11__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders(animateOption) {
      if (animateOption.enable) {
        switch (animateOption.type) {
          case 'wave':
            return {
              frag: waveFillFrag,
              vert: pointFillVert,
              type: 'wave'
            };

          default:
            return {
              frag: waveFillFrag,
              vert: pointFillVert,
              type: 'wave'
            };
        }
      } else {
        return {
          frag: pointFillFrag,
          vert: pointFillVert,
          type: 'normal'
        };
      }
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "animateOption2Array",
    value: function animateOption2Array(option) {
      return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      var isGlobel = this.mapService.version === 'GLOBEL';
      this.styleAttributeService.registerStyleAttribute({
        name: 'extrude',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Extrude',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var extrude;

            if (isGlobel) {
              var _vertex = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(vertex, 3),
                  x = _vertex[0],
                  y = _vertex[1],
                  z = _vertex[2];

              var n1 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(0, 0, 1);
              var n2 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(x, 0, z);
              var xzReg = x >= 0 ? gl_matrix__WEBPACK_IMPORTED_MODULE_14__.angle(n1, n2) : Math.PI * 2 - gl_matrix__WEBPACK_IMPORTED_MODULE_14__.angle(n1, n2);
              var yReg = Math.PI * 2 - Math.asin(y / 100);
              var m = gl_matrix__WEBPACK_IMPORTED_MODULE_15__.create();
              gl_matrix__WEBPACK_IMPORTED_MODULE_15__.rotateY(m, m, xzReg);
              gl_matrix__WEBPACK_IMPORTED_MODULE_15__.rotateX(m, m, yReg);
              var v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(1, 1, 0);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.transformMat4(v1, v1, m);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.normalize(v1, v1);
              var v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(-1, 1, 0);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.transformMat4(v2, v2, m);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.normalize(v2, v2);
              var v3 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(-1, -1, 0);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.transformMat4(v3, v3, m);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.normalize(v3, v3);
              var v4 = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.fromValues(1, -1, 0);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.transformMat4(v4, v4, m);
              gl_matrix__WEBPACK_IMPORTED_MODULE_14__.normalize(v4, v4);
              extrude = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(v1), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(v2), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(v3), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(v4));
            } else {
              extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
            }

            var extrudeIndex = attributeIdx % 4 * 3;
            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'shape',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Shape',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_10__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$shape = feature.shape,
                shape = _feature$shape === void 0 ? 2 : _feature$shape;

            var shape2d = _this2.layer.getLayerConfig().shape2d;

            var shapeIndex = shape2d.indexOf(shape);
            return [shapeIndex];
          }
        }
      });
    }
  }, {
    key: "updateUnit",
    value: function updateUnit(unit) {
      var version = this.mapService.version;

      if (this.unit !== unit) {
        if (this.unit !== 'meter' && unit === 'meter' && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.L7MAP && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.GLOBEL) {
          this.isMeter = true;
          this.calMeter2Coord();
        } else if (this.unit === 'meter' && unit !== 'meter') {
          this.isMeter = false;
          this.meter2coord = 1;
        }

        this.unit = unit;
      }
    }
  }]);

  return FillModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_16__.default);


//# sourceMappingURL=fill.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/fillmage.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/fillmage.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FillImageModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var pointFillFrag = "uniform sampler2D u_texture;\nuniform vec2 u_textSize;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\nvarying vec2 v_uv; // \u672C\u8EAB\u7684 uv \u5750\u6807\nvarying vec2 v_Iconuv;\n\nvoid main() {\n\n  float opacity = styleMappingMat[0][0];\n\n  vec2 pos = v_Iconuv / u_textSize + v_uv / u_textSize * 64.;\n  gl_FragColor = texture2D(u_texture, pos);\n  gl_FragColor.a *= opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var pointFillVert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute vec2 a_Uv;\nattribute float a_Rotate;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform mat2 u_RotateMatrix;\nuniform float u_isMeter;\n\nvarying vec2 v_uv; // \u672C\u8EAB\u7684 uv \u5750\u6807\nvarying vec2 v_Iconuv; // icon \u8D34\u56FE\u7684 uv \u5750\u6807\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n\n  v_uv = (a_Extrude.xy + 1.0)/2.0;\n  v_uv.y = 1.0 - v_uv.y;\n  v_Iconuv = a_Uv;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // empty - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  highp float angle_sin = sin(a_Rotate);\n  highp float angle_cos = cos(a_Rotate);\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n  // vec2 offset = (u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec2 offset = (rotation_matrix * u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // \u4E0D\u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    offset = project_pixel(offset);\n  } else {\n    // \u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n  }\n \n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";

var FillImageModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(FillImageModel, _BaseModel);

  var _super = _createSuper(FillImageModel);

  function FillImageModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, FillImageModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "meter2coord", 1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "isMeter", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "radian", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas(),
          mag: 'linear',
          min: 'linear mipmap nearest',
          mipmap: true
        });

        _this.layer.renderLayers();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128,
        mipmap: true
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(FillImageModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets,
          rotation = _ref.rotation;

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      var rotateFlag = 1;

      if (this.mapService.version === 'GAODE2.x' || this.mapService.version === 'GAODE1.x') {
        rotateFlag = -1;
      }

      this.radian = rotation !== undefined ? rotateFlag * Math.PI * rotation / 180 : rotateFlag * Math.PI * (this.mapService.getRotation() % 360) / 180;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_isMeter: Number(this.isMeter),
        u_RotateMatrix: new Float32Array([Math.cos(this.radian), Math.sin(this.radian), -Math.sin(this.radian), Math.cos(this.radian)]),
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_texture: this.texture,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "getAttribute",
    value: function getAttribute() {
      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.PointFillTriangulation);
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$unit = _ref2.unit,
          unit = _ref2$unit === void 0 ? 'l7size' : _ref2$unit;

      var version = this.mapService.version;

      if (unit === 'meter' && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.L7MAP && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.GLOBEL) {
        this.isMeter = true;
        this.calMeter2Coord();
      }

      return this.buildModels();
    }
  }, {
    key: "calMeter2Coord",
    value: function calMeter2Coord() {
      var _this$layer$getSource = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(this.layer.getSource().extent, 4),
          minLng = _this$layer$getSource[0],
          minLat = _this$layer$getSource[1],
          maxLng = _this$layer$getSource[2],
          maxLat = _this$layer$getSource[3];

      var center = [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
      var version = this.mapService.version;

      if (version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.MAPBOX && window.mapboxgl.MercatorCoordinate) {
        var coord = window.mapboxgl.MercatorCoordinate.fromLngLat({
          lng: center[0],
          lat: center[1]
        }, 0);
        var offsetInMeters = 1;
        var offsetInMercatorCoordinateUnits = offsetInMeters * coord.meterInMercatorCoordinateUnits();
        var westCoord = new window.mapboxgl.MercatorCoordinate(coord.x - offsetInMercatorCoordinateUnits, coord.y, coord.z);
        var westLnglat = westCoord.toLngLat();
        this.meter2coord = center[0] - westLnglat.lng;
        return;
      }

      var m1 = this.mapService.meterToCoord(center, [minLng, minLat]);
      var m2 = this.mapService.meterToCoord(center, [maxLng === minLng ? maxLng + 0.1 : maxLng, maxLat === minLat ? minLat + 0.1 : maxLat]);
      this.meter2coord = (m1 + m2) / 2;

      if (!Boolean(this.meter2coord)) {
        this.meter2coord = 7.70681090738883;
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.PointFillTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside),
        cull: {
          enable: true,
          face: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getCullFace)(this.mapService.version)
        }
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: pointFillFrag,
        vert: pointFillVert,
        type: 'point_fillImage'
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      this.iconService.off('imageUpdate', this.updateTexture);
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'rotate',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Rotate',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$rotate = feature.rotate,
                rotate = _feature$rotate === void 0 ? 0 : _feature$rotate;
            return Array.isArray(rotate) ? [rotate[0]] : [rotate];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var shape = feature.shape;

            var _ref4 = iconMap[shape] || {
              x: 0,
              y: 0
            },
                x = _ref4.x,
                y = _ref4.y;

            return [x, y];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'extrude',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Extrude',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
            var extrudeIndex = attributeIdx % 4 * 3;
            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0] * _this2.meter2coord] : [size * _this2.meter2coord];
          }
        }
      });
    }
  }]);

  return FillImageModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_13__.default);


//# sourceMappingURL=fillmage.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/icon-font.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/icon-font.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ IconeModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var pointImageFrag = "\nuniform sampler2D u_texture;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform vec2 u_textSize;\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main(){\n      float opacity = styleMappingMat[0][0];\n      float size = styleMappingMat[1][0];\n      vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n      vec4 textureColor;\n\n      // Y = 0.299R + 0.587G + 0.114B // \u4EAE\u5EA6\u63D0\u53D6\n     \n      textureColor = texture2D(u_texture, pos);\n\n      // Tip: \u53BB\u9664\u8FB9\u7F18\u90E8\u5206 mipmap \u5BFC\u81F4\u7684\u6DF7\u5408\u53D8\u6697\n      float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n      if(fragmengTocenter >= 0.5) {\n            float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n            textureColor.a *= luma;\n      }\n      \n      \n\n      if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n            gl_FragColor= textureColor;\n      }else {\n            gl_FragColor= step(0.01, textureColor.z) * v_color;\n      }\n\n      gl_FragColor.a = gl_FragColor.a * opacity;\n      gl_FragColor = filterColor(gl_FragColor);\n}\n";
var pointImageVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Uv;\nattribute float a_Size;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec2 u_offsets;\n\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  styleMappingMat[1][0] = a_Size;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n   v_color = a_Color;\n   v_uv = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  //  vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n\n  //  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n  }\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n\n  setPickingColor(a_PickingColor);\n}\n";

var IconeModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(IconeModel, _BaseModel);

  var _super = _createSuper(IconeModel);

  function IconeModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, IconeModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(IconeModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity;

      return {
        u_opacity: opacity || 1.0,
        u_texture: this.texture,
        u_textSize: [1024, this.iconService.canvasHeight || 128]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this2 = this;

      this.initIconFontGlyphs();
      this.registerBuiltinAttributes();
      this.updateTexture();
      this.iconService.on('imageUpdate', function () {
        _this2.updateTexture();

        _this2.layer.render();
      });
      return [this.layer.buildLayerModel({
        moduleName: 'pointiconImage',
        vertexShader: pointImageVert,
        fragmentShader: pointImageFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.PointImageTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.POINTS,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this3 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var size = feature.size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var mapping = _this3.fontService.mapping;
            var shape = feature.shape;

            var icon = _this3.fontService.getGlyph(shape);

            var _mapping$icon = mapping[icon],
                x = _mapping$icon.x,
                y = _mapping$icon.y;
            return [x, y];
          }
        }
      });
    }
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.texture = createTexture2D({
        data: canvas,
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LINEAR,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "initIconFontGlyphs",
    value: function initIconFontGlyphs() {
      var _this4 = this;

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$fontWeight = _ref2.fontWeight,
          fontWeight = _ref2$fontWeight === void 0 ? 'normal' : _ref2$fontWeight,
          _ref2$fontFamily = _ref2.fontFamily,
          fontFamily = _ref2$fontFamily === void 0 ? 'sans-serif' : _ref2$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();

        var icon = _this4.fontService.getGlyph(shape);

        if (characterSet.indexOf(icon) === -1) {
          characterSet.push(icon);
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        fontSize: 48
      });
    }
  }]);

  return IconeModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=icon-font.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/image.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/image.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ImageModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var pointImageFrag = "\nuniform sampler2D u_texture;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform vec2 u_textSize;\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main(){\n      float opacity = styleMappingMat[0][0];\n      float size = styleMappingMat[1][0];\n      vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n      vec4 textureColor;\n\n      // Y = 0.299R + 0.587G + 0.114B // \u4EAE\u5EA6\u63D0\u53D6\n     \n      textureColor = texture2D(u_texture, pos);\n\n      // Tip: \u53BB\u9664\u8FB9\u7F18\u90E8\u5206 mipmap \u5BFC\u81F4\u7684\u6DF7\u5408\u53D8\u6697\n      float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n      if(fragmengTocenter >= 0.5) {\n            float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n            textureColor.a *= luma;\n      }\n      \n      \n\n      if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n            gl_FragColor= textureColor;\n      }else {\n            gl_FragColor= step(0.01, textureColor.z) * v_color;\n      }\n\n      gl_FragColor.a = gl_FragColor.a * opacity;\n      gl_FragColor = filterColor(gl_FragColor);\n}\n";
var pointImageVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Uv;\nattribute float a_Size;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec2 u_offsets;\n\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  styleMappingMat[1][0] = a_Size;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n   v_color = a_Color;\n   v_uv = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  //  vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n\n  //  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n  }\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n\n  setPickingColor(a_PickingColor);\n}\n";

var ImageModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(ImageModel, _BaseModel);

  var _super = _createSuper(ImageModel);

  function ImageModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ImageModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas(),
          mag: 'linear',
          min: 'linear mipmap nearest',
          mipmap: true
        });

        _this.layer.renderLayers();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LINEAR,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128,
        mipmap: true
      });
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ImageModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets;

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_texture: this.texture,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.registerBuiltinAttributes();
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'pointImage',
        vertexShader: pointImageVert,
        fragmentShader: pointImageFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PointImageTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.POINTS,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var shape = feature.shape;

            var _ref3 = iconMap[shape] || {
              x: 0,
              y: 0
            },
                x = _ref3.x,
                y = _ref3.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return ImageModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=image.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tile/models/tileModel */ "./node_modules/@antv/l7-layers/es/tile/models/tileModel.js");
/* harmony import */ var _extrude__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extrude */ "./node_modules/@antv/l7-layers/es/point/models/extrude.js");
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fill */ "./node_modules/@antv/l7-layers/es/point/models/fill.js");
/* harmony import */ var _fillmage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillmage */ "./node_modules/@antv/l7-layers/es/point/models/fillmage.js");
/* harmony import */ var _icon_font__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./icon-font */ "./node_modules/@antv/l7-layers/es/point/models/icon-font.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./image */ "./node_modules/@antv/l7-layers/es/point/models/image.js");
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./normal */ "./node_modules/@antv/l7-layers/es/point/models/normal.js");
/* harmony import */ var _radar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radar */ "./node_modules/@antv/l7-layers/es/point/models/radar.js");
/* harmony import */ var _simplePoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simplePoint */ "./node_modules/@antv/l7-layers/es/point/models/simplePoint.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./text */ "./node_modules/@antv/l7-layers/es/point/models/text.js");
/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tile */ "./node_modules/@antv/l7-layers/es/point/models/tile.js");











var PointModels = {
  fillImage: _fillmage__WEBPACK_IMPORTED_MODULE_0__.default,
  fill: _fill__WEBPACK_IMPORTED_MODULE_1__.default,
  radar: _radar__WEBPACK_IMPORTED_MODULE_2__.default,
  image: _image__WEBPACK_IMPORTED_MODULE_3__.default,
  normal: _normal__WEBPACK_IMPORTED_MODULE_4__.default,
  simplePoint: _simplePoint__WEBPACK_IMPORTED_MODULE_5__.default,
  extrude: _extrude__WEBPACK_IMPORTED_MODULE_6__.default,
  text: _text__WEBPACK_IMPORTED_MODULE_7__.default,
  icon: _icon_font__WEBPACK_IMPORTED_MODULE_8__.default,
  vectorpoint: _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_9__.default,
  tile: _tile__WEBPACK_IMPORTED_MODULE_10__.default
};
/* harmony default export */ __webpack_exports__["default"] = (PointModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/normal.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/normal.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointTriangulation": function() { return /* binding */ PointTriangulation; },
/* harmony export */   "default": function() { return /* binding */ NormalModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var normalFrag = "\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nvarying vec4 v_color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n\n  gl_FragColor = v_color;\n  // gl_FragColor.a =gl_FragColor.a * u_opacity;\n  gl_FragColor.a =gl_FragColor.a * opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var normalVert = "\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute float a_Size;\nattribute vec4 a_Color;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"project\"\nvoid main() {\n  v_color = a_Color;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n  \n  // vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n  // vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n  // gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\\\n  // \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // vec2 offset = project_pixel((u_offsets));\n    gl_Position = u_Mvp * vec4(a_Position.xy + offset, a_Position.z, 1.0);\n  } else { // else\n    // vec2 offset = project_pixel(u_offsets);\n    vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n  }\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n";
function PointTriangulation(feature) {
  var coordinates = feature.coordinates;
  return {
    vertices: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

var NormalModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(NormalModel, _BaseModel);

  var _super = _createSuper(NormalModel);

  function NormalModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, NormalModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(NormalModel, [{
    key: "getDefaultStyle",
    value: function getDefaultStyle() {
      return {
        blend: 'additive'
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default()(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      this.layer.triangulation = PointTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'normalpoint',
        vertexShader: normalVert,
        fragmentShader: normalFrag,
        triangulation: PointTriangulation,
        depth: {
          enable: false
        },
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.POINTS,
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
    }
  }, {
    key: "defaultStyleOptions",
    value: function defaultStyleOptions() {
      return {
        blend: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.BlendType.additive
      };
    }
  }]);

  return NormalModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=normal.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/radar.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/radar.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RadarModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var pointFillFrag = "\nuniform float u_additive;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius);\n\n  float outer_df = sdCircle(v_data.xy, 1.0);\n  float inner_df = sdCircle(v_data.xy, r);\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n\n  if(u_additive > 0.0) {\n    gl_FragColor *= opacity_t;\n  } else {\n    gl_FragColor.a *= opacity_t;\n  }\n\n  if(gl_FragColor.a > 0.0) {\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n\n  vec2 extrude =  styleMappingMat[2].ba;\n  vec2 dir = normalize(extrude);\n  vec2 baseDir = vec2(1.0, 0.0);\n  float pi = 3.14159265359;\n  // full circle\n  // float rades = dot(dir, baseDir);\n  // float flag = sign(dir.y);\n  // float radar_v = (flag - 1.0) * -0.5 + flag * acos(rades)/pi/2.0;\n  \n  // half circle\n  float flag = sign(dir.y);\n  float rades = dot(dir, baseDir);\n  float radar_v = (flag - 1.0) * -0.5 * acos(rades)/pi;\n  // simple AA\n  if(radar_v > 0.99) {\n    radar_v = 1.0 - (radar_v - 0.99)/0.01;\n  }\n\n  gl_FragColor.a *= radar_v;\n}\n";
var pointFillVert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\nuniform float u_speed: 1.0;\nuniform float u_time;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_isMeter;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  float newSize = setPickingSize(a_Size);\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // empty - empty - empty - empty\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1] - a_Extrude.x - a_Extrude.y\n    0.0, 0.0, 0.0, 0.0  // \n  );\n\n  float time = u_time * u_speed;\n  mat2 rotateMatrix = mat2( \n    cos(time), sin(time), \n    -sin(time), cos(time)\n  );\n  styleMappingMat[2].ba = rotateMatrix * a_Extrude.xy;\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> empty -> empty ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // anti-alias\n  float blur = 0.0;\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, blur);\n\n  vec2 offset = (extrude.xy * (newSize) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // \u4E0D\u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    offset = project_pixel(offset);\n  } else {\n    // \u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    antialiasblur *= pow(19.0 - u_Zoom, 2.0);\n    antialiasblur = max(antialiasblur, -0.01);\n    // offset *= 0.5;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n  v_data = vec4(extrude.x, extrude.y, antialiasblur,shape_type);\n\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";


var RadarModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(RadarModel, _BaseModel);

  var _super = _createSuper(RadarModel);

  function RadarModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, RadarModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "meter2coord", 1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "isMeter", false);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(RadarModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets,
          blend = _ref.blend,
          _ref$speed = _ref.speed,
          speed = _ref$speed === void 0 ? 1 : _ref$speed;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_isMeter: Number(this.isMeter),
        u_speed: speed,
        u_additive: blend === 'additive' ? 1.0 : 0.0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$animateOption = _ref2.animateOption,
          animateOption = _ref2$animateOption === void 0 ? {
        enable: false
      } : _ref2$animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "getAttribute",
    value: function getAttribute() {
      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.PointFillTriangulation);
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$unit = _ref3.unit,
          unit = _ref3$unit === void 0 ? 'l7size' : _ref3$unit;

      var version = this.mapService.version;

      if (unit === 'meter' && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.L7MAP && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.GLOBEL) {
        this.isMeter = true;
        this.calMeter2Coord();
      }

      return this.buildModels();
    }
  }, {
    key: "calMeter2Coord",
    value: function calMeter2Coord() {
      var _this$layer$getSource = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(this.layer.getSource().extent, 4),
          minLng = _this$layer$getSource[0],
          minLat = _this$layer$getSource[1],
          maxLng = _this$layer$getSource[2],
          maxLat = _this$layer$getSource[3];

      var center = [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
      var version = this.mapService.version;

      if (version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_12__.Version.MAPBOX && window.mapboxgl.MercatorCoordinate) {
        var coord = window.mapboxgl.MercatorCoordinate.fromLngLat({
          lng: center[0],
          lat: center[1]
        }, 0);
        var offsetInMeters = 1;
        var offsetInMercatorCoordinateUnits = offsetInMeters * coord.meterInMercatorCoordinateUnits();
        var westCoord = new window.mapboxgl.MercatorCoordinate(coord.x - offsetInMercatorCoordinateUnits, coord.y, coord.z);
        var westLnglat = westCoord.toLngLat();
        this.meter2coord = center[0] - westLnglat.lng;
        return;
      }

      var m1 = this.mapService.meterToCoord(center, [minLng, minLat]);
      var m2 = this.mapService.meterToCoord(center, [maxLng === minLng ? maxLng + 0.1 : maxLng, maxLat === minLat ? minLat + 0.1 : maxLat]);
      this.meter2coord = (m1 + m2) / 2;

      if (!Boolean(this.meter2coord)) {
        this.meter2coord = 7.70681090738883;
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$mask = _ref4.mask,
          mask = _ref4$mask === void 0 ? false : _ref4$mask,
          _ref4$maskInside = _ref4.maskInside,
          maskInside = _ref4$maskInside === void 0 ? true : _ref4$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.PointFillTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: pointFillFrag,
        vert: pointFillVert,
        type: 'point_radar'
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "animateOption2Array",
    value: function animateOption2Array(option) {
      return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'extrude',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Extrude',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var extrude;
            extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
            var extrudeIndex = attributeIdx % 4 * 3;
            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0] * _this2.meter2coord] : [size * _this2.meter2coord];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'shape',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Shape',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$shape = feature.shape,
                shape = _feature$shape === void 0 ? 2 : _feature$shape;

            var shape2d = _this2.layer.getLayerConfig().shape2d;

            var shapeIndex = shape2d.indexOf(shape);
            return [shapeIndex];
          }
        }
      });
    }
  }]);

  return RadarModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_13__.default);


//# sourceMappingURL=radar.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/simplePoint.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/simplePoint.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointTriangulation": function() { return /* binding */ PointTriangulation; },
/* harmony export */   "default": function() { return /* binding */ SimplePointModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var simplePointFrag = "\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nuniform float u_additive;\n\nuniform float u_stroke_opacity : 1;\n\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\nvarying vec4 v_color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\nvarying float v_blur;\nvarying float v_innerRadius;\n\n#pragma include \"picking\"\nvoid main() {\n  vec2 center = vec2(0.5);\n\n  float opacity = styleMappingMat[0][0];\n  // Tip: \u7247\u5143\u5230\u4E2D\u5FC3\u70B9\u7684\u8DDD\u79BB 0 - 1\n  float fragmengTocenter = distance(center, gl_PointCoord) * 2.0;\n  // Tip: \u7247\u5143\u7684\u526A\u5207\u6210\u5706\u5F62\n  float circleClipOpacity = 1.0 - smoothstep(v_blur, 1.0, fragmengTocenter);\n\n\n  if(v_innerRadius < 0.99) {\n    // \u5F53\u5B58\u5728 stroke \u4E14 stroke > 0.01\n    float blurWidth = (1.0 - v_blur)/2.0;\n    vec4 stroke = vec4(u_stroke_color.rgb, u_stroke_opacity);\n    if(fragmengTocenter > v_innerRadius + blurWidth) {\n      gl_FragColor = stroke;\n    } else if(fragmengTocenter > v_innerRadius - blurWidth){\n      float mixR = (fragmengTocenter - (v_innerRadius - blurWidth)) / (blurWidth * 2.0);\n      gl_FragColor = mix(v_color, stroke, mixR);\n    } else {\n      gl_FragColor = v_color;\n    }\n  } else {\n    // \u5F53\u4E0D\u5B58\u5728 stroke \u6216 stroke <= 0.01\n    gl_FragColor = v_color;\n  }\n\n  gl_FragColor.a *= opacity;\n\n  gl_FragColor = filterColor(gl_FragColor);\n  \n  if(u_additive > 0.0) {\n    gl_FragColor *= circleClipOpacity;\n  } else {\n    gl_FragColor.a *= circleClipOpacity;\n  }\n\n}\n";
var simplePointVert = "\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute float a_Size;\nattribute vec4 a_Color;\nvarying vec4 v_color;\n\nuniform float u_opacity : 1;\nuniform vec2 u_offsets;\nuniform float u_stroke_width;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\nvarying float v_blur;\nvarying float v_innerRadius;\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"project\"\nvoid main() {\n  v_color = a_Color;\n  v_blur = 1.0 - max(2.0/a_Size, 0.05);\n  v_innerRadius = max((a_Size - u_stroke_width) / a_Size, 0.0);\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n  \n  vec2 offset = project_pixel(textrueOffsets);\n  \n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(a_Position.xy + offset, a_Position.z, 1.0);\n  } else { // else\n    vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\n    gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n  }\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n";
function PointTriangulation(feature) {
  var coordinates = feature.coordinates;
  return {
    vertices: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_5__.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

var SimplePointModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(SimplePointModel, _BaseModel);

  var _super = _createSuper(SimplePointModel);

  function SimplePointModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, SimplePointModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(SimplePointModel, [{
    key: "getDefaultStyle",
    value: function getDefaultStyle() {
      return {
        blend: 'additive'
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets,
          blend = _ref.blend,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_additive: blend === 'additive' ? 1.0 : 0.0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default()(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0],
        u_stroke_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default()(strokeOpacity) ? strokeOpacity : 1.0,
        u_stroke_width: lodash_isNumber__WEBPACK_IMPORTED_MODULE_6___default()(strokeWidth) ? strokeWidth : 1.0,
        u_stroke_color: this.getStrokeColor(stroke)
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      this.layer.triangulation = PointTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: 'simplepoint',
        vertexShader: simplePointVert,
        fragmentShader: simplePointFrag,
        triangulation: PointTriangulation,
        depth: {
          enable: false
        },
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.POINTS,
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
    }
  }, {
    key: "defaultStyleOptions",
    value: function defaultStyleOptions() {
      return {
        blend: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.BlendType.additive
      };
    }
  }]);

  return SimplePointModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=simplePoint.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/text.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/text.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextTriangulation": function() { return /* binding */ TextTriangulation; },
/* harmony export */   "default": function() { return /* binding */ TextModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _utils_collision_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utils/collision-index */ "./node_modules/@antv/l7-layers/es/utils/collision-index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utils/geo */ "./node_modules/@antv/l7-layers/es/utils/geo.js");
/* harmony import */ var _utils_symbol_layout__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/symbol-layout */ "./node_modules/@antv/l7-layers/es/utils/symbol-layout.js");










function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var textFrag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke_color : [0, 0, 0, 1];\nuniform float u_stroke_width : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\nvoid main() {\n  // get style data mapping\n  float opacity = styleMappingMat[0][0];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  // float fontScale = u_font_size / FONT_SIZE;\n\n  // lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  lowp float buff = (6.0 - strokeWidth / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  // gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke_color.rgb, u_stroke_color.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), vec4(textrueStroke.rgb, textrueStroke.a * opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var textVert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\nattribute float a_Rotate;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_raisingHeight: 0.0;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform float u_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalStrokeWidth\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n   styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n   vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n  \n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  highp float angle_sin = sin(a_Rotate);\n  highp float angle_cos = cos(a_Rotate);\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  \n  // gl_Position = vec4(projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n\n  float raiseHeight = u_raisingHeight;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  vec4 projected_position;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n   projected_position  = u_Mvp * (vec4(a_Position.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  } else { // else\n   projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  }\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";
function TextTriangulation(feature) {
  var that = this;
  var id = feature.id;
  var vertices = [];
  var indices = [];

  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      indices: [],
      size: 7
    };
  }

  var centroid = that.glyphInfoMap[id].centroid;
  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__.default)(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__.default)(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    indices: indices,
    size: 7
  };
}

var TextModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(TextModel, _BaseModel);

  var _super = _createSuper(TextModel);

  function TextModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, TextModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "glyphInfo", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "glyphInfoMap", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "currentZoom", -1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "extent", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "textureHeight", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "textCount", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "preTextStyle", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "buildModels", function () {
      var _ref = _this.layer.getLayerConfig(),
          _ref$mask = _ref.mask,
          mask = _ref$mask === void 0 ? false : _ref$mask,
          _ref$maskInside = _ref.maskInside,
          maskInside = _ref$maskInside === void 0 ? true : _ref$maskInside;

      _this.initGlyph();

      _this.updateTexture();

      _this.filterGlyphs();

      _this.reBuildModel();

      return [_this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this)),
        depth: {
          enable: false
        },
        blend: _this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    });

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$opacity = _ref2.opacity,
          opacity = _ref2$opacity === void 0 ? 1.0 : _ref2$opacity,
          _ref2$stroke = _ref2.stroke,
          stroke = _ref2$stroke === void 0 ? '#fff' : _ref2$stroke,
          _ref2$strokeWidth = _ref2.strokeWidth,
          strokeWidth = _ref2$strokeWidth === void 0 ? 0 : _ref2$strokeWidth,
          _ref2$textAnchor = _ref2.textAnchor,
          textAnchor = _ref2$textAnchor === void 0 ? 'center' : _ref2$textAnchor,
          _ref2$textAllowOverla = _ref2.textAllowOverlap,
          textAllowOverlap = _ref2$textAllowOverla === void 0 ? false : _ref2$textAllowOverla,
          _ref2$halo = _ref2.halo,
          halo = _ref2$halo === void 0 ? 0.5 : _ref2$halo,
          _ref2$gamma = _ref2.gamma,
          gamma = _ref2$gamma === void 0 ? 2.0 : _ref2$gamma,
          _ref2$raisingHeight = _ref2.raisingHeight,
          raisingHeight = _ref2$raisingHeight === void 0 ? 0 : _ref2$raisingHeight;

      var _this$fontService = this.fontService,
          canvas = _this$fontService.canvas,
          mapping = _this$fontService.mapping;

      if (Object.keys(mapping).length !== this.textCount) {
        this.updateTexture();
        this.textCount = Object.keys(mapping).length;
      }

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        strokeWidth: strokeWidth,
        stroke: stroke
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          strokeWidth: strokeWidth,
          stroke: stroke
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_raisingHeight: Number(raisingHeight),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0,
        u_stroke_width: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(strokeWidth) ? strokeWidth : 1.0,
        u_stroke_color: this.getStrokeColor(stroke),
        u_sdf_map: this.texture,
        u_halo_blur: halo,
        u_gamma_scale: gamma,
        u_sdf_map_size: [canvas.width, canvas.height]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.layer.on('remapping', this.buildModels);
      this.extent = this.textExtent();

      var _ref3 = this.layer.getLayerConfig(),
          _ref3$textAnchor = _ref3.textAnchor,
          textAnchor = _ref3$textAnchor === void 0 ? 'center' : _ref3$textAnchor,
          _ref3$textAllowOverla = _ref3.textAllowOverlap,
          textAllowOverlap = _ref3$textAllowOverla === void 0 ? true : _ref3$textAllowOverla;

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      return this.buildModels();
    }
  }, {
    key: "needUpdate",
    value: function needUpdate() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$textAllowOverla = _ref4.textAllowOverlap,
          textAllowOverlap = _ref4$textAllowOverla === void 0 ? false : _ref4$textAllowOverla;

      var zoom = this.mapService.getZoom();
      var extent = this.mapService.getBounds();
      var flag = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.boundsContains)(this.extent, extent);

      if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || !flag) || textAllowOverlap !== this.preTextStyle.textAllowOverlap) {
        this.reBuildModel();
        return true;
      }

      return false;
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.layer.off('remapping', this.buildModels);
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'rotate',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Rotate',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$rotate = feature.rotate,
                rotate = _feature$rotate === void 0 ? 0 : _feature$rotate;
            return Array.isArray(rotate) ? [rotate[0]] : [rotate];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 12 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      return (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.padBounds)(bounds, 0.5);
    }
  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _ref5 = this.layer.getLayerConfig(),
          _ref5$fontWeight = _ref5.fontWeight,
          fontWeight = _ref5$fontWeight === void 0 ? '400' : _ref5$fontWeight,
          _ref5$fontFamily = _ref5.fontFamily,
          fontFamily = _ref5$fontFamily === void 0 ? 'sans-serif' : _ref5$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();

        var _iterator = _createForOfIteratorHelper(shape),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;

            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        iconfont: false
      });
    }
  }, {
    key: "initIconFontTex",
    value: function initIconFontTex() {
      var _ref6 = this.layer.getLayerConfig(),
          _ref6$fontWeight = _ref6.fontWeight,
          fontWeight = _ref6$fontWeight === void 0 ? '400' : _ref6$fontWeight,
          _ref6$fontFamily = _ref6.fontFamily,
          fontFamily = _ref6$fontFamily === void 0 ? 'sans-serif' : _ref6$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape2 = item.shape,
            shape = _item$shape2 === void 0 ? '' : _item$shape2;
        shape = "".concat(shape);

        if (characterSet.indexOf(shape) === -1) {
          characterSet.push(shape);
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        iconfont: true
      });
    }
  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout(iconfont) {
      var _this2 = this;

      var mapping = this.fontService.mapping;

      var _ref7 = this.layer.getLayerConfig(),
          _ref7$spacing = _ref7.spacing,
          spacing = _ref7$spacing === void 0 ? 2 : _ref7$spacing,
          _ref7$textAnchor = _ref7.textAnchor,
          textAnchor = _ref7$textAnchor === void 0 ? 'center' : _ref7$textAnchor;

      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
            shape = _feature$shape === void 0 ? '' : _feature$shape,
            id = feature.id,
            _feature$size2 = feature.size,
            size = _feature$size2 === void 0 ? 1 : _feature$size2,
            _feature$textOffset = feature.textOffset,
            textOffset = _feature$textOffset === void 0 ? [0, 0] : _feature$textOffset;
        var shaping = (0,_utils_symbol_layout__WEBPACK_IMPORTED_MODULE_11__.shapeText)(shape.toString(), mapping, size, textAnchor, 'left', spacing, textOffset, iconfont);
        var glyphQuads = (0,_utils_symbol_layout__WEBPACK_IMPORTED_MODULE_11__.getGlyphQuads)(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        feature.centroid = (0,_utils_geo__WEBPACK_IMPORTED_MODULE_12__.calculateCentroid)(feature.coordinates);
        feature.originCentroid = feature.version === 'GAODE2.x' ? (0,_utils_geo__WEBPACK_IMPORTED_MODULE_12__.calculateCentroid)(feature.originCoordinates) : feature.originCentroid = feature.centroid;
        _this2.glyphInfoMap[id] = {
          shaping: shaping,
          glyphQuads: glyphQuads,
          centroid: (0,_utils_geo__WEBPACK_IMPORTED_MODULE_12__.calculateCentroid)(feature.coordinates)
        };
        return feature;
      });
    }
  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this3 = this;

      var _ref8 = this.layer.getLayerConfig(),
          _ref8$padding = _ref8.padding,
          padding = _ref8$padding === void 0 ? [4, 4] : _ref8$padding,
          _ref8$textAllowOverla = _ref8.textAllowOverlap,
          textAllowOverlap = _ref8$textAllowOverla === void 0 ? false : _ref8$textAllowOverla;

      if (textAllowOverlap) {
        return;
      }

      this.glyphInfoMap = {};
      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      var collisionIndex = new _utils_collision_index__WEBPACK_IMPORTED_MODULE_13__.default(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
            _feature$id = feature.id,
            id = _feature$id === void 0 ? 0 : _feature$id;
        var centroid = feature.version === 'GAODE2.x' ? feature.originCentroid : feature.centroid;
        var size = feature.size;
        var fontScale = size / 24;

        var pixels = _this3.mapService.lngLatToContainer(centroid);

        var _collisionIndex$place = collisionIndex.placeCollisionBox({
          x1: shaping.left * fontScale - padding[0],
          x2: shaping.right * fontScale + padding[0],
          y1: shaping.top * fontScale - padding[1],
          y2: shaping.bottom * fontScale + padding[1],
          anchorPointX: pixels.x,
          anchorPointY: pixels.y
        }),
            box = _collisionIndex$place.box;

        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      filterData.forEach(function (item) {
        _this3.glyphInfoMap[item.id] = item;
      });
    }
  }, {
    key: "initGlyph",
    value: function initGlyph() {
      var _this$layer$getLayerC = this.layer.getLayerConfig(),
          _this$layer$getLayerC2 = _this$layer$getLayerC.iconfont,
          iconfont = _this$layer$getLayerC2 === void 0 ? false : _this$layer$getLayerC2;

      iconfont ? this.initIconFontTex() : this.initTextFont();
      this.generateGlyphLayout(iconfont);
    }
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.textureHeight = canvas.height;

      if (this.texture) {
        this.texture.destroy();
      }

      this.texture = createTexture2D({
        data: canvas,
        mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
        min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "reBuildModel",
    value: function reBuildModel() {
      var _ref9 = this.layer.getLayerConfig(),
          _ref9$mask = _ref9.mask,
          mask = _ref9$mask === void 0 ? false : _ref9$mask,
          _ref9$maskInside = _ref9.maskInside,
          maskInside = _ref9$maskInside === void 0 ? true : _ref9$maskInside;

      this.filterGlyphs();
      this.layer.models = [this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind(this),
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    }
  }]);

  return TextModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_14__.default);


//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/point/models/tile.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/point/models/tile.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FillModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var point_tile_frag = "uniform float u_additive;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  float opacity = styleMappingMat[0][0];\n  float stroke_opacity = styleMappingMat[0][1];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 strokeColor = textrueStroke == vec4(0) ? v_color : textrueStroke;\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius + strokeWidth);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  if (shape == 0) {\n    outer_df = sdCircle(v_data.xy, 1.0);\n    inner_df = sdCircle(v_data.xy, r);\n  } else if (shape == 1) {\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n  } else if (shape == 2) {\n    outer_df = sdBox(v_data.xy, vec2(1.));\n    inner_df = sdBox(v_data.xy, vec2(r));\n  } else if (shape == 3) {\n    outer_df = sdPentagon(v_data.xy, 0.8);\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\n  } else if (shape == 4) {\n    outer_df = sdHexagon(v_data.xy, 0.8);\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\n  } else if (shape == 5) {\n    outer_df = sdOctogon(v_data.xy, 1.0);\n    inner_df = sdOctogon(v_data.xy, r);\n  } else if (shape == 6) {\n    outer_df = sdHexagram(v_data.xy, 0.52);\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\n  } else if (shape == 7) {\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\n    inner_df = sdRhombus(v_data.xy, vec2(r));\n  } else if (shape == 8) {\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n  }\n\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = strokeWidth < 0.01 ? 0.0 : smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n\n  if(strokeWidth < 0.01) {\n    gl_FragColor = vec4(v_color.rgb, v_color.a * opacity);\n  } else {\n    gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), strokeColor * stroke_opacity, color_t);\n  }\n\n  if(u_additive > 0.0) {\n    gl_FragColor *= opacity_t;\n    gl_FragColor = filterColorAlpha(gl_FragColor, gl_FragColor.a);\n  } else {\n    gl_FragColor.a *= opacity_t;\n    gl_FragColor = filterColor(gl_FragColor);\n  }\n}\n";
var point_tile_vert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_isMeter;\n\nuniform vec2 u_tileOrigin;\nuniform float u_coord;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_opacity : 1;\nuniform float u_stroke_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\nuniform vec2 u_offsets;\n\nuniform float u_blur : 0.0;\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalStrokeOpacity\"\n#pragma include \"styleMappingCalStrokeWidth\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  float newSize = setPickingSize(a_Size);\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  vec2 strokeOpacityAndOffset = calStrokeOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][1] = strokeOpacityAndOffset.r;\n  textureOffset = strokeOpacityAndOffset.g;\n\n  vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping\n\n  v_color = a_Color;\n  v_radius = newSize;\n\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, u_blur);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + textrueOffsets);\n  vec3 aPosition = a_Position;\n  if(u_isMeter < 1.0) {\n    // \u4E0D\u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    offset = project_pixel(offset);\n  } else {\n    // \u4EE5\u7C73\u4E3A\u5B9E\u9645\u5355\u4F4D\n    antialiasblur *= pow(19.0 - u_Zoom, 2.0);\n    antialiasblur = max(antialiasblur, -0.01);\n    // offset *= 0.5;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      aPosition.xy += offset;\n      offset.x = 0.0;\n      offset.y = 0.0;\n    }\n  }\n\n  v_data = vec4(extrude.x, extrude.y, antialiasblur,shape_type);\n\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n  }\n\nif(u_coord > 0.0) {\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n  }\n} else {\n  gl_PointSize = 24.0;\n  vec2 pointPos = a_Position.xy;\n  vec4 world = vec4(project_mvt_offset_position(vec4(u_tileOrigin, 0.0, 1.0)).xyz, 1.0); // \u74E6\u7247\u8D77\u59CB\u70B9\u7684\u4E16\u754C\u5750\u6807\n\n  vec2 pointOffset =  pointPos *  pow(2.0, u_Zoom); // \u74E6\u7247\u5185\u7684\u70B9\u7684\u504F\u79FB\u5750\u6807\n  \n  world.xy += offset;\n  world.xy += pointOffset;\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    // Needs to be divided with project_uCommonUnitsPerMeter\n    world.w *= u_PixelsPerMeter.z;\n  }\n\n  gl_Position = u_ViewProjectionMatrix * world + u_ViewportCenterProjection;\n}\n\n \n  setPickingColor(a_PickingColor);\n\n\n}\n";


var FillModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(FillModel, _BaseModel);

  var _super = _createSuper(FillModel);

  function FillModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, FillModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "meter2coord", 1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "isMeter", false);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(FillModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? 'rgba(0,0,0,0)' : _ref$stroke,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets,
          blend = _ref.blend,
          _ref$blur = _ref.blur,
          blur = _ref$blur === void 0 ? 0 : _ref$blur,
          _ref$coord = _ref.coord,
          coord = _ref$coord === void 0 ? 'lnglat' : _ref$coord,
          tileOrigin = _ref.tileOrigin;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        strokeOpacity: strokeOpacity,
        strokeWidth: strokeWidth,
        stroke: stroke,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          strokeOpacity: strokeOpacity,
          strokeWidth: strokeWidth,
          stroke: stroke,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_tileOrigin: tileOrigin || [0, 0],
        u_coord: coord === 'lnglat' ? 1.0 : 0.0,
        u_isMeter: Number(this.isMeter),
        u_blur: blur,
        u_additive: blend === 'additive' ? 1.0 : 0.0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: Number(opacity),
        u_stroke_opacity: Number(strokeOpacity),
        u_stroke_width: Number(strokeWidth),
        u_stroke_color: this.getStrokeColor(stroke),
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "getAttribute",
    value: function getAttribute() {
      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PointFillTriangulation);
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$unit = _ref2.unit,
          unit = _ref2$unit === void 0 ? 'l7size' : _ref2$unit;

      var version = this.mapService.version;

      if (unit === 'meter' && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version.L7MAP && version !== _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version.GLOBEL) {
        this.isMeter = true;
        this.calMeter2Coord();
      }

      return this.buildModels();
    }
  }, {
    key: "calMeter2Coord",
    value: function calMeter2Coord() {
      var _this$layer$getSource = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(this.layer.getSource().extent, 4),
          minLng = _this$layer$getSource[0],
          minLat = _this$layer$getSource[1],
          maxLng = _this$layer$getSource[2],
          maxLat = _this$layer$getSource[3];

      var center = [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
      var version = this.mapService.version;

      if (version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_11__.Version.MAPBOX && window.mapboxgl.MercatorCoordinate) {
        var coord = window.mapboxgl.MercatorCoordinate.fromLngLat({
          lng: center[0],
          lat: center[1]
        }, 0);
        var offsetInMeters = 1;
        var offsetInMercatorCoordinateUnits = offsetInMeters * coord.meterInMercatorCoordinateUnits();
        var westCoord = new window.mapboxgl.MercatorCoordinate(coord.x - offsetInMercatorCoordinateUnits, coord.y, coord.z);
        var westLnglat = westCoord.toLngLat();
        this.meter2coord = center[0] - westLnglat.lng;
        return;
      }

      var m1 = this.mapService.meterToCoord(center, [minLng, minLat]);
      var m2 = this.mapService.meterToCoord(center, [maxLng === minLng ? maxLng + 0.1 : maxLng, maxLat === minLat ? minLat + 0.1 : maxLat]);
      this.meter2coord = (m1 + m2) / 2;

      if (!Boolean(this.meter2coord)) {
        this.meter2coord = 7.70681090738883;
      }
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$mask = _ref3.mask,
          mask = _ref3$mask === void 0 ? false : _ref3$mask,
          _ref3$maskInside = _ref3.maskInside,
          maskInside = _ref3$maskInside === void 0 ? true : _ref3$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      this.layer.triangulation = _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PointFillTriangulation;
      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.PointFillTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside),
        cull: {
          enable: true,
          face: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getCullFace)(this.mapService.version)
        }
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: point_tile_frag,
        vert: point_tile_vert,
        type: 'point_fill_tile'
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'extrude',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Extrude',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
            var extrudeIndex = attributeIdx % 4 * 3;
            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0] * _this2.meter2coord] : [size * _this2.meter2coord];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'shape',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Shape',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$shape = feature.shape,
                shape = _feature$shape === void 0 ? 2 : _feature$shape;

            var shape2d = _this2.layer.getLayerConfig().shape2d;

            var shapeIndex = shape2d.indexOf(shape);
            return [shapeIndex];
          }
        }
      });
    }
  }]);

  return FillModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=tile.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PolygonLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models___WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/ */ "./node_modules/@antv/l7-layers/es/polygon/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PolygonLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(PolygonLayer, _BaseLayer);

  var _super = _createSuper(PolygonLayer);

  function PolygonLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, PolygonLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'PolygonLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(PolygonLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var shape = this.getModelType();
      this.layerModel = new _models___WEBPACK_IMPORTED_MODULE_7__.default[shape](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      var _shapeAttribute$scale;

      if (this.layerSource.parser.type === 'mvt') {
        return 'vectorpolygon';
      }

      var shapeAttribute = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shape = shapeAttribute === null || shapeAttribute === void 0 ? void 0 : (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;

      if (shape === 'fill') {
        return 'fill';
      } else if (shape === 'extrude') {
        return 'extrude';
      } else if (shape === 'water') {
        return 'water';
      } else if (shape === 'ocean') {
        return 'ocean';
      } else if (shape === 'line') {
        return 'line';
      } else if (shape === 'tile') {
        return 'tile';
      } else {
        return this.getPointModelType();
      }
    }
  }, {
    key: "getPointModelType",
    value: function getPointModelType() {
      var layerData = this.getEncodedData();

      var _this$getLayerConfig = this.getLayerConfig(),
          shape2d = _this$getLayerConfig.shape2d,
          shape3d = _this$getLayerConfig.shape3d;

      var iconMap = this.iconService.getIconMap();
      var item = layerData.find(function (fe) {
        return fe.hasOwnProperty('shape');
      });

      if (!item) {
        return 'fill';
      } else {
        var shape = item.shape;

        if (shape === 'dot') {
          return 'point_normal';
        }

        if ((shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(shape)) !== -1) {
          return 'point_fill';
        }

        if ((shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) !== -1) {
          return 'point_extrude';
        }

        if (iconMap.hasOwnProperty(shape)) {
          return 'point_image';
        }

        return 'text';
      }
    }
  }]);

  return PolygonLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/extrude.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/extrude.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ExtrudeModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var polygonExtrudeFrag = "uniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];  \n  float isSide = styleMappingMat[0][3];\n  float sidey = styleMappingMat[3][0];\n  float lightWeight = styleMappingMat[3][1];\n\n  if(isSide < 1.0) {\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n\n    if(u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      gl_FragColor = linearColor;\n    } else {\n      gl_FragColor = v_Color;\n    }\n\n  } else {\n     // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n\n    gl_FragColor = v_Color;\n  }\n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var polygonExtrudeVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - isSide\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // sidey\n  );\n  styleMappingMat[0][3] = a_Position.z;\n  styleMappingMat[3][0] = a_uvs[2];\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // project_pos.z += 500000.0; // amap1\n\n  // project_pos.z += (500000.0 * 4.0)/pow(2.0, 21.0 - u_Zoom); // mapbox\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  styleMappingMat[3][1] = lightWeight;\n\n  setPickingColor(a_PickingColor);\n}\n";
var polygonExtrudeTexFrag = "uniform sampler2D u_texture;\nuniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float isSide = styleMappingMat[0][3];\n  float lightWeight = styleMappingMat[3][1];\n  float topU = styleMappingMat[2][2];\n  float topV = styleMappingMat[2][3];\n\n  float sidey = styleMappingMat[3][0];\n  if(isSide < 1.0) {\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n\n    if(u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      gl_FragColor = linearColor;\n    } else {\n      gl_FragColor = v_Color;\n    }\n  } else {\n\n     // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n\n    gl_FragColor = texture2D(u_texture, vec2(topU, topV));\n  }\n  \n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var polygonExtrudeTexVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_Color = a_Color;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - a_Position.z(judge side by a_Position.z)\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1] - u - v\n    0.0, 0.0, 0.0, 0.0  // sidey\n  );\n  \n  styleMappingMat[0][3] = a_Position.z;\n  styleMappingMat[2][2] = a_uvs[0];\n  styleMappingMat[2][3] = 1.0 - a_uvs[1];\n  styleMappingMat[3][0] = a_uvs[2];\n\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // project_pos.z += 500000.0; // amap1\n\n  // project_pos.z += (500000.0 * 4.0)/pow(2.0, 21.0 - u_Zoom); // mapbox\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  styleMappingMat[3][1] = lightWeight;\n\n  setPickingColor(a_PickingColor);\n}\n";
var polygonExtrudePickLightFrag = "uniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  float isSide = styleMappingMat[0][3];\n  float sidey = styleMappingMat[3][0];\n  float lightWeight = styleMappingMat[3][1];\n\n  if(isSide < 1.0) {\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n    \n    if( u_linearColor == 1.0) {\n      // side use linear\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      gl_FragColor = linearColor;\n    } else {\n      // side notuse linear\n       gl_FragColor = v_Color;\n    }\n  } else {\n    // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n    gl_FragColor = v_Color;\n  }\n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColorAlpha(gl_FragColor, lightWeight);\n}\n";
var polygonExtrudePickLightVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - isSide\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0  // sidey\n  );\n  styleMappingMat[0][3] = a_Position.z;\n  styleMappingMat[3][0] = a_uvs[2];\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  styleMappingMat[3][1] = lightWeight;\n\n  setPickingColor(a_PickingColor);\n}\n";

var ExtrudeModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(ExtrudeModel, _BaseModel);

  var _super = _createSuper(ExtrudeModel);

  function ExtrudeModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, ExtrudeModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(ExtrudeModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$heightfixed = _ref.heightfixed,
          heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
          _ref$raisingHeight = _ref.raisingHeight,
          raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,
          _ref$topsurface = _ref.topsurface,
          topsurface = _ref$topsurface === void 0 ? true : _ref$topsurface,
          _ref$sidesurface = _ref.sidesurface,
          sidesurface = _ref$sidesurface === void 0 ? true : _ref$sidesurface,
          sourceColor = _ref.sourceColor,
          targetColor = _ref.targetColor;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      var useLinearColor = 0;
      var sourceColorArr = [1, 1, 1, 1];
      var targetColorArr = [1, 1, 1, 1];

      if (sourceColor && targetColor) {
        sourceColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.rgb2arr)(sourceColor);
        targetColorArr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.rgb2arr)(targetColor);
        useLinearColor = 1;
      }

      return {
        u_topsurface: Number(topsurface),
        u_sidesurface: Number(sidesurface),
        u_heightfixed: Number(heightfixed),
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_raisingHeight: Number(raisingHeight),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0,
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_texture: this.texture
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.loadTexture();
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      var _this$getShaders = this.getShaders(),
          frag = _this$getShaders.frag,
          vert = _this$getShaders.vert,
          type = _this$getShaders.type;

      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.PolygonExtrudeTriangulation,
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref3 = this.layer.getLayerConfig(),
          pickLight = _ref3.pickLight,
          mapTexture = _ref3.mapTexture;

      if (mapTexture) {
        return {
          frag: polygonExtrudeTexFrag,
          vert: polygonExtrudeTexVert,
          type: 'polygonExtrudeTexture'
        };
      }

      if (pickLight) {
        return {
          frag: polygonExtrudePickLightFrag,
          vert: polygonExtrudePickLightVert,
          type: 'polygonExtrudePickLight'
        };
      } else {
        return {
          frag: polygonExtrudeFrag,
          vert: polygonExtrudeVert,
          type: 'polygonExtrude'
        };
      }
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture, _this$texture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var bbox = this.layer.getSource().extent;

      var _bbox = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(bbox, 4),
          minLng = _bbox[0],
          minLat = _bbox[1],
          maxLng = _bbox[2],
          maxLat = _bbox[3];

      var lngLen = maxLng - minLng;
      var latLen = maxLat - minLat;
      this.styleAttributeService.registerStyleAttribute({
        name: 'uvs',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_uvs',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            var lng = vertex[0];
            var lat = vertex[1];
            return [(lng - minLng) / lngLen, (lat - minLat) / latLen, vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 10 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture() {
      var _this2 = this;

      var _ref4 = this.layer.getLayerConfig(),
          mapTexture = _ref4.mapTexture;

      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });

      if (mapTexture) {
        var image = new Image();
        image.crossOrigin = '';
        image.src = mapTexture;

        image.onload = function () {
          _this2.texture = createTexture2D({
            data: image,
            width: image.width,
            height: image.height,
            wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE,
            wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.CLAMP_TO_EDGE,
            min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
            mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR
          });

          _this2.layerService.updateLayerRenderList();

          _this2.layerService.renderLayers();
        };
      }
    }
  }]);

  return ExtrudeModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=extrude.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/fill.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/fill.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FillModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var polygon_frag = "uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var polygon_linear_frag = "uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\nuniform float u_opacitylinear: 0.0;\nuniform float u_dir: 1.0;\nvarying vec3 v_linear;\nvarying vec2 v_pos;\n\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  \n  if(u_opacitylinear > 0.0) {\n    gl_FragColor.a *= u_dir == 1.0 ? 1.0 - length(v_pos - v_linear.xy)/v_linear.z : length(v_pos - v_linear.xy)/v_linear.z;\n  }\n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var polygon_linear_vert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_opacity: 1.0;\nuniform float u_raisingHeight: 0.0;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nuniform float u_opacitylinear: 0.0;\n\nattribute vec3 a_linear;\nvarying vec3 v_linear;\nvarying vec2 v_pos;\n\nvoid main() {\n  if(u_opacitylinear > 0.0) {\n    v_linear = a_linear;\n    v_pos = a_Position.xy;\n  }\n  \n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  project_pos.z += u_raisingHeight;\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}";
var polygon_vert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_opacity: 1.0;\nuniform float u_raisingHeight: 0.0;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  project_pos.z += u_raisingHeight;\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n\n";

var FillModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(FillModel, _BaseModel);

  var _super = _createSuper(FillModel);

  function FillModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, FillModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(FillModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$raisingHeight = _ref.raisingHeight,
          raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$opacityLinear = _ref.opacityLinear,
          opacityLinear = _ref$opacityLinear === void 0 ? {
        enable: false,
        dir: 'in'
      } : _ref$opacityLinear;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_raisingHeight: Number(raisingHeight),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(opacity) ? opacity : 1.0,
        u_opacitylinear: Number(opacityLinear.enable),
        u_dir: opacityLinear.dir === 'in' ? 1.0 : 0.0
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _this$getModelParams = this.getModelParams(),
          frag = _this$getModelParams.frag,
          vert = _this$getModelParams.vert,
          triangulation = _this$getModelParams.triangulation,
          type = _this$getModelParams.type;

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      this.layer.triangulation = triangulation;
      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: triangulation,
        blend: this.getBlend(),
        depth: {
          enable: false
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$opacityLinear = _ref3.opacityLinear,
          opacityLinear = _ref3$opacityLinear === void 0 ? {
        enable: false,
        dir: 'in'
      } : _ref3$opacityLinear;

      if (opacityLinear.enable) {
        this.styleAttributeService.registerStyleAttribute({
          name: 'linear',
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.AttributeType.Attribute,
          descriptor: {
            name: 'a_linear',
            buffer: {
              usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.STATIC_DRAW,
              data: [],
              type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_6__.gl.FLOAT
            },
            size: 3,
            update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
              return [vertex[3], vertex[4], vertex[5]];
            }
          }
        });
      }
    }
  }, {
    key: "getModelParams",
    value: function getModelParams() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$opacityLinear = _ref4.opacityLinear,
          opacityLinear = _ref4$opacityLinear === void 0 ? {
        enable: false
      } : _ref4$opacityLinear;

      if (opacityLinear.enable) {
        return {
          frag: polygon_linear_frag,
          vert: polygon_linear_vert,
          type: 'polygon_linear',
          triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.polygonTriangulationWithCenter
        };
      } else {
        return {
          frag: polygon_frag,
          vert: polygon_vert,
          type: 'polygon_fill',
          triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_8__.polygonTriangulation
        };
      }
    }
  }]);

  return FillModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=fill.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _line_models_line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../line/models/line */ "./node_modules/@antv/l7-layers/es/line/models/line.js");
/* harmony import */ var _point_models_extrude__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../point/models/extrude */ "./node_modules/@antv/l7-layers/es/point/models/extrude.js");
/* harmony import */ var _point_models_fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../point/models/fill */ "./node_modules/@antv/l7-layers/es/point/models/fill.js");
/* harmony import */ var _point_models_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../point/models/image */ "./node_modules/@antv/l7-layers/es/point/models/image.js");
/* harmony import */ var _point_models_normal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../point/models/normal */ "./node_modules/@antv/l7-layers/es/point/models/normal.js");
/* harmony import */ var _point_models_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../point/models/text */ "./node_modules/@antv/l7-layers/es/point/models/text.js");
/* harmony import */ var _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../tile/models/tileModel */ "./node_modules/@antv/l7-layers/es/tile/models/tileModel.js");
/* harmony import */ var _extrude__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extrude */ "./node_modules/@antv/l7-layers/es/polygon/models/extrude.js");
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fill */ "./node_modules/@antv/l7-layers/es/polygon/models/fill.js");
/* harmony import */ var _ocean__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ocean */ "./node_modules/@antv/l7-layers/es/polygon/models/ocean.js");
/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tile */ "./node_modules/@antv/l7-layers/es/polygon/models/tile.js");
/* harmony import */ var _water__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./water */ "./node_modules/@antv/l7-layers/es/polygon/models/water.js");












var PolygonModels = {
  fill: _fill__WEBPACK_IMPORTED_MODULE_0__.default,
  line: _line_models_line__WEBPACK_IMPORTED_MODULE_1__.default,
  extrude: _extrude__WEBPACK_IMPORTED_MODULE_2__.default,
  text: _point_models_text__WEBPACK_IMPORTED_MODULE_3__.default,
  point_fill: _point_models_fill__WEBPACK_IMPORTED_MODULE_4__.default,
  point_image: _point_models_image__WEBPACK_IMPORTED_MODULE_5__.default,
  point_normal: _point_models_normal__WEBPACK_IMPORTED_MODULE_6__.default,
  point_extrude: _point_models_extrude__WEBPACK_IMPORTED_MODULE_7__.default,
  water: _water__WEBPACK_IMPORTED_MODULE_8__.default,
  ocean: _ocean__WEBPACK_IMPORTED_MODULE_9__.default,
  vectorpolygon: _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_10__.default,
  tile: _tile__WEBPACK_IMPORTED_MODULE_11__.default
};
/* harmony default export */ __webpack_exports__["default"] = (PolygonModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/ocean.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/ocean.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ OceanModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var ocean_frag = "\nuniform float u_time: 0.0;\nuniform float u_opacity: 1.0;\n\nvarying vec2 v_uv;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\nfloat coast2water_fadedepth = 0.10;\nfloat large_waveheight      = .750; // change to adjust the \"heavy\" waves\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\nfloat water_glossylight_fact= 120.; // range [1..200]\nfloat particle_amount       = 70.;\n// vec3 watercolor             = vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\n// vec3 watercolor2            = vec3(0.06, 0.07, 0.11); // deep-water color (RGB, should be darker than the low-water color)\nuniform vec4 u_watercolor;\nuniform vec4 u_watercolor2;\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\n\nuniform sampler2D u_texture1;\nuniform sampler2D u_texture2;\nuniform sampler2D u_texture3;\n\n  \n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\n// 2d noise function\nfloat noise1( in vec2 x ) {\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise(vec2 p) {\n    return texture2D(u_texture2,p*vec2(1./256.)).x;\n}\n\nvec4 highness(vec2 p) {\n    vec4 t = texture2D(u_texture1,fract(p));\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\n}\n\nfloat height_map( vec2 p ) {\n    vec4 height=highness(p);\n    /*\n    height = -0.5+\n        0.5*smoothstep(-100.,0.,-height)+\n        2.75*smoothstep(0.,2.,height)+\n        1.75*smoothstep(2.,4.,height)+\n        2.75*smoothstep(4.,16.,height)+\n        1.5*smoothstep(16.,1000.,height);\n    */\n\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n    //p = p*6.;\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\n    f += 0.2500*noise( p ); p = m*p*1.32;\n    f += 0.1666*noise( p ); p = m*p*1.11;\n    f += 0.0834*noise( p ); p = m*p*1.12;\n    f += 0.0634*noise( p ); p = m*p*1.13;\n    f += 0.0444*noise( p ); p = m*p*1.14;\n    f += 0.0274*noise( p ); p = m*p*1.15;\n    f += 0.0134*noise( p ); p = m*p*1.16;\n    f += 0.0104*noise( p ); p = m*p*1.17;\n    f += 0.0084*noise( p );\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\n        const float FLAT_LEVEL = 0.92525;\n        //f = f*0.25+height*0.75;\n    if (f<FLAT_LEVEL)\n        f = f;\n    else\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\n    return clamp(f, 0., 10.);\n}\n\nvec3 plasma_quintic( float x ) {\n    x = clamp( x, 0.0, 1.0);\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n    return vec3(\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\nvec4 color(vec2 p){\n    vec4 c1 = vec4(1.7,1.6,.9,1);\n    vec4 c2 = vec4(.2,.94,.1,1);\n    vec4 c3 = vec4(.3,.2,.0,1);\n    vec4 c4 = vec4(.99,.99,1.6,1);\n    vec4 v = highness(p);\n    float los = smoothstep(0.1,1.1,v.b);\n    float his = smoothstep(3.5,6.5,v.b);\n    float ces = smoothstep(1.,5.,v.a);\n    vec4 lo = mix(c1,c2,los);\n    vec4 hi = mix(c3,c4,his);\n    vec4 ce = mix(lo,hi,ces);\n\n    return vec4(plasma_quintic(ces),1).ragb;\n}\n\nvec3 terrain_map( vec2 p )\n{\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture2D(u_texture3, fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height ) {\n    vec2 p2 = p*large_wavesize;\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\n\n    // coarse crossing 'ocean' waves...\n    float f = 0.6000*noise( p );\n    f += 0.2500*noise( p*m );\n    f += 0.1666*noise( p*m*m );\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\n\n    p *= small_wavesize;\n    f = 0.;\n    float amp = 1.0, s = .5;\n    for (int i=0; i<9; i++)\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\n    \n    return wave+f*small_waveheight;\n}\n\nfloat nautic(vec2 p) {\n    p *= 18.;\n    float f = 0.;\n    float amp = 1.0, s = .5;\n    for (int i=0; i<3; i++)\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\n    return pow(1.-f, 5.);\n}\n\nfloat particles(vec2 p) {\n    p *= 200.;\n    float f = 0.;\n    float amp = 1.0, s = 1.5;\n    for (int i=0; i<3; i++)\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\n    return pow(f*.35, 7.)*particle_amount;\n}\n\nfloat test_shadow( vec2 xy, float height) {\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n    for (int j=1; j<25; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n    return hit;\n}\n\nvec3 CalcTerrain(vec2 uv, float height) {\n    vec3 col = terrain_map( uv );\n    vec2 iResolution = vec2(512.);\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\n    vec3 r0 = vec3(uv, height);\n    vec3 rd = normalize( light - r0 );\n    float grad = dot(norm, rd);\n    col *= grad+pow(grad, 8.);\n    float terrainshade = test_shadow( uv, height );\n    col = mix(col*.25, col, terrainshade);\n    return col;\n}\n\n\nvoid main() {\n  vec3 watercolor = u_watercolor.rgb;\n  vec3 watercolor2 = u_watercolor2.rgb;\n  vec2 uv = v_uv;\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\n  float height = height_map( uv );\n  vec3 col;\n\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\n    if (height > level)\n    {\n        col = CalcTerrain(uv, height);\n    }\n    if (height <= level)\n    {\n        vec2 dif = vec2(.0, .01);\n        vec2 pos = uv*15. + vec2(u_time*.01);\n        float h1 = water_map(pos-dif,waveheight);\n        float h2 = water_map(pos+dif,waveheight);\n        float h3 = water_map(pos-dif.yx,waveheight);\n        float h4 = water_map(pos+dif.yx,waveheight);\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n        uv += normwater.xy*.002*(level-height);\n        \n        col = CalcTerrain(uv, height);\n\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n        vec3 r0 = vec3(uv, WATER_LEVEL);\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n        float watershade  = test_shadow( uv, level );\n        watercolor *= 2.2+watershade;\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\n        watercolor /= (1.+specular1*1.25);\n        watercolor += watershade*specular2*water_specularcolor;\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\n        \n        col = mix(col, watercolor, coastfade);\n    }\n    \n\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = vec4(col, opacity);  \n}\n";
var ocean_vert = "attribute vec2 a_uv;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec2 v_uv;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_uv = a_uv;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n}\n\n";

var OceanModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(OceanModel, _BaseModel);

  var _super = _createSuper(OceanModel);

  function OceanModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, OceanModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture1", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture2", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture3", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(OceanModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$watercolor = _ref.watercolor,
          watercolor = _ref$watercolor === void 0 ? '#6D99A8' : _ref$watercolor,
          _ref$watercolor2 = _ref.watercolor2,
          watercolor2 = _ref$watercolor2 === void 0 ? '#0F121C' : _ref$watercolor2;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_texture1: this.texture1,
        u_texture2: this.texture2,
        u_texture3: this.texture3,
        u_watercolor: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.rgb2arr)(watercolor),
        u_watercolor2: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.rgb2arr)(watercolor2),
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      return {
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.loadTexture();
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'polygon_ocean',
        vertexShader: ocean_vert,
        fragmentShader: ocean_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.polygonTriangulation,
        depth: {
          enable: false
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$texture2, _this$texture3, _this$dataTexture;

      (_this$texture = this.texture1) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 ? void 0 : _this$texture2.destroy();
      (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 ? void 0 : _this$texture3.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var bbox = this.layer.getSource().extent;

      var _bbox = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(bbox, 4),
          minLng = _bbox[0],
          minLat = _bbox[1],
          maxLng = _bbox[2],
          maxLat = _bbox[3];

      var lngLen = maxLng - minLng;
      var latLen = maxLat - minLat;
      this.styleAttributeService.registerStyleAttribute({
        name: 'oceanUv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            var _vertex = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(vertex, 2),
                lng = _vertex[0],
                lat = _vertex[1];

            return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
          }
        }
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture() {
      var _this2 = this;

      var createTexture2D = this.rendererService.createTexture2D;
      var defaultTextureOptions = {
        height: 0,
        width: 0
      };
      this.texture1 = createTexture2D(defaultTextureOptions);
      this.texture2 = createTexture2D(defaultTextureOptions);
      this.texture3 = createTexture2D(defaultTextureOptions);
      initImage(function (images) {
        _this2.texture1 = initTex(images[0]);
        _this2.texture2 = initTex(images[1]);
        _this2.texture3 = initTex(images[2]);

        _this2.layerService.updateLayerRenderList();

        _this2.layerService.renderLayers();
      });

      function initImage(callback) {
        var loadedCount = 0;
        var loadedImages = [];
        var images = ['https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ'];
        images.map(function (imgSrc) {
          var image = new Image();
          image.crossOrigin = '';
          image.src = imgSrc;
          loadedImages.push(image);

          image.onload = function () {
            loadedCount++;

            if (loadedCount === 3) {
              callback(loadedImages);
            }
          };
        });
      }

      function initTex(image) {
        return createTexture2D({
          data: image,
          width: image.width,
          height: image.height,
          wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.MIRRORED_REPEAT,
          wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.MIRRORED_REPEAT,
          min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
          mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR
        });
      }
    }
  }]);

  return OceanModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=ocean.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/tile.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/tile.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FillModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var polygon_tile_frag = "uniform float u_opacity: 1.0;\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var polygon_tile_vert = "attribute vec4 a_Color;\nattribute vec3 a_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_opacity: 1.0;\n\nuniform vec2 u_tileOrigin;\nuniform float u_coord;\n\nvarying vec4 v_Color;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n  }\n\nif(u_coord > 0.0) {\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n} else {\n    vec2 pointPos = a_Position.xy;\n    vec4 world = vec4(project_mvt_offset_position(vec4(u_tileOrigin, 0.0, 1.0)).xyz, 1.0); // \u74E6\u7247\u8D77\u59CB\u70B9\u7684\u4E16\u754C\u5750\u6807\n\n    vec2 pointOffset =  pointPos *  pow(2.0, u_Zoom); // \u74E6\u7247\u5185\u7684\u70B9\u7684\u504F\u79FB\u5750\u6807\n    \n    world.xy += pointOffset;\n\n    if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // Needs to be divided with project_uCommonUnitsPerMeter\n      world.w *= u_PixelsPerMeter.z;\n    }\n\n    gl_Position = u_ViewProjectionMatrix * world + u_ViewportCenterProjection;\n}\n\n\n  setPickingColor(a_PickingColor);\n}\n\n";

var FillModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(FillModel, _BaseModel);

  var _super = _createSuper(FillModel);

  function FillModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, FillModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(FillModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          tileOrigin = _ref.tileOrigin,
          _ref$coord = _ref.coord,
          coord = _ref$coord === void 0 ? 'lnglat' : _ref$coord;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_tileOrigin: tileOrigin || [0, 0],
        u_coord: coord === 'lnglat' ? 1.0 : 0.0,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_opacity: opacity
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _this$getModelParams = this.getModelParams(),
          frag = _this$getModelParams.frag,
          vert = _this$getModelParams.vert,
          triangulation = _this$getModelParams.triangulation,
          type = _this$getModelParams.type;

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      this.layer.triangulation = triangulation;
      return [this.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: triangulation,
        blend: this.getBlend(),
        depth: {
          enable: false
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$dataTexture;

      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {}
  }, {
    key: "getModelParams",
    value: function getModelParams() {
      return {
        frag: polygon_tile_frag,
        vert: polygon_tile_vert,
        type: 'polygon_tile',
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_7__.polygonTriangulation
      };
    }
  }]);

  return FillModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=tile.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/polygon/models/water.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/polygon/models/water.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ WaterModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");










function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var water_frag = "uniform sampler2D u_texture;\nuniform float u_time: 0.0;\nuniform float u_speed: 1.0;\nuniform float u_opacity: 1.0;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n\nfloat rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\nfloat water(vec3 p) {\n  float t = u_time * u_speed;\n  p.z += t * 2.; p.x += t * 2.;\n  vec3 c1 = texture2D(u_texture, p.xz / 30.).xyz;\n  p.z += t * 3.; p.x += t * 0.52;\n  vec3 c2 = texture2D(u_texture, p.xz / 30.).xyz;\n  p.z += t * 4.; p.x += t * 0.8;\n  vec3 c3 = texture2D(u_texture, p.xz / 30.).xyz;\n  c1 += c2 - c3;\n  float z = (c1.x + c1.y + c1.z) / 3.;\n  return p.y + z / 4.;\n}\n\nfloat map(vec3 p) {\n  float d = 100.0;\n  d = water(p);\n  return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n  float d = 0.0;\n  for (int i = 0; i <= 100; i++) {\n    float h = map(ro + rd * d);\n    if (h < 0.1) return  d;\n    d += h;\n  }\n  return 0.0;\n}\n\nvec3 norm(vec3 p) {\n  float eps = .1;\n  return normalize(vec3(\n    map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n    map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n    map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n  ));\n} \n\nfloat calSpc() {\n  vec3 l1 = normalize(vec3(1, 1, 1));\n  vec3 ro = vec3(-3, 20, -8);\n  vec3 rc = vec3(0, 0, 0);\n  vec3 ww = normalize(rc - ro);\n  vec3 uu = normalize(cross(vec3(0,1,0), ww));\n  vec3 vv = normalize(cross(rc - ro, uu));\n  vec3 rd = normalize(uu * v_uv.x + vv * v_uv.y + ww);\n  float d = intersect(ro, rd);\n  vec3 p = ro + rd * d;\n  vec3 n = norm(p);\n  float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n  return spc;\n}\n\nvoid main() {\n  float opacity = styleMappingMat[0][0];\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n\n  float spc = calSpc();\n  gl_FragColor += spc * 0.4;\n}\n";
var water_vert = "attribute vec4 a_Color;\nattribute vec2 a_uv;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nuniform float u_opacity: 1.0;\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_uv = a_uv;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\nstyleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n}\n\n";

var WaterModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(WaterModel, _BaseModel);

  var _super = _createSuper(WaterModel);

  function WaterModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, WaterModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "texture", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(WaterModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$speed = _ref.speed,
          speed = _ref$speed === void 0 ? 0.5 : _ref$speed;

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity
      })) {
        this.judgeStyleAttributes({
          opacity: opacity
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LUMINANCE,
          type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_texture: this.texture,
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_speed: speed,
        u_opacity: lodash_isNumber__WEBPACK_IMPORTED_MODULE_8___default()(opacity) ? opacity : 1.0
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      return {
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.loadTexture();
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'polygon_water',
        vertexShader: water_vert,
        fragmentShader: water_frag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_11__.polygonTriangulation,
        depth: {
          enable: false
        },
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_10__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var bbox = this.layer.getSource().extent;

      var _bbox = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(bbox, 4),
          minLng = _bbox[0],
          minLat = _bbox[1],
          maxLng = _bbox[2],
          maxLat = _bbox[3];

      var lngLen = maxLng - minLng;
      var latLen = maxLat - minLat;
      this.styleAttributeService.registerStyleAttribute({
        name: 'waterUv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.AttributeType.Attribute,
        descriptor: {
          name: 'a_uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.STATIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            var _vertex = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(vertex, 2),
                lng = _vertex[0],
                lat = _vertex[1];

            return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
          }
        }
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture() {
      var _this2 = this;

      var _ref3 = this.layer.getLayerConfig(),
          waterTexture = _ref3.waterTexture;

      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      var image = new Image();
      image.crossOrigin = '';

      if (waterTexture) {
        console.warn('L7 recommendhttps://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ');
        image.src = waterTexture;
      } else {
        image.src = 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ';
      }

      image.onload = function () {
        _this2.texture = createTexture2D({
          data: image,
          width: image.width,
          height: image.height,
          wrapS: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.MIRRORED_REPEAT,
          wrapT: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.MIRRORED_REPEAT,
          min: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR,
          mag: _antv_l7_core__WEBPACK_IMPORTED_MODULE_9__.gl.LINEAR
        });

        _this2.layerService.updateLayerRenderList();

        _this2.layerService.renderLayers();
      };
    }
  }]);

  return WaterModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_12__.default);


//# sourceMappingURL=water.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/raster/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/raster/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RaterLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/index */ "./node_modules/@antv/l7-layers/es/raster/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var RaterLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(RaterLayer, _BaseLayer);

  var _super = _createSuper(RaterLayer);

  function RaterLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RaterLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'RasterLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RaterLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models_index__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        raster: {},
        raster3d: {},
        rasterTile: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      switch (this.layerSource.parser.type) {
        case 'raster':
          return 'raster';

        case 'rasterTile':
          return 'rasterTile';

        default:
          return 'raster';
      }
    }
  }]);

  return RaterLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/raster/models/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/raster/models/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tile/models/tileModel */ "./node_modules/@antv/l7-layers/es/tile/models/tileModel.js");
/* harmony import */ var _raster__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster */ "./node_modules/@antv/l7-layers/es/raster/models/raster.js");


var RasterModels = {
  raster: _raster__WEBPACK_IMPORTED_MODULE_0__.default,
  raster3d: _raster__WEBPACK_IMPORTED_MODULE_0__.default,
  rasterTile: _tile_models_tileModel__WEBPACK_IMPORTED_MODULE_1__.default
};
/* harmony default export */ __webpack_exports__["default"] = (RasterModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/raster/models/raster.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/raster/models/raster.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RasterModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var rasterFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_min;\nuniform float u_max;\nuniform vec2 u_domain;\nuniform float u_noDataValue;\nuniform bool u_clampLow: true;\nuniform bool u_clampHigh: true;\nvarying vec2 v_texCoord;\n\nvoid main() {\n\n  float value = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y)).r;\n  if (value == u_noDataValue)\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n    gl_FragColor = vec4(0, 0, 0, 0);\n  else {\n    float normalisedValue =(value - u_domain[0]) / (u_domain[1] -u_domain[0]);\n    vec4 color = texture2D(u_colorTexture,vec2(normalisedValue, 0));\n    gl_FragColor = color;\n    gl_FragColor.a =  gl_FragColor.a * u_opacity ;\n  }\n\n\n}\n";
var rasterVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n#pragma include \"projection\"\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy,0., 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   }\n}\n";

var RasterModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(RasterModel, _BaseModel);

  var _super = _createSuper(RasterModel);

  function RasterModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RasterModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "colorTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "rampColors", void 0);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RasterModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$clampLow = _ref.clampLow,
          clampLow = _ref$clampLow === void 0 ? true : _ref$clampLow,
          _ref$clampHigh = _ref.clampHigh,
          clampHigh = _ref$clampHigh === void 0 ? true : _ref$clampHigh,
          _ref$noDataValue = _ref.noDataValue,
          noDataValue = _ref$noDataValue === void 0 ? -9999999 : _ref$noDataValue,
          _ref$domain = _ref.domain,
          domain = _ref$domain === void 0 ? [0, 1] : _ref$domain,
          rampColors = _ref.rampColors;

      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_7___default()(this.rampColors, rampColors)) {
        this.updateColorTexure();
        this.rampColors = rampColors;
      }

      return {
        u_opacity: opacity || 1,
        u_texture: this.texture,
        u_domain: domain,
        u_clampLow: clampLow,
        u_clampHigh: typeof clampHigh !== 'undefined' ? clampHigh : clampLow,
        u_noDataValue: noDataValue,
        u_colorTexture: this.colorTexture
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside,
          rampColorsData = _ref2.rampColorsData,
          rampColors = _ref2.rampColors;

      var source = this.layer.getSource();
      var createTexture2D = this.rendererService.createTexture2D;
      var parserDataItem = source.data.dataArray[0];
      this.texture = createTexture2D({
        data: parserDataItem.data,
        width: parserDataItem.width,
        height: parserDataItem.height,
        format: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.LUMINANCE,
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
      });
      var imageData = rampColorsData ? rampColorsData : (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.generateColorRamp)(rampColors);
      this.colorTexture = createTexture2D({
        data: imageData.data,
        width: imageData.width,
        height: imageData.height,
        flipY: false
      });
      return [this.layer.buildLayerModel({
        moduleName: 'RasterImageData',
        vertexShader: rasterVert,
        fragmentShader: rasterFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.RasterImageTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.TRIANGLES,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.getMask)(mask, maskInside)
      })];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$colorTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 ? void 0 : _this$colorTexture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_8__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "updateColorTexure",
    value: function updateColorTexure() {
      var createTexture2D = this.rendererService.createTexture2D;

      var _ref3 = this.layer.getLayerConfig(),
          rampColors = _ref3.rampColors;

      var imageData = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_9__.generateColorRamp)(rampColors);
      this.colorTexture = createTexture2D({
        data: imageData.data,
        width: imageData.width,
        height: imageData.height,
        flipY: false
      });
    }
  }]);

  return RasterModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=raster.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/manager/tileConfigManager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/manager/tileConfigManager.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TileConfigManager; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_8__);









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var TileConfigManager = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(TileConfigManager, _EventEmitter);

  var _super = _createSuper(TileConfigManager);

  function TileConfigManager() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, TileConfigManager);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "cacheConfig", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "checkConfigList", []);

    _this.cacheConfig = new Map();
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(TileConfigManager, [{
    key: "setConfig",
    value: function setConfig(key, value) {
      if (!this.checkConfigList.includes(key)) {
        this.checkConfigList.push(key);
      }

      this.cacheConfig.set(key, value);
    }
  }, {
    key: "removeConfig",
    value: function removeConfig(key) {
      var configIndex = this.checkConfigList.indexOf(key);

      if (configIndex > -1) {
        this.cacheConfig.delete(key);
        this.checkConfigList.splice(configIndex, 1);
      }
    }
  }, {
    key: "checkConfig",
    value: function checkConfig(layer) {
      var _this2 = this;

      if (!layer.inited) {
        return;
      }

      var layerConfig = layer.getLayerConfig();
      var updateConfigs = [];
      this.checkConfigList.map(function (key) {
        var cacheConfig = _this2.cacheConfig.get(key);

        var currentConfig;

        if (['color', 'size', 'shape'].includes(key)) {
          var _layer$getAttribute;

          currentConfig = (_layer$getAttribute = layer.getAttribute(key)) === null || _layer$getAttribute === void 0 ? void 0 : _layer$getAttribute.scale;
        } else {
          if (!(key in layerConfig)) {
            return;
          }

          currentConfig = layerConfig[key];
        }

        if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_7___default()(cacheConfig, currentConfig)) {
          updateConfigs.push(key);

          _this2.setConfig(key, currentConfig);
        }
      });

      if (updateConfigs.length > 0) {
        console.warn('tile config cache update!', updateConfigs);
        this.emit('updateConfig', updateConfigs);
      }
    }
  }, {
    key: "getAttributeScale",
    value: function getAttributeScale(layer, name) {
      var attribute = layer.getAttribute(name);
      var scaleValue = {
        field: undefined,
        values: undefined,
        callback: undefined
      };

      if (attribute && attribute.scale) {
        var _attribute$scale = attribute.scale,
            field = _attribute$scale.field,
            values = _attribute$scale.values,
            callback = _attribute$scale.callback;
        scaleValue.field = field;
        scaleValue.values = values;
        scaleValue.callback = callback;
      }

      return scaleValue;
    }
  }]);

  return TileConfigManager;
}((eventemitter3__WEBPACK_IMPORTED_MODULE_8___default()));


//# sourceMappingURL=tileConfigManager.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/manager/tileLayerManager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/manager/tileLayerManager.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileLayerManager": function() { return /* binding */ TileLayerManager; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _tileFactory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tileFactory */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils */ "./node_modules/@antv/l7-layers/es/tile/utils.js");
/* harmony import */ var _tileConfigManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tileConfigManager */ "./node_modules/@antv/l7-layers/es/tile/manager/tileConfigManager.js");
/* harmony import */ var _tilePickerManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tilePickerManager */ "./node_modules/@antv/l7-layers/es/tile/manager/tilePickerManager.js");









var TileLayerManager = function () {
  function TileLayerManager(parent, mapService, rendererService, pickingService, layerService) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, TileLayerManager);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "sourceLayer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "parent", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "children", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "rendererService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tilePickManager", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tileConfigManager", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tileFactory", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "initOptions", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "rampColorsData", void 0);

    this.parent = parent;
    this.children = parent.layerChildren;
    this.mapService = mapService;
    this.rendererService = rendererService;
    this.tilePickManager = new _tilePickerManager__WEBPACK_IMPORTED_MODULE_5__.default(parent, rendererService, pickingService, this.children, layerService);
    this.tileConfigManager = new _tileConfigManager__WEBPACK_IMPORTED_MODULE_6__.default();
    this.setSubLayerInitOptipn();
    this.setConfigListener();
    this.initTileFactory();
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(TileLayerManager, [{
    key: "createTile",
    value: function createTile(tile) {
      return this.tileFactory.createTile(tile, this.initOptions);
    }
  }, {
    key: "updateLayersConfig",
    value: function updateLayersConfig(layers, key, value) {
      layers.map(function (layer) {
        if (key === 'mask') {
          layer.style({
            mask: value
          });
        } else {
          layer.updateLayerConfig((0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)({}, key, value));
        }
      });
    }
  }, {
    key: "addChild",
    value: function addChild(layer) {
      this.children.push(layer);
    }
  }, {
    key: "addChilds",
    value: function addChilds(layers) {
      var _this$children;

      (_this$children = this.children).push.apply(_this$children, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(layers));
    }
  }, {
    key: "removeChilds",
    value: function removeChilds(layerIDList) {
      var refresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var remveLayerList = [];
      var cacheLayerList = [];
      this.children.filter(function (child) {
        layerIDList.includes(child.id) ? remveLayerList.push(child) : cacheLayerList.push(child);
      });
      remveLayerList.map(function (layer) {
        return layer.destroy(refresh);
      });
      this.children = cacheLayerList;
    }
  }, {
    key: "removeChild",
    value: function removeChild(layer) {
      var layerIndex = this.children.indexOf(layer);

      if (layerIndex > -1) {
        this.children.splice(layerIndex, 1);
      }

      layer.destroy();
    }
  }, {
    key: "getChilds",
    value: function getChilds(layerIDList) {
      return this.children.filter(function (child) {
        return layerIDList.includes(child.id);
      });
    }
  }, {
    key: "getChild",
    value: function getChild(layerID) {
      return this.children.filter(function (child) {
        return child.id === layerID;
      })[0];
    }
  }, {
    key: "clearChild",
    value: function clearChild() {
      this.children.forEach(function (layer) {
        layer.destroy();
      });
      this.children.slice(0, this.children.length);
    }
  }, {
    key: "hasChild",
    value: function hasChild(layer) {
      return this.children.includes(layer);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$tileConfigManag, _this$tilePickManager;

      (_this$tileConfigManag = this.tileConfigManager) === null || _this$tileConfigManag === void 0 ? void 0 : _this$tileConfigManag.checkConfig(this.parent);
      (_this$tilePickManager = this.tilePickManager) === null || _this$tilePickManager === void 0 ? void 0 : _this$tilePickManager.normalRender(this.children);
    }
  }, {
    key: "pickLayers",
    value: function pickLayers(target) {
      var _this$tilePickManager2;

      return (_this$tilePickManager2 = this.tilePickManager) === null || _this$tilePickManager2 === void 0 ? void 0 : _this$tilePickManager2.pickRender(this.children, target);
    }
  }, {
    key: "setSubLayerInitOptipn",
    value: function setSubLayerInitOptipn() {
      var _source$data;

      var _ref = this.parent.getLayerConfig(),
          _ref$zIndex = _ref.zIndex,
          zIndex = _ref$zIndex === void 0 ? 0 : _ref$zIndex,
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
          _ref$mask = _ref.mask,
          mask = _ref$mask === void 0 ? false : _ref$mask,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$clampLow = _ref.clampLow,
          clampLow = _ref$clampLow === void 0 ? true : _ref$clampLow,
          _ref$clampHigh = _ref.clampHigh,
          clampHigh = _ref$clampHigh === void 0 ? true : _ref$clampHigh,
          _ref$domain = _ref.domain,
          domain = _ref$domain === void 0 ? [0, 1] : _ref$domain,
          _ref$rampColors = _ref.rampColors,
          rampColors = _ref$rampColors === void 0 ? {
        colors: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(245,245,245)', 'rgb(128,205,193)', 'rgb(1,133,113)'],
        positions: [0, 0.25, 0.5, 0.75, 1.0]
      } : _ref$rampColors,
          _ref$featureId = _ref.featureId,
          featureId = _ref$featureId === void 0 ? 'id' : _ref$featureId,
          sourceLayer = _ref.sourceLayer;

      var colorValue = this.tileConfigManager.getAttributeScale(this.parent, 'color');
      var sizeValue = this.tileConfigManager.getAttributeScale(this.parent, 'size');
      var source = this.parent.getSource();

      var _ref2 = (source === null || source === void 0 ? void 0 : (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.tilesetOptions) || {},
          coords = _ref2.coords;

      var layerShape = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.getLayerShape)(this.parent.type, this.parent);

      if (rampColors) {
        this.rampColorsData = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.generateColorRamp)(rampColors);
      }

      this.initOptions = {
        layerType: this.parent.type,
        shape: layerShape,
        zIndex: zIndex,
        opacity: opacity,
        sourceLayer: sourceLayer,
        coords: coords,
        featureId: featureId,
        color: colorValue,
        size: sizeValue,
        mask: (0,_utils__WEBPACK_IMPORTED_MODULE_7__.getMaskValue)(this.parent.type, mask),
        stroke: stroke,
        strokeWidth: strokeWidth,
        strokeOpacity: strokeOpacity,
        clampLow: clampLow,
        clampHigh: clampHigh,
        domain: domain,
        rampColors: rampColors,
        rampColorsData: this.rampColorsData
      };
    }
  }, {
    key: "setConfigListener",
    value: function setConfigListener() {
      var _this = this;

      this.tileConfigManager.setConfig('opacity', this.initOptions.opacity);
      this.tileConfigManager.setConfig('zIndex', this.initOptions.zIndex);
      this.tileConfigManager.setConfig('mask', this.initOptions.mask);

      if (this.parent.type === 'RasterLayer') {
        this.tileConfigManager.setConfig('rampColors', this.initOptions.rampColors);
        this.tileConfigManager.setConfig('domain', this.initOptions.domain);
        this.tileConfigManager.setConfig('clampHigh', this.initOptions.clampHigh);
        this.tileConfigManager.setConfig('clampLow', this.initOptions.clampLow);
      } else {
        var _this$parent$getAttri, _this$parent$getAttri2, _this$parent$getAttri3;

        this.tileConfigManager.setConfig('stroke', this.initOptions.stroke);
        this.tileConfigManager.setConfig('strokeWidth', this.initOptions.strokeWidth);
        this.tileConfigManager.setConfig('strokeOpacity', this.initOptions.strokeOpacity);
        this.tileConfigManager.setConfig('color', (_this$parent$getAttri = this.parent.getAttribute('color')) === null || _this$parent$getAttri === void 0 ? void 0 : _this$parent$getAttri.scale);
        this.tileConfigManager.setConfig('shape', (_this$parent$getAttri2 = this.parent.getAttribute('shape')) === null || _this$parent$getAttri2 === void 0 ? void 0 : _this$parent$getAttri2.scale);
        this.tileConfigManager.setConfig('size', (_this$parent$getAttri3 = this.parent.getAttribute('size')) === null || _this$parent$getAttri3 === void 0 ? void 0 : _this$parent$getAttri3.scale);
      }

      this.tileConfigManager.on('updateConfig', function (updateConfigs) {
        updateConfigs.map(function (key) {
          _this.updateStyle(key);

          return '';
        });
      });
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(style) {
      var _this2 = this;

      var updateValue = null;

      if (['size', 'color', 'shape'].includes(style)) {
        var _this$parent$getAttri4;

        var scaleValue = (_this$parent$getAttri4 = this.parent.getAttribute(style)) === null || _this$parent$getAttri4 === void 0 ? void 0 : _this$parent$getAttri4.scale;

        if (!scaleValue) {
          return;
        }

        updateValue = scaleValue;
        this.children.map(function (child) {
          _this2.tileFactory.setStyleAttributeField(child, style, scaleValue);

          return '';
        });
      } else {
        var layerConfig = this.parent.getLayerConfig();

        if (!(style in layerConfig)) {
          return;
        }

        var config = layerConfig[style];
        updateValue = config;
        this.updateLayersConfig(this.children, style, config);

        if (style === 'rampColors' && config) {
          this.rampColorsData = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.generateColorRamp)(config);
        }
      }

      this.initOptions[style] = updateValue;
    }
  }, {
    key: "initTileFactory",
    value: function initTileFactory() {
      var source = this.parent.getSource();
      var TileFactory = (0,_tileFactory__WEBPACK_IMPORTED_MODULE_8__.getTileFactory)(this.parent.type, source.parser);
      this.tileFactory = new TileFactory({
        parent: this.parent,
        mapService: this.mapService,
        rendererService: this.rendererService
      });
    }
  }]);

  return TileLayerManager;
}();
//# sourceMappingURL=tileLayerManager.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/manager/tilePickerManager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/manager/tilePickerManager.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TilePickManager; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_7__);








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var TilePickManager = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(TilePickManager, _EventEmitter);

  var _super = _createSuper(TilePickManager);

  function TilePickManager(parent, rendererService, pickingService, children, layerService) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, TilePickManager);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "isLastPicked", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "rendererService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "pickingService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "children", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parent", void 0);

    _this.parent = parent;
    _this.rendererService = rendererService;
    _this.pickingService = pickingService;
    _this.layerService = layerService;
    _this.children = children;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(TilePickManager, [{
    key: "normalRender",
    value: function normalRender(layers) {
      var _this2 = this;

      layers.filter(function (layer) {
        return layer.inited;
      }).filter(function (layer) {
        return layer.isVisible();
      }).map(function (layer) {
        layer.hooks.beforeRenderData.call();
        layer.hooks.beforeRender.call();

        if (layer.masks.length > 0) {
          _this2.rendererService.clear({
            stencil: 0,
            depth: 1,
            framebuffer: null
          });

          layer.masks.map(function (m) {
            m.hooks.beforeRender.call();
            m.render();
            m.hooks.afterRender.call();
          });
        }

        layer.render();
        layer.hooks.afterRender.call();
      });
    }
  }, {
    key: "pickRender",
    value: function pickRender(layers, target) {
      var _this3 = this;

      if (this.parent.type === 'RasterLayer') {
        this.renderMask(this.parent);
      }

      var isPicked = layers.filter(function (layer) {
        return _this3.parent.needPick(target.type) && layer.inited && layer.isVisible();
      }).some(function (layer) {
        layer.hooks.beforePickingEncode.call();

        if (layer.masks.length > 0) {
          _this3.rendererService.clear({
            stencil: 0,
            depth: 1,
            framebuffer: null
          });

          layer.masks.map(function (m) {
            m.hooks.beforeRender.call();
            m.render();
            m.hooks.afterRender.call();
          });
        }

        layer.renderModels(true);
        layer.hooks.afterPickingEncode.call();

        var layerPicked = _this3.pickingService.pickFromPickingFBO(layer, target);

        if (layerPicked && _this3.parent.type !== 'RasterLayer') {
          _this3.emit('pick', {
            type: target.type,
            pickedColors: _this3.pickingService.pickedColors,
            layer: layer
          });

          _this3.pickingService.pickedTileLayers = [_this3.parent];
        }

        return layerPicked;
      });

      if (this.parent.type !== 'RasterLayer' && !isPicked && this.isLastPicked && target.type !== 'click') {
        this.pickingService.pickedTileLayers = [];
        this.emit('unpick', {});
        this.beforeHighlight([0, 0, 0]);
      }

      this.isLastPicked = isPicked;
      return isPicked;
    }
  }, {
    key: "clearPick",
    value: function clearPick() {
      this.children.filter(function (child) {
        return child.inited && child.isVisible();
      }).map(function (layer) {
        layer.hooks.beforeSelect.call([0, 0, 0]);
      });
      this.pickingService.pickedTileLayers = [];
    }
  }, {
    key: "beforeHighlight",
    value: function beforeHighlight(pickedColors) {
      this.children.filter(function (child) {
        return child.inited && child.isVisible();
      }).map(function (child) {
        child.hooks.beforeHighlight.call(pickedColors);
      });
    }
  }, {
    key: "beforeSelect",
    value: function beforeSelect(pickedColors) {
      this.children.filter(function (child) {
        return child.inited && child.isVisible();
      }).map(function (layer) {
        layer.hooks.beforeSelect.call(pickedColors);
      });
    }
  }, {
    key: "renderMask",
    value: function renderMask(layer) {
      if (layer.inited && layer.isVisible()) {
        layer.hooks.beforeRender.call();

        if (layer.masks.length > 0) {
          this.rendererService.clear({
            stencil: 0,
            depth: 1,
            framebuffer: null
          });
          layer.masks.map(function (m) {
            m.hooks.beforeRender.call();
            m.render();
            m.hooks.afterRender.call();
          });
        }

        layer.hooks.afterRender.call();
      }
    }
  }]);

  return TilePickManager;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_7__.EventEmitter);


//# sourceMappingURL=tilePickerManager.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/models/tileModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/models/tileModel.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RasterTileModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _tmsTileLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tmsTileLayer */ "./node_modules/@antv/l7-layers/es/tile/tmsTileLayer.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var RasterTileModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(RasterTileModel, _BaseModel);

  var _super = _createSuper(RasterTileModel);

  function RasterTileModel() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RasterTileModel);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RasterTileModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      return {};
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this$layer$getSource;

      if ((_this$layer$getSource = this.layer.getSource()) !== null && _this$layer$getSource !== void 0 && _this$layer$getSource.data.isTile) {
        this.layer.tileLayer = new _tmsTileLayer__WEBPACK_IMPORTED_MODULE_5__.TMSTileLayer({
          parent: this.layer,
          rendererService: this.rendererService,
          mapService: this.mapService,
          layerService: this.layerService,
          pickingService: this.pickingService
        });
      }

      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return [];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {}
  }]);

  return RasterTileModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_6__.default);


//# sourceMappingURL=tileModel.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TileFactory; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _mask__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../mask */ "./node_modules/@antv/l7-layers/es/mask/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils */ "./node_modules/@antv/l7-layers/es/tile/utils.js");
/* harmony import */ var _vectorLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vectorLayer */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/vectorLayer.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");
/* harmony import */ var _turf_union__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @turf/union */ "./node_modules/@turf/union/dist/es/index.js");





function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









var TileFactory = function () {
  function TileFactory(option) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, TileFactory);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "type", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "parentLayer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "rendererService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "outSideEventTimer", null);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "zoomOffset", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tilesetManager", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "layers", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "eventCache", {
      click: 0,
      mousemove: 0,
      mouseup: 0,
      mousedown: 0,
      contextmenu: 0
    });

    this.parentLayer = option.parent;
    this.mapService = option.mapService;
    this.rendererService = option.rendererService;
    var source = this.parentLayer.getSource();
    this.zoomOffset = source.parser.zoomOffset || 0;
    this.tilesetManager = source.tileset;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(TileFactory, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      return {
        layers: [],
        layerIDList: []
      };
    }
  }, {
    key: "getFeatureData",
    value: function getFeatureData(tile, initOptions) {
      var emptyData = {
        features: [],
        featureId: null,
        vectorTileLayer: null,
        source: null
      };
      var sourceLayer = initOptions.sourceLayer,
          featureId = initOptions.featureId;

      if (!sourceLayer) {
        return emptyData;
      }

      var vectorTileLayer = tile.data.layers[sourceLayer];
      var features = vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.features;

      if (!(Array.isArray(features) && features.length > 0)) {
        return emptyData;
      } else {
        var source = new _antv_l7_source__WEBPACK_IMPORTED_MODULE_4__.default({
          type: 'FeatureCollection',
          features: features
        }, {
          parser: {
            type: 'geojson',
            featureId: featureId
          }
        });
        return {
          features: features,
          featureId: featureId,
          vectorTileLayer: vectorTileLayer,
          source: source
        };
      }
    }
  }, {
    key: "createLayer",
    value: function createLayer(tileLayerOption) {
      var L7Layer = tileLayerOption.L7Layer,
          tile = tileLayerOption.tile,
          initOptions = tileLayerOption.initOptions,
          vectorTileLayer = tileLayerOption.vectorTileLayer,
          source = tileLayerOption.source;
      var mask = initOptions.mask,
          color = initOptions.color,
          layerType = initOptions.layerType,
          size = initOptions.size,
          shape = initOptions.shape;
      var FactoryTileLayer = L7Layer ? L7Layer : _vectorLayer__WEBPACK_IMPORTED_MODULE_8__.default;
      var layer = new FactoryTileLayer(_objectSpread({
        visible: tile.isVisible,
        tileOrigin: vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.l7TileOrigin,
        coord: vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.l7TileCoord
      }, this.getLayerInitOption(initOptions)));

      if (layer.isVector) {
        this.emitEvent([layer]);
        layer.type = layerType;
        layer.select(true);
      }

      layer.source(source);
      this.setScale(layer);
      this.setStyleAttributeField(layer, 'shape', shape);
      this.setStyleAttributeField(layer, 'color', color);
      this.setStyleAttributeField(layer, 'size', size);
      var layers = [layer];

      if (mask && layer.isVector) {
        var masklayer = new _mask__WEBPACK_IMPORTED_MODULE_9__.default().source({
          type: 'FeatureCollection',
          features: [tile.bboxPolygon]
        }).shape('fill');
        layers.push(masklayer);
        layer.addMaskLayer(masklayer);
      }

      (0,_utils__WEBPACK_IMPORTED_MODULE_10__.registerLayers)(this.parentLayer, layers);
      this.layers = [layer];
      return layer;
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(styles) {
      return '';
    }
  }, {
    key: "getDefautStyleAttributeField",
    value: function getDefautStyleAttributeField(layer, type) {
      switch (type) {
        case 'size':
          return 2;

        case 'color':
          return '#fff';

        case 'shape':
          return (0,_utils__WEBPACK_IMPORTED_MODULE_10__.getLayerShape)(this.parentLayer.type, layer);

        default:
          return '';
      }
    }
  }, {
    key: "setStyleAttributeField",
    value: function setStyleAttributeField(layer, type, value) {
      if (Array.isArray(value)) {
        layer[type].apply(layer, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(value));
        return;
      }

      if (typeof value === 'string') {
        layer[type](value);
        return;
      }

      var defaultValue = this.getDefautStyleAttributeField(layer, type);

      if (!value) {
        layer[type](defaultValue);
        return layer;
      }

      var params = this.parseScaleValue(value, type);

      if (params.length === 0) {
        layer[type](defaultValue);
      } else {
        layer[type].apply(layer, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(params));
      }
    }
  }, {
    key: "parseScaleValue",
    value: function parseScaleValue(value, type) {
      if (type === 'shape') {
        if (typeof value === 'string') {
          return [value];
        } else if (value !== null && value !== void 0 && value.field) {
          return [value === null || value === void 0 ? void 0 : value.field];
        } else {
          return [];
        }
      }

      var _ref = value,
          field = _ref.field,
          values = _ref.values,
          callback = _ref.callback;

      if (field && values && Array.isArray(values)) {
        return [field, values];
      } else if (field && callback) {
        return [field, callback];
      } else if (field) {
        return [field];
      }

      return [];
    }
  }, {
    key: "getTile",
    value: function getTile(lng, lat) {
      var zoom = this.mapService.getZoom();
      var z = Math.ceil(zoom) + this.zoomOffset;
      var xy = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.osmLonLat2TileXY)(lng, lat, z);
      var tiles = this.tilesetManager.tiles.filter(function (t) {
        return t.key === "".concat(xy[0], ",").concat(xy[1], ",").concat(z);
      });
      var tile = tiles[0];
      return tile;
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(layers, isVector) {
      var _this = this;

      layers.map(function (layer) {
        layer.once('inited', function () {
          layer.on('click', function (e) {
            _this.eventCache.click = 1;

            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat = e.lngLat,
                  lng = _e$lngLat.lng,
                  lat = _e$lngLat.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerClick', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerClick', e);
            }
          });
          layer.on('mousemove', function (e) {
            _this.eventCache.mousemove = 1;

            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat2 = e.lngLat,
                  lng = _e$lngLat2.lng,
                  lat = _e$lngLat2.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e);
            }
          });
          layer.on('mouseup', function (e) {
            _this.eventCache.mouseup = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseUp', e);
          });
          layer.on('mouseenter', function (e) {
            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat3 = e.lngLat,
                  lng = _e$lngLat3.lng,
                  lat = _e$lngLat3.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseEnter', e);
            }
          });
          layer.on('mouseout', function (e) {
            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseOut', e);
          });
          layer.on('mousedown', function (e) {
            _this.eventCache.mousedown = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseDown', e);
          });
          layer.on('contextmenu', function (e) {
            _this.eventCache.contextmenu = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerContextmenu', e);
          });
          layer.on('unclick', function (e) {
            return _this.handleOutsideEvent('click', 'subLayerUnClick', layer, e);
          });
          layer.on('unmouseup', function (e) {
            return _this.handleOutsideEvent('mouseup', 'subLayerUnMouseUp', layer, e);
          });
          layer.on('unmousedown', function (e) {
            return _this.handleOutsideEvent('mousedown', 'subLayerUnMouseDown', layer, e);
          });
          layer.on('uncontextmenu', function (e) {
            return _this.handleOutsideEvent('contextmenu', 'subLayerUnContextmenu', layer, e);
          });
        });
      });
    }
  }, {
    key: "getCombineFeature",
    value: function getCombineFeature(features) {
      var p = null;
      var properties = features[0];
      features.map(function (feature) {
        var polygon = _turf_helpers__WEBPACK_IMPORTED_MODULE_6__.polygon(feature.coordinates);

        if (p === null) {
          p = polygon;
        }

        {
          p = (0,_turf_union__WEBPACK_IMPORTED_MODULE_7__.default)(p, polygon);
        }
      });

      if (properties) {
        p.properties = _objectSpread({}, properties);
      }

      return p;
    }
  }, {
    key: "getFeatureAndEmitEvent",
    value: function getFeatureAndEmitEvent(layer, eventName, e, isVector, tile) {
      if (isVector === false) {
        e.value = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.readRasterValue)(tile, this.mapService, e.x, e.y);
      } else {
        var featureId = e.featureId;
        var features = this.getAllFeatures(featureId);

        try {
          e.feature = this.getCombineFeature(features);
        } catch (err) {
          console.warn('Combine Featuer Err! Return First Feature!');
          e.feature = features[0];
        }
      }

      this.parentLayer.emit(eventName, e);
    }
  }, {
    key: "setScale",
    value: function setScale(layer) {
      var scaleOptions = this.parentLayer.tileLayer.scaleField;
      var scaleKeys = Object.keys(scaleOptions);
      scaleKeys.map(function (key) {
        layer.scale(key, scaleOptions[key]);
      });
    }
  }, {
    key: "getAllFeatures",
    value: function getAllFeatures(featureId) {
      var allLayers = this.parentLayer.tileLayer.children;
      var features = [];
      allLayers.map(function (layer) {
        var source = layer.getSource();
        source.data.dataArray.map(function (feature) {
          if (feature._id === featureId) {
            features.push(feature);
          }
        });
      });
      return features;
    }
  }, {
    key: "getLayerInitOption",
    value: function getLayerInitOption(initOptions) {
      var option = _objectSpread({}, initOptions);

      delete option.color;
      delete option.shape;
      delete option.size;
      delete option.coords;
      delete option.sourceLayer;
      delete option.coords;
      return option;
    }
  }, {
    key: "handleOutsideEvent",
    value: function handleOutsideEvent(type, emitType, layer, e) {
      var _this2 = this;

      if (this.outSideEventTimer) {
        clearTimeout(this.outSideEventTimer);
        this.outSideEventTimer = null;
      }

      this.outSideEventTimer = setTimeout(function () {
        if (_this2.eventCache[type] > 0) {
          _this2.eventCache[type] = 0;
        } else {
          _this2.getFeatureAndEmitEvent(layer, emitType, e);
        }
      }, 64);
    }
  }]);

  return TileFactory;
}();


//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTileFactory": function() { return /* binding */ getTileFactory; }
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/point.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygon */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/polygon.js");
/* harmony import */ var _raster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./raster */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/raster.js");
/* harmony import */ var _rasterData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rasterData */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterData.js");





function getTileFactory(tileType, parser) {
  switch (tileType) {
    case 'PolygonLayer':
      return _polygon__WEBPACK_IMPORTED_MODULE_0__.default;

    case 'LineLayer':
      return _line__WEBPACK_IMPORTED_MODULE_1__.default;

    case 'PointLayer':
      return _point__WEBPACK_IMPORTED_MODULE_2__.default;

    case 'RasterLayer':
      if (parser.dataType === 'arraybuffer') {
        return _rasterData__WEBPACK_IMPORTED_MODULE_3__.default;
      } else {
        return _raster__WEBPACK_IMPORTED_MODULE_4__.default;
      }

    default:
      console.warn('Current Tile Not Exist!');
      return _raster__WEBPACK_IMPORTED_MODULE_4__.default;
  }
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/line.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/line.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VectorPolygonTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var VectorPolygonTile = function (_TileFactory) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(VectorPolygonTile, _TileFactory);

  var _super = _createSuper(VectorPolygonTile);

  function VectorPolygonTile(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, VectorPolygonTile);

    _this = _super.call(this, option);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parentLayer", void 0);

    _this.parentLayer = option.parent;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(VectorPolygonTile, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      var _this$getFeatureData = this.getFeatureData(tile, initOptions),
          features = _this$getFeatureData.features,
          vectorTileLayer = _this$getFeatureData.vectorTileLayer,
          source = _this$getFeatureData.source;

      if (features.length === 0) {
        return {
          layers: [],
          layerIDList: []
        };
      }

      var layer = this.createLayer({
        tile: tile,
        initOptions: initOptions,
        vectorTileLayer: vectorTileLayer,
        source: source
      });
      return {
        layers: [layer],
        layerIDList: [layer.id]
      };
    }
  }]);

  return VectorPolygonTile;
}(_base__WEBPACK_IMPORTED_MODULE_7__.default);


//# sourceMappingURL=line.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/point.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/point.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VectorPolygonTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var VectorPolygonTile = function (_TileFactory) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(VectorPolygonTile, _TileFactory);

  var _super = _createSuper(VectorPolygonTile);

  function VectorPolygonTile(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, VectorPolygonTile);

    _this = _super.call(this, option);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parentLayer", void 0);

    _this.parentLayer = option.parent;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(VectorPolygonTile, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      var _this$getFeatureData = this.getFeatureData(tile, initOptions),
          features = _this$getFeatureData.features,
          vectorTileLayer = _this$getFeatureData.vectorTileLayer,
          source = _this$getFeatureData.source;

      if (features.length === 0) {
        return {
          layers: [],
          layerIDList: []
        };
      }

      var layer = this.createLayer({
        tile: tile,
        initOptions: initOptions,
        vectorTileLayer: vectorTileLayer,
        source: source
      });
      return {
        layers: [layer],
        layerIDList: [layer.id]
      };
    }
  }]);

  return VectorPolygonTile;
}(_base__WEBPACK_IMPORTED_MODULE_7__.default);


//# sourceMappingURL=point.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/polygon.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/polygon.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VectorPolygonTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var VectorPolygonTile = function (_TileFactory) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(VectorPolygonTile, _TileFactory);

  var _super = _createSuper(VectorPolygonTile);

  function VectorPolygonTile(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, VectorPolygonTile);

    _this = _super.call(this, option);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parentLayer", void 0);

    _this.parentLayer = option.parent;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(VectorPolygonTile, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      var _this$getFeatureData = this.getFeatureData(tile, initOptions),
          features = _this$getFeatureData.features,
          vectorTileLayer = _this$getFeatureData.vectorTileLayer,
          source = _this$getFeatureData.source;

      if (features.length === 0) {
        return {
          layers: [],
          layerIDList: []
        };
      }

      var layer = this.createLayer({
        tile: tile,
        initOptions: initOptions,
        vectorTileLayer: vectorTileLayer,
        source: source
      });
      return {
        layers: [layer],
        layerIDList: [layer.id]
      };
    }
  }]);

  return VectorPolygonTile;
}(_base__WEBPACK_IMPORTED_MODULE_7__.default);


//# sourceMappingURL=polygon.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/raster.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/raster.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RasterTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../image */ "./node_modules/@antv/l7-layers/es/image/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var RasterTile = function (_TileFactory) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(RasterTile, _TileFactory);

  var _super = _createSuper(RasterTile);

  function RasterTile(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RasterTile);

    _this = _super.call(this, option);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parentLayer", void 0);

    _this.parentLayer = option.parent;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RasterTile, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      var source = new _antv_l7_source__WEBPACK_IMPORTED_MODULE_7__.default(tile.data, {
        parser: {
          type: 'image',
          extent: tile.bounds
        }
      });
      var layer = this.createLayer({
        L7Layer: _image__WEBPACK_IMPORTED_MODULE_8__.default,
        tile: tile,
        initOptions: initOptions,
        source: source
      });
      return {
        layers: [layer],
        layerIDList: [layer.id]
      };
    }
  }]);

  return RasterTile;
}(_base__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=raster.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterData.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RasterTiffTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils */ "./node_modules/@antv/l7-layers/es/tile/utils.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/base.js");
/* harmony import */ var _rasterDataLayer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rasterDataLayer */ "./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterDataLayer.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var RasterTiffTile = function (_TileFactory) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(RasterTiffTile, _TileFactory);

  var _super = _createSuper(RasterTiffTile);

  function RasterTiffTile(option) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RasterTiffTile);

    _this = _super.call(this, option);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parentLayer", void 0);

    _this.parentLayer = option.parent;
    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RasterTiffTile, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      var opacity = initOptions.opacity,
          domain = initOptions.domain,
          clampHigh = initOptions.clampHigh,
          clampLow = initOptions.clampLow,
          rampColors = initOptions.rampColors,
          rampColorsData = initOptions.rampColorsData,
          mask = initOptions.mask;
      var rasterdata = tile.data;

      if (!rasterdata.data) {
        console.warn('raster data not exist!');
        return {
          layers: [],
          layerIDList: []
        };
      }

      var layer = new _rasterDataLayer__WEBPACK_IMPORTED_MODULE_7__.default({
        visible: tile.isVisible,
        mask: mask
      }).source(rasterdata.data, {
        parser: {
          type: 'raster',
          width: rasterdata.width,
          height: rasterdata.height,
          extent: tile.bboxPolygon.bbox
        }
      }).style({
        opacity: opacity,
        domain: domain,
        clampHigh: clampHigh,
        clampLow: clampLow,
        rampColors: rampColors,
        rampColorsData: rampColorsData
      });
      this.emitEvent([layer], false);
      (0,_utils__WEBPACK_IMPORTED_MODULE_8__.registerLayers)(this.parentLayer, [layer]);
      return {
        layers: [layer],
        layerIDList: [layer.id]
      };
    }
  }]);

  return RasterTiffTile;
}(_base__WEBPACK_IMPORTED_MODULE_9__.default);


//# sourceMappingURL=rasterData.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterDataLayer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/rasterDataLayer.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ RasterTiffLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _raster_models_raster__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../raster/models/raster */ "./node_modules/@antv/l7-layers/es/raster/models/raster.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var RasterTiffLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(RasterTiffLayer, _BaseLayer);

  var _super = _createSuper(RasterTiffLayer);

  function RasterTiffLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, RasterTiffLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", _this.layerType);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(RasterTiffLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var model = this.getModelType();
      this.layerModel = new model(this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return _raster_models_raster__WEBPACK_IMPORTED_MODULE_7__.default;
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {};
    }
  }]);

  return RasterTiffLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=rasterDataLayer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileFactory/vectorLayer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileFactory/vectorLayer.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ VectorLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _line_models_tile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../line/models/tile */ "./node_modules/@antv/l7-layers/es/line/models/tile.js");
/* harmony import */ var _point_models_text__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../point/models/text */ "./node_modules/@antv/l7-layers/es/point/models/text.js");
/* harmony import */ var _point_models_tile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../point/models/tile */ "./node_modules/@antv/l7-layers/es/point/models/tile.js");
/* harmony import */ var _polygon_models_tile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../polygon/models/tile */ "./node_modules/@antv/l7-layers/es/polygon/models/tile.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var VectorLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(VectorLayer, _BaseLayer);

  var _super = _createSuper(VectorLayer);

  function VectorLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, VectorLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "isVector", true);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", _this.layerType);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "pickedID", null);

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(VectorLayer, [{
    key: "getPickID",
    value: function getPickID() {
      return this.pickedID;
    }
  }, {
    key: "setPickID",
    value: function setPickID() {
      return this.pickedID;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var model = this.getModelType();
      this.layerModel = new model(this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      switch (this.layerType) {
        case 'PolygonLayer':
          return _polygon_models_tile__WEBPACK_IMPORTED_MODULE_7__.default;

        case 'LineLayer':
          return _line_models_tile__WEBPACK_IMPORTED_MODULE_8__.default;

        case 'PointLayer':
          return this.getPointModel();

        default:
          return _point_models_tile__WEBPACK_IMPORTED_MODULE_9__.default;
      }
    }
  }, {
    key: "getPointModel",
    value: function getPointModel() {
      var layerData = this.getEncodedData();

      var _this$getLayerConfig = this.getLayerConfig(),
          shape2d = _this$getLayerConfig.shape2d;

      var item = layerData.find(function (fe) {
        return fe.hasOwnProperty('shape');
      });

      if (item) {
        var shape = item.shape;

        if ((shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(shape)) !== -1) {
          return _point_models_tile__WEBPACK_IMPORTED_MODULE_9__.default;
        } else {
          return _point_models_text__WEBPACK_IMPORTED_MODULE_10__.default;
        }
      } else {
        return _point_models_tile__WEBPACK_IMPORTED_MODULE_9__.default;
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {};
    }
  }]);

  return VectorLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=vectorLayer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tileLayer/baseTileLayer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tileLayer/baseTileLayer.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BaseTileLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _manager_tileLayerManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manager/tileLayerManager */ "./node_modules/@antv/l7-layers/es/tile/manager/tileLayerManager.js");





function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var BaseTileLayer = function () {
  function BaseTileLayer(_ref) {
    var _parentSource$data;

    var parent = _ref.parent,
        rendererService = _ref.rendererService,
        mapService = _ref.mapService,
        layerService = _ref.layerService,
        pickingService = _ref.pickingService;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, BaseTileLayer);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "type", 'baseTile');

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "sourceLayer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "parent", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "initedTileset", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tilesetManager", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "tileLayerManager", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "scaleField", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "lastViewStates", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "timer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "pickColors", {
      select: null,
      active: null
    });

    var parentSource = parent.getSource();

    var _ref2 = (parentSource === null || parentSource === void 0 ? void 0 : (_parentSource$data = parentSource.data) === null || _parentSource$data === void 0 ? void 0 : _parentSource$data.tilesetOptions) || {},
        sourceLayer = _ref2.sourceLayer,
        coords = _ref2.coords,
        featureId = _ref2.featureId;

    this.sourceLayer = sourceLayer;
    this.parent = parent;
    this.mapService = mapService;
    this.layerService = layerService;
    this.tileLayerManager = new _manager_tileLayerManager__WEBPACK_IMPORTED_MODULE_5__.TileLayerManager(parent, mapService, rendererService, pickingService, layerService);
    this.initTileSetManager();
    this.bindSubLayerEvent();
    this.bindSubLayerPick();
    this.scaleField = this.parent.getScaleOptions();
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(BaseTileLayer, [{
    key: "children",
    get: function get() {
      return this.tileLayerManager.children;
    }
  }, {
    key: "render",
    value: function render() {
      if (this.tileLayerManager) {
        this.tileLayerManager.render();
      }
    }
  }, {
    key: "clearPick",
    value: function clearPick(type) {
      if (type === 'mousemove') {
        this.tileLayerManager.tilePickManager.clearPick();
      }
    }
  }, {
    key: "clearPickState",
    value: function clearPickState() {
      var _this = this;

      this.children.filter(function (child) {
        return child.inited && child.isVisible();
      }).filter(function (child) {
        return child.getCurrentSelectedId() !== null;
      }).map(function (child) {
        _this.selectFeature(child, new Uint8Array([0, 0, 0, 0]));

        child.setCurrentSelectedId(null);
      });
    }
  }, {
    key: "pickLayers",
    value: function pickLayers(target) {
      return this.tileLayerManager.pickLayers(target);
    }
  }, {
    key: "tileLoaded",
    value: function tileLoaded(tile) {}
  }, {
    key: "tileError",
    value: function tileError(error) {
      console.warn('error:', error);
    }
  }, {
    key: "tileUnLoad",
    value: function tileUnLoad(tile) {
      this.tileLayerManager.removeChilds(tile.layerIDList, false);
    }
  }, {
    key: "tileUpdate",
    value: function tileUpdate() {
      var _this2 = this;

      if (!this.tilesetManager) {
        return;
      }

      this.tilesetManager.tiles.filter(function (tile) {
        return tile.isLoaded;
      }).map(function (tile) {
        if (tile.layerIDList.length === 0) {
          var _this2$tileLayerManag = _this2.tileLayerManager.createTile(tile),
              layers = _this2$tileLayerManag.layers,
              layerIDList = _this2$tileLayerManag.layerIDList;

          tile.layerIDList = layerIDList;

          _this2.tileLayerManager.addChilds(layers);
        } else {
          if (!tile.isVisibleChange) {
            return;
          }

          var _layers = _this2.tileLayerManager.getChilds(tile.layerIDList);

          _this2.tileLayerManager.updateLayersConfig(_layers, 'visible', tile.isVisible);
        }
      });

      if (this.tilesetManager.isLoaded) {
        this.parent.emit('tiles-loaded', this.tilesetManager.currentTiles);
      }
    }
  }, {
    key: "setPickState",
    value: function setPickState(layers) {
      var _this3 = this;

      if (this.pickColors.select) {
        var selectedId = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.decodePickingColor)(this.pickColors.select);
        layers.map(function (layer) {
          _this3.selectFeature(layer, _this3.pickColors.select);

          layer.setCurrentSelectedId(selectedId);
        });
      }

      if (this.pickColors.active) {
        var _selectedId = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.decodePickingColor)(this.pickColors.active);

        layers.filter(function (layer) {
          return layer.inited && layer.isVisible();
        }).map(function (layer) {
          layer.hooks.beforeHighlight.call(_this3.pickColors.active);
          layer.setCurrentPickId(_selectedId);
        });
      }
    }
  }, {
    key: "bindSubLayerPick",
    value: function bindSubLayerPick() {
      var _this4 = this;

      this.tileLayerManager.tilePickManager.on('pick', function (e) {
        var _e$pickedColors = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(e.pickedColors, 3),
            r = _e$pickedColors[0],
            g = _e$pickedColors[1],
            b = _e$pickedColors[2];

        if (e.type === 'click') {
          var restLayers = _this4.children.filter(function (child) {
            return child.inited && child.isVisible() && child.isVector;
          }).filter(function (child) {
            return child !== e.layer;
          });

          _this4.setSelect(restLayers, [r, g, b]);
        } else {
          _this4.setHighlight([r, g, b]);
        }
      });
      this.tileLayerManager.tilePickManager.on('unpick', function () {
        _this4.pickColors.active = null;
      });
    }
  }, {
    key: "setHighlight",
    value: function setHighlight(pickedColors) {
      var pickId = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.decodePickingColor)(pickedColors);
      this.pickColors.active = pickedColors;
      this.children.filter(function (child) {
        return child.inited && child.isVisible() && child.isVector;
      }).filter(function (child) {
        return child.getPickID() !== pickId;
      }).map(function (child) {
        child.setPickID(pickId);
        child.hooks.beforeHighlight.call(pickedColors);
      });
    }
  }, {
    key: "setSelect",
    value: function setSelect(layers, pickedColors) {
      var _this5 = this;

      var selectedId = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_4__.decodePickingColor)(pickedColors);
      layers.map(function (layer) {
        if (layer.getCurrentSelectedId() === null || selectedId !== layer.getCurrentSelectedId()) {
          _this5.selectFeature(layer, pickedColors);

          layer.setCurrentSelectedId(selectedId);
          _this5.pickColors.select = pickedColors;
        } else {
          _this5.selectFeature(layer, new Uint8Array([0, 0, 0, 0]));

          layer.setCurrentSelectedId(null);
          _this5.pickColors.select = null;
        }
      });
      var renderList = this.layerService.getRenderList();
      renderList.filter(function (layer) {
        return layer.inited && !layer.isVector && layer.isVisible() && layer.needPick('click');
      }).filter(function (layer) {
        return layer.getCurrentSelectedId() !== null;
      }).map(function (layer) {
        _this5.selectFeature(layer, new Uint8Array([0, 0, 0, 0]));

        layer.setCurrentSelectedId(null);
      });
    }
  }, {
    key: "selectFeature",
    value: function selectFeature(layer, pickedColors) {
      var _pickedColors = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(pickedColors, 3),
          r = _pickedColors[0],
          g = _pickedColors[1],
          b = _pickedColors[2];

      layer.hooks.beforeSelect.call([r, g, b]);
    }
  }, {
    key: "bindSubLayerEvent",
    value: function bindSubLayerEvent() {
      var _this6 = this;

      this.parent.on('subLayerClick', function (e) {
        _this6.parent.emit('click', _objectSpread({}, e));
      });
      this.parent.on('subLayerMouseMove', function (e) {
        return _this6.parent.emit('mousemove', _objectSpread({}, e));
      });
      this.parent.on('subLayerMouseUp', function (e) {
        return _this6.parent.emit('mouseup', _objectSpread({}, e));
      });
      this.parent.on('subLayerMouseEnter', function (e) {
        return _this6.parent.emit('mouseenter', _objectSpread({}, e));
      });
      this.parent.on('subLayerMouseOut', function (e) {
        return _this6.parent.emit('mouseout', _objectSpread({}, e));
      });
      this.parent.on('subLayerMouseDown', function (e) {
        return _this6.parent.emit('mousedown', _objectSpread({}, e));
      });
      this.parent.on('subLayerContextmenu', function (e) {
        return _this6.parent.emit('contextmenu', _objectSpread({}, e));
      });
      this.parent.on('subLayerUnClick', function (e) {
        return _this6.parent.emit('unclick', _objectSpread({}, e));
      });
      this.parent.on('subLayerUnMouseMove', function (e) {
        return _this6.parent.emit('unmousemove', _objectSpread({}, e));
      });
      this.parent.on('subLayerUnMouseUp', function (e) {
        return _this6.parent.emit('unmouseup', _objectSpread({}, e));
      });
      this.parent.on('subLayerUnMouseDown', function (e) {
        return _this6.parent.emit('unmousedown', _objectSpread({}, e));
      });
      this.parent.on('subLayerUnContextmenu', function (e) {
        return _this6.parent.emit('uncontextmenu', _objectSpread({}, e));
      });
    }
  }, {
    key: "initTileSetManager",
    value: function initTileSetManager() {
      var _this$tilesetManager;

      var source = this.parent.getSource();
      this.tilesetManager = source.tileset;

      if (!this.initedTileset) {
        this.bindTilesetEvent();
        this.initedTileset = true;
      }

      var _this$getCurrentView = this.getCurrentView(),
          latLonBounds = _this$getCurrentView.latLonBounds,
          zoom = _this$getCurrentView.zoom;

      (_this$tilesetManager = this.tilesetManager) === null || _this$tilesetManager === void 0 ? void 0 : _this$tilesetManager.update(zoom, latLonBounds);
    }
  }, {
    key: "mapchange",
    value: function mapchange() {
      var _this$tilesetManager2;

      var _this$getCurrentView2 = this.getCurrentView(),
          latLonBounds = _this$getCurrentView2.latLonBounds,
          zoom = _this$getCurrentView2.zoom;

      if (this.mapService.version === 'GAODE1.x') {
        var _this$parent$getLayer = this.parent.getLayerConfig(),
            visible = _this$parent$getLayer.visible;

        if (zoom < 3 && visible) {
          this.parent.updateLayerConfig({
            visible: false
          });
          this.layerService.updateLayerRenderList();
        } else if (zoom >= 3 && !visible) {
          this.parent.updateLayerConfig({
            visible: true
          });
          this.layerService.updateLayerRenderList();
        }
      }

      if (this.lastViewStates && this.lastViewStates.zoom === zoom && this.lastViewStates.latLonBounds.toString() === latLonBounds.toString()) {
        return;
      }

      this.lastViewStates = {
        zoom: zoom,
        latLonBounds: latLonBounds
      };

      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }

      (_this$tilesetManager2 = this.tilesetManager) === null || _this$tilesetManager2 === void 0 ? void 0 : _this$tilesetManager2.update(zoom, latLonBounds);
    }
  }, {
    key: "bindTilesetEvent",
    value: function bindTilesetEvent() {
      var _this7 = this;

      if (!this.tilesetManager) {
        return;
      }

      this.tilesetManager.on('tile-loaded', function (tile) {});
      this.tilesetManager.on('tile-unload', function (tile) {
        _this7.tileUnLoad(tile);
      });
      this.tilesetManager.on('tile-error', function (error, tile) {
        _this7.tileError(error);
      });
      this.tilesetManager.on('tile-update', function () {
        _this7.tileUpdate();
      });
      this.mapService.on('zoomend', function () {
        return _this7.mapchange();
      });
      this.mapService.on('moveend', function () {
        return _this7.mapchange();
      });
    }
  }, {
    key: "getCurrentView",
    value: function getCurrentView() {
      var bounds = this.mapService.getBounds();
      var latLonBounds = [bounds[0][0], bounds[0][1], bounds[1][0], bounds[1][1]];
      var zoom = this.mapService.getZoom();
      return {
        latLonBounds: latLonBounds,
        zoom: zoom
      };
    }
  }]);

  return BaseTileLayer;
}();


//# sourceMappingURL=baseTileLayer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/tmsTileLayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/tmsTileLayer.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TMSTileLayer": function() { return /* binding */ TMSTileLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _tileLayer_baseTileLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tileLayer/baseTileLayer */ "./node_modules/@antv/l7-layers/es/tile/tileLayer/baseTileLayer.js");









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var TMSTileLayer = function (_BaseTileLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__.default)(TMSTileLayer, _BaseTileLayer);

  var _super = _createSuper(TMSTileLayer);

  function TMSTileLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, TMSTileLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__.default)(_this), "type", 'TMS');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(TMSTileLayer, [{
    key: "tileUnLoad",
    value: function tileUnLoad(tile) {
      this.tileLayerManager.removeChilds(tile.layerIDList, false);
    }
  }, {
    key: "tileUpdate",
    value: function tileUpdate() {
      var _this2 = this;

      if (!this.tilesetManager) {
        return;
      }

      this.tilesetManager.tiles.filter(function (tile) {
        return tile.isLoaded;
      }).map(function (tile) {
        var _tile$data;

        if ((_tile$data = tile.data) !== null && _tile$data !== void 0 && _tile$data.layers && _this2.sourceLayer) {
          var vectorTileLayer = tile.data.layers[_this2.sourceLayer];
          var features = vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.features;

          if (!(Array.isArray(features) && features.length > 0)) {
            return;
          }
        }

        if (!tile.parentLayerIDList.includes(_this2.parent.id)) {
          var _tile$layerIDList;

          var _this2$tileLayerManag = _this2.tileLayerManager.createTile(tile),
              layers = _this2$tileLayerManag.layers,
              layerIDList = _this2$tileLayerManag.layerIDList;

          tile.parentLayerIDList.push(_this2.parent.id);

          (_tile$layerIDList = tile.layerIDList).push.apply(_tile$layerIDList, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(layerIDList));

          _this2.tileLayerManager.addChilds(layers);

          _this2.setPickState(layers);
        } else {
          if (!tile.isVisibleChange) {
            return;
          }

          var _layers = _this2.tileLayerManager.getChilds(tile.layerIDList);

          _this2.tileLayerManager.updateLayersConfig(_layers, 'visible', tile.isVisible);

          _this2.setPickState(_layers);
        }
      });
      this.parent.renderLayers();

      if (this.tilesetManager.isLoaded) {
        this.parent.emit('tiles-loaded', this.tilesetManager.currentTiles);
      }
    }
  }]);

  return TMSTileLayer;
}(_tileLayer_baseTileLayer__WEBPACK_IMPORTED_MODULE_8__.default);
//# sourceMappingURL=tmsTileLayer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/tile/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/tile/utils.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerLayers": function() { return /* binding */ registerLayers; },
/* harmony export */   "getLayerShape": function() { return /* binding */ getLayerShape; },
/* harmony export */   "getMaskValue": function() { return /* binding */ getMaskValue; },
/* harmony export */   "getContainerSize": function() { return /* binding */ getContainerSize; },
/* harmony export */   "readRasterValue": function() { return /* binding */ readRasterValue; },
/* harmony export */   "readPixel": function() { return /* binding */ readPixel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");



function registerLayers(parentLayer, layers) {
  layers.map(function (layer) {
    var container = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.createLayerContainer)(parentLayer.sceneContainer);
    layer.setContainer(container, parentLayer.sceneContainer);
    layer.init();
  });
}
function getLayerShape(layerType, layer) {
  var _layerShape$scale;

  var layerShape = layer.getAttribute('shape');

  if (layerShape && (_layerShape$scale = layerShape.scale) !== null && _layerShape$scale !== void 0 && _layerShape$scale.field) {
    var _layerShape$scale2;

    if (((_layerShape$scale2 = layerShape.scale) === null || _layerShape$scale2 === void 0 ? void 0 : _layerShape$scale2.values) === 'text') {
      return [layerShape.scale.field, layerShape.scale.values];
    }

    return layerShape.scale.field;
  }

  switch (layerType) {
    case 'PolygonLayer':
      return 'fill';

    case 'LineLayer':
      return 'tileline';

    case 'PointLayer':
      return 'circle';

    case 'RasterLayer':
      return 'image';

    default:
      return '';
  }
}
function getMaskValue(layerType, mask) {
  switch (layerType) {
    case 'PolygonLayer':
      return true;

    case 'LineLayer':
      return true;

    case 'PointLayer':
      return false;

    case 'RasterLayer':
      return mask;

    default:
      return mask;
  }
}
function getContainerSize(container) {
  if (!!container.getContext) {
    return {
      width: container.width / _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR,
      height: container.height / _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR
    };
  } else {
    return container.getBoundingClientRect();
  }
}
function readRasterValue(tile, mapService, x, y) {
  var _tile$bboxPolygon, _tile$data, _tile$data2, _tile$data3;

  var bbox = (tile === null || tile === void 0 ? void 0 : (_tile$bboxPolygon = tile.bboxPolygon) === null || _tile$bboxPolygon === void 0 ? void 0 : _tile$bboxPolygon.bbox) || [0, 0, 10, -10];

  var _bbox = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(bbox, 4),
      _bbox$ = _bbox[0],
      minLng = _bbox$ === void 0 ? 0 : _bbox$,
      _bbox$2 = _bbox[1],
      minLat = _bbox$2 === void 0 ? 0 : _bbox$2,
      _bbox$3 = _bbox[2],
      maxLng = _bbox$3 === void 0 ? 10 : _bbox$3,
      _bbox$4 = _bbox[3],
      maxLat = _bbox$4 === void 0 ? -10 : _bbox$4;

  var tileXY = mapService.lngLatToContainer([minLng, minLat]);
  var tileMaxXY = mapService.lngLatToContainer([maxLng, maxLat]);
  var tilePixelWidth = tileMaxXY.x - tileXY.x;
  var tilePixelHeight = tileXY.y - tileMaxXY.y;
  var pos = [(x - tileXY.x) / tilePixelWidth, (y - tileMaxXY.y) / tilePixelHeight];
  var tileWidth = (tile === null || tile === void 0 ? void 0 : (_tile$data = tile.data) === null || _tile$data === void 0 ? void 0 : _tile$data.width) || 1;
  var tileHeight = (tile === null || tile === void 0 ? void 0 : (_tile$data2 = tile.data) === null || _tile$data2 === void 0 ? void 0 : _tile$data2.height) || 1;
  var indexX = Math.floor(pos[0] * tileWidth);
  var indexY = Math.floor(pos[1] * tileHeight);
  var index = Math.max(0, indexY - 1) * tileWidth + indexX;
  var data = tile === null || tile === void 0 ? void 0 : (_tile$data3 = tile.data) === null || _tile$data3 === void 0 ? void 0 : _tile$data3.data[index];
  return data;
}
function readPixel(x, y, rendererService) {
  var readPixels = rendererService.readPixels,
      getContainer = rendererService.getContainer;
  var xInDevicePixel = x * _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR;
  var yInDevicePixel = y * _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR;

  var _getContainerSize = getContainerSize(getContainer()),
      width = _getContainerSize.width,
      height = _getContainerSize.height;

  width *= _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR;
  height *= _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR;

  if (xInDevicePixel > width - 1 * _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR || yInDevicePixel < 0) {
    return false;
  }

  var pickedColors = readPixels({
    x: Math.floor(xInDevicePixel),
    y: Math.floor(height - (y + 1) * _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.DOM.DPR),
    width: 1,
    height: 1,
    data: new Uint8Array(1 * 1 * 4)
  });
  return pickedColors;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/blend.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/blend.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlendTypes": function() { return /* binding */ BlendTypes; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");


var _BlendTypes;


var BlendTypes = (_BlendTypes = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.additive, {
  enable: true,
  func: {
    srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    srcAlpha: 1,
    dstAlpha: 1
  }
}), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.none, {
  enable: false
}), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.normal, {
  enable: true,
  func: {
    srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_ALPHA,
    dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_ALPHA,
    srcAlpha: 1,
    dstAlpha: 1
  }
}), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.subtractive, {
  enable: true,
  func: {
    srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    srcAlpha: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ZERO,
    dstAlpha: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_COLOR
  },
  equation: {
    rgb: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_SUBTRACT,
    alpha: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_SUBTRACT
  }
}), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.max, {
  enable: true,
  func: {
    srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE
  },
  equation: {
    rgb: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.MAX_EXT
  }
}), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_BlendTypes, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType.min, {
  enable: true,
  func: {
    srcRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE,
    dstRGB: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE
  },
  equation: {
    rgb: _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.MIN_EXT
  }
}), _BlendTypes);
//# sourceMappingURL=blend.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/collision-index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/collision-index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ CollisionIndex; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _grid_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grid-index */ "./node_modules/@antv/l7-layers/es/utils/grid-index.js");







var CollisionIndex = function () {
  function CollisionIndex(width, height) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, CollisionIndex);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "width", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "height", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "grid", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "viewportPadding", 100);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "screenRightBoundary", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "screenBottomBoundary", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "gridRightBoundary", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "gridBottomBoundary", void 0);

    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    this.grid = new _grid_index__WEBPACK_IMPORTED_MODULE_4__.default(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(CollisionIndex, [{
    key: "placeCollisionBox",
    value: function placeCollisionBox(collisionBox) {
      var tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
      var tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
      var brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
      var brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;

      if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
        return {
          box: []
        };
      }

      return {
        box: [tlX, tlY, brX, brY]
      };
    }
  }, {
    key: "insertCollisionBox",
    value: function insertCollisionBox(box, featureIndex) {
      var key = {
        featureIndex: featureIndex
      };
      this.grid.insert(key, box[0], box[1], box[2], box[3]);
    }
  }, {
    key: "project",
    value: function project(mvpMatrix, x, y) {
      var point = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.fromValues(x, y, 0, 1);
      var out = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create();
      var mat = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.fromValues.apply(gl_matrix__WEBPACK_IMPORTED_MODULE_6__, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(mvpMatrix));
      gl_matrix__WEBPACK_IMPORTED_MODULE_5__.transformMat4(out, point, mat);
      return {
        x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
        y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
      };
    }
  }, {
    key: "isInsideGrid",
    value: function isInsideGrid(x1, y1, x2, y2) {
      return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
    }
  }]);

  return CollisionIndex;
}();


//# sourceMappingURL=collision-index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/dataMappingStyle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/dataMappingStyle.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleStyleDataMapping": function() { return /* binding */ handleStyleDataMapping; },
/* harmony export */   "handleStyleFloat": function() { return /* binding */ handleStyleFloat; },
/* harmony export */   "handleStyleColor": function() { return /* binding */ handleStyleColor; }
/* harmony export */ });
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js");
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__);



var WIDTH = 1024;

function registerStyleAttribute(fieldName, layer, field, values, updateOptions) {
  layer.updateStyleAttribute(fieldName, field, values, updateOptions);
}

function handleStyleDataMapping(configToUpdate, layer) {
  if (configToUpdate.opacity) {
    handleStyleFloat('opacity', layer, configToUpdate.opacity);
  }

  if (configToUpdate.strokeWidth) {
    handleStyleFloat('strokeWidth', layer, configToUpdate.strokeWidth);
  }

  if (configToUpdate.strokeOpacity) {
    handleStyleFloat('strokeOpacity', layer, configToUpdate.strokeOpacity);
  }

  if (configToUpdate.stroke) {
    handleStyleColor('stroke', layer, configToUpdate.stroke);
  }

  if (configToUpdate.offsets) {
    handleStyleOffsets('offsets', layer, configToUpdate.offsets);
  }

  if (configToUpdate.textOffset) {
    handleStyleOffsets('textOffset', layer, configToUpdate.textOffset);
  }

  if (configToUpdate.thetaOffset) {
    handleStyleFloat('thetaOffset', layer, configToUpdate.thetaOffset);
  }
}

function handleStyleFloat(fieldName, layer, styleFloat) {
  if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleFloat)) {
    registerStyleAttribute(fieldName, layer, styleFloat, function (value) {
      return value;
    });
  } else if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default()(styleFloat)) {
    registerStyleAttribute(fieldName, layer, [styleFloat], undefined);
  } else if (Array.isArray(styleFloat) && styleFloat.length === 2) {
    if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleFloat[0]) && lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(styleFloat[1])) {
      registerStyleAttribute(fieldName, layer, styleFloat[0], styleFloat[1]);
    } else if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleFloat[0]) && Array.isArray(styleFloat[1]) && lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default()(styleFloat[1][0]) && lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default()(styleFloat[1][1])) {
      registerStyleAttribute(fieldName, layer, styleFloat[0], styleFloat[1]);
    } else {
      registerStyleAttribute(fieldName, layer, [1.0], undefined);
    }
  } else {
    registerStyleAttribute(fieldName, layer, [1.0], undefined);
  }
}

function handleStyleOffsets(fieldName, layer, styleOffsets) {
  if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleOffsets)) {
    registerStyleAttribute(fieldName, layer, styleOffsets, function (value) {
      return value;
    });
  } else if (Array.isArray(styleOffsets) && styleOffsets.length === 2 && lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleOffsets[0]) && lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(styleOffsets[1])) {
    registerStyleAttribute(fieldName, layer, styleOffsets[0], styleOffsets[1]);
  } else if (Array.isArray(styleOffsets) && styleOffsets.length === 2 && lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default()(styleOffsets[0]) && lodash_isNumber__WEBPACK_IMPORTED_MODULE_1___default()(styleOffsets[1])) {
    registerStyleAttribute(fieldName, layer, styleOffsets, undefined);
  } else {
    registerStyleAttribute(fieldName, layer, [0, 0], undefined);
  }
}

function handleStyleColor(fieldName, layer, styleColor) {
  if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleColor)) {
    registerStyleAttribute(fieldName, layer, styleColor, undefined);
  } else if (Array.isArray(styleColor) && styleColor.length === 2) {
    if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleColor[0]) && lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(styleColor[1])) {
      registerStyleAttribute(fieldName, layer, styleColor[0], styleColor[1]);
    } else if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(styleColor[0]) && Array.isArray(styleColor[1]) && styleColor[1].length > 0) {
      registerStyleAttribute(fieldName, layer, styleColor[0], styleColor[1]);
    } else {
      registerStyleAttribute(fieldName, layer, '#fff', undefined);
    }
  } else {
    registerStyleAttribute(fieldName, layer, '#fff', undefined);
  }
}


//# sourceMappingURL=dataMappingStyle.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/extrude_polyline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/extrude_polyline.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeMiter": function() { return /* binding */ computeMiter; },
/* harmony export */   "computeNormal": function() { return /* binding */ computeNormal; },
/* harmony export */   "direction": function() { return /* binding */ direction; },
/* harmony export */   "default": function() { return /* binding */ ExtrudePolyline; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec2.js");







var tmp = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
var capEnd = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
var lineA = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
var lineB = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
var tangent = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
function computeMiter(lineTangent, miter, start, end, halfThick) {
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(lineTangent, start, end);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__.normalize(lineTangent, lineTangent);
  miter = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.fromValues(-lineTangent[1], lineTangent[0]);
  var tmpvec = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.fromValues(-start[1], start[0]);
  return [halfThick / gl_matrix__WEBPACK_IMPORTED_MODULE_6__.dot(miter, tmpvec), miter];
}
function computeNormal(out, dir) {
  return gl_matrix__WEBPACK_IMPORTED_MODULE_6__.set(out, -dir[1], dir[0]);
}
function direction(out, a, b) {
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__.sub(out, a, b);
  gl_matrix__WEBPACK_IMPORTED_MODULE_6__.normalize(out, out);
  return out;
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function getArrayUnique(matrix) {
  var map = new Map();

  for (var i = 0; i < matrix.length; i++) {
    var key = matrix[0].toString() + '-' + matrix[1].toString();

    if (map.get(key)) {
      matrix.splice(i, 1);
      i++;
    } else {
      map.set(key, key);
    }
  }

  return matrix;
}

var ExtrudePolyline = function () {
  function ExtrudePolyline() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, ExtrudePolyline);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "complex", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "join", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "cap", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "miterLimit", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "thickness", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "normal", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "lastFlip", -1);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "miter", gl_matrix__WEBPACK_IMPORTED_MODULE_6__.fromValues(0, 0));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "started", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "dash", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "totalDistance", 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__.default)(this, "currentIndex", 0);

    this.join = opts.join || 'miter';
    this.cap = opts.cap || 'butt';
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0,
      indexes: []
    };
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(ExtrudePolyline, [{
    key: "extrude_gaode2",
    value: function extrude_gaode2(points, originPoints) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var _originPoints$, _originPoints$i$, _originPoints$2;

        var last = points[i - 1];
        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.segment_gaode2(complex, count, last, cur, next, originLast, originCur, originNext);
        count += amt;
      }

      if (this.dash) {
        for (var _i = 0; _i < complex.positions.length / 6; _i++) {
          complex.positions[_i * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleExtrude_gaode2",
    value: function simpleExtrude_gaode2(points, originPoints) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var _originPoints$3, _originPoints$i$2, _originPoints$4;

        var last = points[i - 1];
        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.simpleSegment(complex, count, last, cur, next, originLast, originCur, originNext);
        count += amt;
      }

      if (this.dash) {
        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {
          complex.positions[_i2 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "extrude",
    value: function extrude(points) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.segment(complex, count, last, cur, next);
        count += amt;
      }

      if (this.dash) {
        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {
          complex.positions[_i3 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleExtrude",
    value: function simpleExtrude(points) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.simpleSegment(complex, count, last, cur, next);
        count += amt;
      }

      if (this.dash) {
        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {
          complex.positions[_i4 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "segment_gaode2",
    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur, originNext) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([originCur[0], originCur[1]]);
      var flatLast = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([originLast[0], originLast[1]]);
      direction(lineA, cur, last);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;

        if (capSquare) {
          var out1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
          var out2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(out1, this.normal, lineA);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);

        if (capSquare) {
          var _out = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();

          var _out2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();

          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.sub(_out2, lineA, this.normal);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(_out, lineA, this.normal);
          normals.push(_out2[0], _out2[1], 0);
          normals.push(_out[0], _out[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        if (isPointEqual(cur, next)) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(next, cur, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.normalize(next, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.subtract(next, cur, last)));
        }

        direction(lineB, next, cur);

        var _computeMiter = computeMiter(tangent, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create(), lineA, lineB, this.thickness),
            _computeMiter2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_computeMiter, 2),
            miterLen = _computeMiter2[0],
            miter = _computeMiter2[1];

        var flip = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;

        if (!bevel && this.join === 'miter') {
          var limit = miterLen;

          if (limit > this.miterLimit) {
            bevel = true;
          }
        }

        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.copy(this.normal, tmp);
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.copy(this.normal, miter);
          count += 2;
        }

        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "simpleSegment",
    value: function simpleSegment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var flatCur = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;
        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);
        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([next[0], next[1]]);

        if (isPointEqual(flatCur, flatNext)) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(flatNext, flatCur, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.normalize(flatNext, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.subtract(flatNext, flatCur, flatLast)));
        }

        direction(lineB, flatNext, flatCur);

        var _computeMiter3 = computeMiter(tangent, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create(), lineA, lineB, this.thickness),
            _computeMiter4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_computeMiter3, 2),
            miterLen = _computeMiter4[0],
            miter = _computeMiter4[1];

        var flip = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.dot(tangent, this.normal) < 0 ? -1 : 1;
        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
        indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        flip = -1;
        gl_matrix__WEBPACK_IMPORTED_MODULE_6__.copy(this.normal, miter);
        count += 2;
        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "segment",
    value: function segment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;

        if (capSquare) {
          var out1 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
          var out2 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(out1, this.normal, lineA);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);

        if (capSquare) {
          var _out3 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();

          var _out4 = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create();

          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.sub(_out4, lineA, this.normal);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(_out3, lineA, this.normal);
          normals.push(_out4[0], _out4[1], 0);
          normals.push(_out3[0], _out3[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.aProjectFlat)([next[0], next[1]]);

        if (isPointEqual(flatCur, flatNext)) {
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.add(flatNext, flatCur, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.normalize(flatNext, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.subtract(flatNext, flatCur, flatLast)));
        }

        direction(lineB, flatNext, flatCur);

        var _computeMiter5 = computeMiter(tangent, gl_matrix__WEBPACK_IMPORTED_MODULE_6__.create(), lineA, lineB, this.thickness),
            _computeMiter6 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_computeMiter5, 2),
            miterLen = _computeMiter6[0],
            miter = _computeMiter6[1];

        var flip = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;

        if (!bevel && this.join === 'miter') {
          var limit = miterLen;

          if (limit > this.miterLimit) {
            bevel = true;
          }
        }

        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.copy(this.normal, tmp);
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;
          gl_matrix__WEBPACK_IMPORTED_MODULE_6__.copy(this.normal, miter);
          count += 2;
        }

        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "extrusions",
    value: function extrusions(positions, normals, point, normal, thickness, distanceRadio) {
      normals.push(normal[0], normal[1], 0);
      normals.push(normal[0], normal[1], 0);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      this.currentIndex++;
    }
  }, {
    key: "lineSegmentDistance",
    value: function lineSegmentDistance(b1, a1) {
      var dx = a1[0] - b1[0];
      var dy = a1[1] - b1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);

  return ExtrudePolyline;
}();


//# sourceMappingURL=extrude_polyline.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/geo.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/geo.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateCentroid": function() { return /* binding */ calculateCentroid; },
/* harmony export */   "calculatePointsCenterAndRadius": function() { return /* binding */ calculatePointsCenterAndRadius; }
/* harmony export */ });
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_0__);

function calculateCentroid(coord) {
  if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_0___default()(coord[0])) {
    return coord;
  } else if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_0___default()(coord[0][0])) {
    throw new Error('');
  } else if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_0___default()(coord[0][0][0])) {
    var coords = coord;
    var xSum = 0;
    var ySum = 0;
    var len = 0;
    coords.forEach(function (coor) {
      coor.forEach(function (pos) {
        xSum += pos[0];
        ySum += pos[1];
        len++;
      });
    });
    return [xSum / len, ySum / len, 0];
  } else {
    throw new Error('');
  }
}
function calculatePointsCenterAndRadius(points) {
  var maxX = points[0];
  var maxY = points[1];
  var minX = points[0];
  var minY = points[1];
  var xCount = 0;
  var yCount = 0;
  var pCount = 0;

  for (var i = 0; i < points.length; i += 2) {
    var x = points[i];
    var y = points[i + 1];

    if (x && y) {
      maxX = Math.max(x, maxX);
      maxY = Math.max(y, maxY);
      minX = Math.min(x, minX);
      minY = Math.min(y, minY);
      xCount += x;
      yCount += y;
      pCount++;
    }
  }

  return {
    center: [xCount / pCount, yCount / pCount],
    radius: Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) / 2
  };
}
//# sourceMappingURL=geo.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/grid-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/grid-index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");




function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var GridIndex = function () {
  function GridIndex(width, height, cellSize) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, GridIndex);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "boxCells", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "xCellCount", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "yCellCount", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "boxKeys", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "bboxes", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "width", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "height", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "xScale", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "yScale", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "boxUid", void 0);

    var boxCells = this.boxCells;
    this.xCellCount = Math.ceil(width / cellSize);
    this.yCellCount = Math.ceil(height / cellSize);

    for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {
      boxCells.push([]);
    }

    this.boxKeys = [];
    this.bboxes = [];
    this.width = width;
    this.height = height;
    this.xScale = this.xCellCount / width;
    this.yScale = this.yCellCount / height;
    this.boxUid = 0;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(GridIndex, [{
    key: "insert",
    value: function insert(key, x1, y1, x2, y2) {
      this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);
      this.boxKeys.push(key);
      this.bboxes.push(x1);
      this.bboxes.push(y1);
      this.bboxes.push(x2);
      this.bboxes.push(y2);
    }
  }, {
    key: "query",
    value: function query(x1, y1, x2, y2, predicate) {
      return this.queryHitTest(x1, y1, x2, y2, false, predicate);
    }
  }, {
    key: "hitTest",
    value: function hitTest(x1, y1, x2, y2, predicate) {
      return this.queryHitTest(x1, y1, x2, y2, true, predicate);
    }
  }, {
    key: "insertBoxCell",
    value: function insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {
      this.boxCells[cellIndex].push(uid);
    }
  }, {
    key: "queryHitTest",
    value: function queryHitTest(x1, y1, x2, y2, hitTest, predicate) {
      if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
        return hitTest ? false : [];
      }

      var result = [];

      if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
        if (hitTest) {
          return true;
        }

        for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
          result.push({
            key: this.boxKeys[boxUid],
            x1: this.bboxes[boxUid * 4],
            y1: this.bboxes[boxUid * 4 + 1],
            x2: this.bboxes[boxUid * 4 + 2],
            y2: this.bboxes[boxUid * 4 + 3]
          });
        }

        return predicate ? result.filter(predicate) : result;
      }

      var queryArgs = {
        hitTest: hitTest,
        seenUids: {
          box: {},
          circle: {}
        }
      };
      this.forEachCell(x1, y1, x2, y2, this.queryCell, result, queryArgs, predicate);
      return hitTest ? result.length > 0 : result;
    }
  }, {
    key: "queryCell",
    value: function queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
      var seenUids = queryArgs.seenUids;
      var boxCell = this.boxCells[cellIndex];

      if (boxCell !== null) {
        var bboxes = this.bboxes;

        var _iterator = _createForOfIteratorHelper(boxCell),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var boxUid = _step.value;

            if (!seenUids.box[boxUid]) {
              seenUids.box[boxUid] = true;
              var offset = boxUid * 4;

              if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {
                if (queryArgs.hitTest) {
                  result.push(true);
                  return true;
                }

                result.push({
                  key: this.boxKeys[boxUid],
                  x1: bboxes[offset],
                  y1: bboxes[offset + 1],
                  x2: bboxes[offset + 2],
                  y2: bboxes[offset + 3]
                });
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return false;
    }
  }, {
    key: "forEachCell",
    value: function forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {
      var cx1 = this.convertToXCellCoord(x1);
      var cy1 = this.convertToYCellCoord(y1);
      var cx2 = this.convertToXCellCoord(x2);
      var cy2 = this.convertToYCellCoord(y2);

      for (var x = cx1; x <= cx2; x++) {
        for (var y = cy1; y <= cy2; y++) {
          var cellIndex = this.xCellCount * y + x;

          if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {
            return;
          }
        }
      }
    }
  }, {
    key: "convertToXCellCoord",
    value: function convertToXCellCoord(x) {
      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));
    }
  }, {
    key: "convertToYCellCoord",
    value: function convertToYCellCoord(y) {
      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));
    }
  }]);

  return GridIndex;
}();

/* harmony default export */ __webpack_exports__["default"] = (GridIndex);
//# sourceMappingURL=grid-index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/layerData.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/layerData.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateData": function() { return /* binding */ calculateData; }
/* harmony export */ });
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/version.js");
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");




function getArrowPoints(p1, p2) {
  var dir = [p2[0] - p1[0], p2[1] - p1[1]];
  var normalizeDir = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.normalize)(dir);
  var arrowPoint = [p1[0] + normalizeDir[0] * 0.0001, p1[1] + normalizeDir[1] * 0.0001];
  return arrowPoint;
}

function adjustData2Amap2Coordinates(mappedData, mapService) {
  var _this = this;

  if (mappedData.length > 0 && mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_2__.Version["GAODE2.x"]) {
    if (typeof mappedData[0].coordinates[0] === 'number') {
      mappedData.filter(function (d) {
        return !d.originCoordinates;
      }).map(function (d) {
        d.version = _antv_l7_maps__WEBPACK_IMPORTED_MODULE_2__.Version["GAODE2.x"];
        d.originCoordinates = cloneDeep(d.coordinates);
        d.coordinates = _this.mapService.lngLatToCoord(d.coordinates);
      });
    } else {
      mappedData.filter(function (d) {
        return !d.originCoordinates;
      }).map(function (d) {
        d.version = _antv_l7_maps__WEBPACK_IMPORTED_MODULE_2__.Version["GAODE2.x"];
        d.originCoordinates = cloneDeep(d.coordinates);
        d.coordinates = _this.mapService.lngLatToCoords(d.coordinates);
      });
    }
  }
}

function adjustData2SimpleCoordinates(mappedData, mapService) {
  if (mappedData.length > 0 && mapService.version === _antv_l7_maps__WEBPACK_IMPORTED_MODULE_2__.Version.SIMPLE) {
    mappedData.map(function (d) {
      if (!d.simpleCoordinate) {
        d.coordinates = unProjectCoordinates(d.coordinates, mapService);
        d.simpleCoordinate = true;
      }
    });
  }
}

function unProjectCoordinates(coordinates, mapService) {
  if (typeof coordinates[0] === 'number') {
    return mapService.simpleMapCoord.unproject(coordinates);
  }

  if (coordinates[0] && coordinates[0][0] instanceof Array) {
    var coords = [];
    coordinates.map(function (coord) {
      var c1 = [];
      coord.map(function (co) {
        c1.push(mapService.simpleMapCoord.unproject(co));
      });
      coords.push(c1);
    });
    return coords;
  } else {
    var _coords = [];
    coordinates.map(function (coord) {
      _coords.push(mapService.simpleMapCoord.unproject(coord));
    });
    return _coords;
  }
}

function applyAttributeMapping(attribute, record, minimumColor) {
  var _attribute$scale;

  if (!attribute.scale) {
    return [];
  }

  var scalers = (attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers) || [];
  var params = [];
  scalers.forEach(function (_ref) {
    var _attribute$scale2;

    var field = _ref.field;

    if (record.hasOwnProperty(field) || ((_attribute$scale2 = attribute.scale) === null || _attribute$scale2 === void 0 ? void 0 : _attribute$scale2.type) === 'variable') {
      params.push(record[field]);
    }
  });
  var mappingResult = attribute.mapping ? attribute.mapping(params) : [];

  if (attribute.name === 'color' && !(0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.isColor)(mappingResult[0])) {
    return [minimumColor];
  }

  return mappingResult;
}

function mapping(attributes, data, fontService, mapService, minimumColor, layer) {
  var _ref2 = layer === null || layer === void 0 ? void 0 : layer.getLayerConfig(),
      _ref2$arrow = _ref2.arrow,
      arrow = _ref2$arrow === void 0 ? {
    enable: false
  } : _ref2$arrow;

  var mappedData = data.map(function (record) {
    var encodeRecord = {
      id: record._id,
      coordinates: record.coordinates
    };
    attributes.filter(function (attribute) {
      return attribute.scale !== undefined;
    }).forEach(function (attribute) {
      var values = applyAttributeMapping(attribute, record, minimumColor);
      attribute.needRemapping = false;

      if (attribute.name === 'color') {
        values = values.map(function (c) {
          return (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_1__.rgb2arr)(c);
        });
      }

      encodeRecord[attribute.name] = Array.isArray(values) && values.length === 1 ? values[0] : values;

      if (attribute.name === 'shape') {
        encodeRecord.shape = fontService.getIconFontKey(encodeRecord[attribute.name]);
      }
    });

    if (encodeRecord.shape === 'line' && arrow.enable) {
      var coords = encodeRecord.coordinates;
      var arrowPoint = getArrowPoints(coords[0], coords[1]);
      encodeRecord.coordinates.splice(1, 0, arrowPoint, arrowPoint);
    }

    return encodeRecord;
  });
  adjustData2Amap2Coordinates(mappedData, mapService);
  adjustData2SimpleCoordinates(mappedData, mapService);
  return mappedData;
}

function calculateData(layer, fontService, mapService, styleAttributeService, data, options) {
  var source = new _antv_l7_source__WEBPACK_IMPORTED_MODULE_0__.default(data, options);
  var bottomColor = layer.getBottomColor();
  var attributes = styleAttributeService.getLayerStyleAttributes() || [];
  var dataArray = source.data.dataArray;
  var filterData = dataArray;
  var mappedEncodeData = mapping(attributes, filterData, fontService, mapService, bottomColor, layer);
  source.destroy();
  return mappedEncodeData;
}
//# sourceMappingURL=layerData.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/multiPassRender.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/multiPassRender.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizePasses": function() { return /* binding */ normalizePasses; },
/* harmony export */   "createMultiPassRenderer": function() { return /* binding */ createMultiPassRenderer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");

function normalizePasses(passes) {
  return passes.map(function (pass) {
    if (typeof pass === 'string') {
      pass = [pass, {}];
    }

    return pass;
  });
}
function createMultiPassRenderer(layer, passes, postProcessingPassFactory, normalPassFactory) {
  var multiPassRenderer = layer.multiPassRenderer;

  var _layer$getLayerConfig = layer.getLayerConfig(),
      enablePicking = _layer$getLayerConfig.enablePicking,
      enableTAA = _layer$getLayerConfig.enableTAA;

  if (enableTAA) {
    multiPassRenderer.add(normalPassFactory('taa'));
  } else {
    multiPassRenderer.add(normalPassFactory('render'));
  }

  normalizePasses(passes).forEach(function (pass) {
    var _pass = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(pass, 2),
        passName = _pass[0],
        initializationOptions = _pass[1];

    multiPassRenderer.add(postProcessingPassFactory(passName), initializationOptions);
  });
  multiPassRenderer.add(postProcessingPassFactory('copy'));
  return multiPassRenderer;
}
//# sourceMappingURL=multiPassRender.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/symbol-layout.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/symbol-layout.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shapeText": function() { return /* binding */ shapeText; },
/* harmony export */   "getGlyphQuads": function() { return /* binding */ getGlyphQuads; }
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function getAnchorAlignment(anchor) {
  var horizontalAlign = 0.5;
  var verticalAlign = 0.5;

  switch (anchor) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
      horizontalAlign = 1;
      break;

    case 'left':
    case 'top-left':
    case 'bottom-left':
      horizontalAlign = 0;
      break;

    default:
      horizontalAlign = 0.5;
  }

  switch (anchor) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
      verticalAlign = 1;
      break;

    case 'top':
    case 'top-right':
    case 'top-left':
      verticalAlign = 0;
      break;

    default:
      verticalAlign = 0.5;
  }

  return {
    horizontalAlign: horizontalAlign,
    verticalAlign: verticalAlign
  };
}

function justifyLine(positionedGlyphs, glyphMap, start, end, justify) {
  if (!justify) {
    return;
  }

  var lastPositionedGlyph = positionedGlyphs[end];
  var glyph = lastPositionedGlyph.glyph;

  if (glyph) {
    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
      positionedGlyphs[j].x -= lineIndent;
    }
  }
}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {
  var shiftX = (justify - horizontalAlign) * maxLineLength;
  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;

  var _iterator = _createForOfIteratorHelper(positionedGlyphs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var glyphs = _step.value;
      glyphs.x += shiftX;
      glyphs.y += shiftY;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {
  var yOffset = -8;
  var x = 0;
  var y = yOffset;
  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;
  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
  var lineStartIndex = positionedGlyphs.length;
  lines.forEach(function (line) {
    line.split('').forEach(function (char) {
      var glyph = glyphMap[char];
      var baselineOffset = 0;

      if (glyph) {
        positionedGlyphs.push({
          glyph: char,
          x: x,
          y: y + baselineOffset,
          vertical: false,
          scale: 1,
          metrics: glyph
        });
        x += glyph.advance + spacing;
      }
    });

    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }

    x = 0;
    y -= lineHeight + 5;
  });

  var _getAnchorAlignment = getAnchorAlignment(textAnchor),
      horizontalAlign = _getAnchorAlignment.horizontalAlign,
      verticalAlign = _getAnchorAlignment.verticalAlign;

  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);
  var height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}

function shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {
  var yOffset = -8;
  var x = 0;
  var y = yOffset;
  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;
  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
  var lineStartIndex = positionedGlyphs.length;
  iconfonts.forEach(function (iconfont) {
    var glyph = glyphMap[iconfont];
    var baselineOffset = 0;

    if (glyph) {
      positionedGlyphs.push({
        glyph: iconfont,
        x: glyph.advance / 2,
        y: y + baselineOffset,
        vertical: false,
        scale: 1,
        metrics: glyph
      });
      x += glyph.advance + spacing;
    }

    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }

    x = 0;
    y -= lineHeight + 5;
  });

  var _getAnchorAlignment2 = getAnchorAlignment(textAnchor),
      horizontalAlign = _getAnchorAlignment2.horizontalAlign,
      verticalAlign = _getAnchorAlignment2.verticalAlign;

  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);
  var height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}

function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing) {
  var translate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];
  var isIconFont = arguments.length > 7 ? arguments[7] : undefined;
  var lines = text.split('\n');
  var positionedGlyphs = [];
  var shaping = {
    positionedGlyphs: positionedGlyphs,
    top: translate[1],
    bottom: translate[1],
    left: translate[0],
    right: translate[0],
    lineCount: lines.length,
    text: text
  };
  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);

  if (!positionedGlyphs.length) {
    return false;
  }

  return shaping;
}
function getGlyphQuads(shaping) {
  var textOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var alongLine = arguments.length > 2 ? arguments[2] : undefined;
  var _shaping$positionedGl = shaping.positionedGlyphs,
      positionedGlyphs = _shaping$positionedGl === void 0 ? [] : _shaping$positionedGl;
  var quads = [];

  var _iterator2 = _createForOfIteratorHelper(positionedGlyphs),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var positionedGlyph = _step2.value;
      var rect = positionedGlyph.metrics;
      var rectBuffer = 4;
      var halfAdvance = rect.advance * positionedGlyph.scale / 2;
      var glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];
      var builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];
      var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
      var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
      var x2 = x1 + rect.width * positionedGlyph.scale;
      var y2 = y1 + rect.height * positionedGlyph.scale;
      var tl = {
        x: x1,
        y: y1
      };
      var tr = {
        x: x2,
        y: y1
      };
      var bl = {
        x: x1,
        y: y2
      };
      var br = {
        x: x2,
        y: y2
      };
      quads.push({
        tl: tl,
        tr: tr,
        bl: bl,
        br: br,
        tex: rect,
        glyphOffset: glyphOffset
      });
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return quads;
}
//# sourceMappingURL=symbol-layout.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/utils/updateShape.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/utils/updateShape.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateShape": function() { return /* binding */ updateShape; }
/* harmony export */ });
var shapeUpdateList = [['circle', 'cylinder'], ['square', 'cylinder'], ['triangle', 'cylinder'], ['pentagon', 'cylinder'], ['hexagon', 'cylinder'], ['octogon', 'cylinder'], ['hexagram', 'cylinder'], ['rhombus', 'cylinder'], ['vesica', 'cylinder']];
function updateShape(layer, lastShape, currentShape) {
  if (typeof lastShape === 'string' && typeof currentShape === 'string' && lastShape !== currentShape) {
    if (layer.type === 'PointLayer') {
      layer.dataState.dataSourceNeedUpdate = true;
      return;
    }

    shapeUpdateList.map(function (shapes) {
      if (shapes.includes(lastShape) && shapes.includes(currentShape)) {
        layer.dataState.dataSourceNeedUpdate = true;
        return;
      }
    });
  }
}
//# sourceMappingURL=updateShape.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ WindLayer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/BaseLayer */ "./node_modules/@antv/l7-layers/es/core/BaseLayer.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models */ "./node_modules/@antv/l7-layers/es/wind/models/index.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var WindLayer = function (_BaseLayer) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(WindLayer, _BaseLayer);

  var _super = _createSuper(WindLayer);

  function WindLayer() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, WindLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "type", 'WindLayer');

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(WindLayer, [{
    key: "buildModels",
    value: function buildModels() {
      var modelType = this.getModelType();
      this.layerModel = new _models__WEBPACK_IMPORTED_MODULE_7__.default[modelType](this);
      this.models = this.layerModel.initModels();
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      this.models = this.layerModel.buildModels();
    }
  }, {
    key: "renderModels",
    value: function renderModels() {
      if (this.layerModel) {
        this.layerModel.render();
      }

      return this;
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      var type = this.getModelType();
      var defaultConfig = {
        wind: {}
      };
      return defaultConfig[type];
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      return 'wind';
    }
  }]);

  return WindLayer;
}(_core_BaseLayer__WEBPACK_IMPORTED_MODULE_8__.default);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/models/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/models/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wind__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wind */ "./node_modules/@antv/l7-layers/es/wind/models/wind.js");

var WindModels = {
  wind: _wind__WEBPACK_IMPORTED_MODULE_0__.default
};
/* harmony default export */ __webpack_exports__["default"] = (WindModels);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/models/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/models/utils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProgram": function() { return /* binding */ createProgram; },
/* harmony export */   "loadShader": function() { return /* binding */ loadShader; },
/* harmony export */   "createTexture": function() { return /* binding */ createTexture; },
/* harmony export */   "createDataTexture": function() { return /* binding */ createDataTexture; },
/* harmony export */   "bindTexture": function() { return /* binding */ bindTexture; },
/* harmony export */   "createBuffer": function() { return /* binding */ createBuffer; },
/* harmony export */   "bindAttriBuffer": function() { return /* binding */ bindAttriBuffer; },
/* harmony export */   "bindAttriIndicesBuffer": function() { return /* binding */ bindAttriIndicesBuffer; },
/* harmony export */   "bindUnifrom": function() { return /* binding */ bindUnifrom; },
/* harmony export */   "setUnifrom": function() { return /* binding */ setUnifrom; },
/* harmony export */   "initFramebuffer": function() { return /* binding */ initFramebuffer; }
/* harmony export */ });
function createProgram(gl, vshader, fshader) {
  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

  if (!vertexShader || !fragmentShader) {
    return null;
  }

  var program = gl.createProgram();

  if (!program) {
    return null;
  }

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (!linked) {
    var error = gl.getProgramInfoLog(program);
    console.warn('Failed to link program: ' + error);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
    return null;
  }

  var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

  for (var i = 0; i < numAttributes; i++) {
    var attribute = gl.getActiveAttrib(program, i);
    program[attribute.name] = gl.getAttribLocation(program, attribute.name);
  }

  var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

  for (var i$1 = 0; i$1 < numUniforms; i$1++) {
    var uniform = gl.getActiveUniform(program, i$1);
    program[uniform.name] = gl.getUniformLocation(program, uniform.name);
  }

  program.vertexShader = vertexShader;
  program.fragmentShader = fragmentShader;
  return program;
}
function loadShader(gl, type, source) {
  var shader = gl.createShader(type);

  if (shader == null) {
    console.warn('unable to create shader');
    return null;
  }

  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (!compiled) {
    var error = gl.getShaderInfoLog(shader);
    console.warn('Failed to compile shader: ' + error);
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}
function createTexture(gl, filter, data, width, height) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return texture;
}
function createDataTexture(gl, filter, data) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return texture;
}
function bindTexture(gl, texture, unit) {
  gl.activeTexture(gl.TEXTURE0 + unit);
  gl.bindTexture(gl.TEXTURE_2D, texture);
}
function createBuffer(gl, data) {
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  return buffer;
}
function bindAttriBuffer(gl, attrName, vertices, count, program) {
  var buffer = gl.createBuffer();

  if (!buffer) {
    console.warn('failed create vertex buffer');
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  var attr = gl.getAttribLocation(program, attrName);
  gl.vertexAttribPointer(attr, count, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(attr);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return {
    buffer: buffer,
    attr: attr,
    count: count
  };
}
function bindAttriIndicesBuffer(gl, indices) {
  var buffer = gl.createBuffer();

  if (!buffer) {
    console.warn('failed create vertex buffer');
  } else {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  }

  return buffer;
}
function bindUnifrom(gl, unifromName, data, program, vec) {
  var uniform = gl.getUniformLocation(program, unifromName);

  if (uniform === null || uniform < 0) {
    console.warn(' uniform ');
  } else {
    setUnifrom(gl, uniform, data, vec);
  }

  return uniform;
}
function setUnifrom(gl, location, data, vec) {
  switch (vec) {
    case 'float':
      gl.uniform1f(location, data);
      break;

    case 'vec2':
      gl.uniform2fv(location, data);
      break;

    case 'vec3':
      gl.uniform3fv(location, data);
      break;

    case 'vec4':
      gl.uniform4fv(location, data);
      break;

    case 'bool':
      gl.uniform1i(location, data);
      break;

    case 'sampler2d':
      break;

    case 'mat4':
      gl.uniformMatrix4fv(location, false, data);
      break;
  }
}
function initFramebuffer(gl) {
  var drawingBufferWidth = gl.drawingBufferWidth,
      drawingBufferHeight = gl.drawingBufferHeight;
  var OFFER_SCREEN_WIDTH = drawingBufferWidth;
  var OFFER_SCREEN_HEIGHT = drawingBufferHeight;
  var FRAMEBUFFER = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, FRAMEBUFFER);
  var depthbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthbuffer);
  var texture = gl.createTexture();
  FRAMEBUFFER.texture = texture;
  FRAMEBUFFER.width = OFFER_SCREEN_WIDTH;
  FRAMEBUFFER.height = OFFER_SCREEN_HEIGHT;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return {
    FRAMEBUFFER: FRAMEBUFFER,
    OFFER_SCREEN_WIDTH: OFFER_SCREEN_WIDTH,
    OFFER_SCREEN_HEIGHT: OFFER_SCREEN_HEIGHT
  };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/models/wind.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/models/wind.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ WindModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _core_BaseModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/BaseModel */ "./node_modules/@antv/l7-layers/es/core/BaseModel.js");
/* harmony import */ var _core_triangulation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/triangulation */ "./node_modules/@antv/l7-layers/es/core/triangulation.js");
/* harmony import */ var _windRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./windRender */ "./node_modules/@antv/l7-layers/es/wind/models/windRender.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var WindFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}\n";
var WindVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n#pragma include \"projection\"\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy,0., 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   }\n}\n";

var defaultRampColors = {
  0.0: '#3288bd',
  0.1: '#66c2a5',
  0.2: '#abdda4',
  0.3: '#e6f598',
  0.4: '#fee08b',
  0.5: '#fdae61',
  0.6: '#f46d43',
  1.0: '#d53e4f'
};

var WindModel = function (_BaseModel) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(WindModel, _BaseModel);

  var _super = _createSuper(WindModel);

  function WindModel() {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, WindModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "colorModel", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "wind", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "imageCoords", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "sizeScale", 0.5);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "frequency", new _antv_l7_utils__WEBPACK_IMPORTED_MODULE_8__.FrequencyController(7.2));

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(WindModel, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      this.frequency.run(function () {
        _this2.drawWind();
      });
      this.drawColorMode();
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this3 = this;

      var createTexture2D = this.rendererService.createTexture2D;
      var source = this.layer.getSource();
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      var glContext = this.rendererService.getGLContext();
      this.imageCoords = source.data.dataArray[0].coordinates;
      source.data.images.then(function (imageData) {
        var _ref = _this3.layer.getLayerConfig(),
            _ref$uMin = _ref.uMin,
            uMin = _ref$uMin === void 0 ? -21.32 : _ref$uMin,
            _ref$uMax = _ref.uMax,
            uMax = _ref$uMax === void 0 ? 26.8 : _ref$uMax,
            _ref$vMin = _ref.vMin,
            vMin = _ref$vMin === void 0 ? -21.57 : _ref$vMin,
            _ref$vMax = _ref.vMax,
            vMax = _ref$vMax === void 0 ? 21.42 : _ref$vMax,
            _ref$fadeOpacity = _ref.fadeOpacity,
            fadeOpacity = _ref$fadeOpacity === void 0 ? 0.996 : _ref$fadeOpacity,
            _ref$speedFactor = _ref.speedFactor,
            speedFactor = _ref$speedFactor === void 0 ? 0.25 : _ref$speedFactor,
            _ref$dropRate = _ref.dropRate,
            dropRate = _ref$dropRate === void 0 ? 0.003 : _ref$dropRate,
            _ref$dropRateBump = _ref.dropRateBump,
            dropRateBump = _ref$dropRateBump === void 0 ? 0.01 : _ref$dropRateBump,
            _ref$rampColors = _ref.rampColors,
            rampColors = _ref$rampColors === void 0 ? defaultRampColors : _ref$rampColors,
            _ref$sizeScale = _ref.sizeScale,
            sizeScale = _ref$sizeScale === void 0 ? 0.5 : _ref$sizeScale;

        _this3.sizeScale = sizeScale;

        var _this3$getWindSize = _this3.getWindSize(),
            imageWidth = _this3$getWindSize.imageWidth,
            imageHeight = _this3$getWindSize.imageHeight;

        var options = {
          glContext: glContext,
          imageWidth: imageWidth,
          imageHeight: imageHeight,
          fadeOpacity: fadeOpacity,
          speedFactor: speedFactor,
          dropRate: dropRate,
          dropRateBump: dropRateBump,
          rampColors: rampColors
        };
        _this3.wind = new _windRender__WEBPACK_IMPORTED_MODULE_9__.Wind(options);

        _this3.wind.setWind({
          uMin: uMin,
          uMax: uMax,
          vMin: vMin,
          vMax: vMax,
          image: imageData[0]
        });

        _this3.texture = createTexture2D({
          data: imageData[0],
          width: imageData[0].width,
          height: imageData[0].height
        });

        _this3.layerService.updateLayerRenderList();

        _this3.layerService.renderLayers();
      });
      this.colorModel = this.layer.buildLayerModel({
        moduleName: 'WindLayer',
        vertexShader: WindVert,
        fragmentShader: WindFrag,
        triangulation: _core_triangulation__WEBPACK_IMPORTED_MODULE_10__.RasterImageTriangulation,
        primitive: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.TRIANGLES,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      });
      return [this.colorModel];
    }
  }, {
    key: "getWindSize",
    value: function getWindSize() {
      var p1 = this.mapService.lngLatToPixel(this.imageCoords[0]);
      var p2 = this.mapService.lngLatToPixel(this.imageCoords[1]);
      var imageWidth = Math.floor((p2.x - p1.x) * this.sizeScale);
      var imageHeight = Math.floor((p1.y - p2.y) * this.sizeScale);
      return {
        imageWidth: imageWidth,
        imageHeight: imageHeight
      };
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$wind;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$wind = this.wind) === null || _this$wind === void 0 ? void 0 : _this$wind.destroy();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.DYNAMIC_DRAW,
            data: [],
            type: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "drawWind",
    value: function drawWind() {
      if (this.wind) {
        var _ref2 = this.layer.getLayerConfig(),
            _ref2$uMin = _ref2.uMin,
            uMin = _ref2$uMin === void 0 ? -21.32 : _ref2$uMin,
            _ref2$uMax = _ref2.uMax,
            uMax = _ref2$uMax === void 0 ? 26.8 : _ref2$uMax,
            _ref2$vMin = _ref2.vMin,
            vMin = _ref2$vMin === void 0 ? -21.57 : _ref2$vMin,
            _ref2$vMax = _ref2.vMax,
            vMax = _ref2$vMax === void 0 ? 21.42 : _ref2$vMax,
            _ref2$numParticles = _ref2.numParticles,
            numParticles = _ref2$numParticles === void 0 ? 65535 : _ref2$numParticles,
            _ref2$fadeOpacity = _ref2.fadeOpacity,
            fadeOpacity = _ref2$fadeOpacity === void 0 ? 0.996 : _ref2$fadeOpacity,
            _ref2$speedFactor = _ref2.speedFactor,
            speedFactor = _ref2$speedFactor === void 0 ? 0.25 : _ref2$speedFactor,
            _ref2$dropRate = _ref2.dropRate,
            dropRate = _ref2$dropRate === void 0 ? 0.003 : _ref2$dropRate,
            _ref2$dropRateBump = _ref2.dropRateBump,
            dropRateBump = _ref2$dropRateBump === void 0 ? 0.01 : _ref2$dropRateBump,
            _ref2$rampColors = _ref2.rampColors,
            rampColors = _ref2$rampColors === void 0 ? defaultRampColors : _ref2$rampColors,
            _ref2$sizeScale = _ref2.sizeScale,
            sizeScale = _ref2$sizeScale === void 0 ? 0.5 : _ref2$sizeScale;

        if (typeof sizeScale === 'number' && sizeScale !== this.sizeScale) {
          this.sizeScale = sizeScale;

          var _this$getWindSize = this.getWindSize(),
              imageWidth = _this$getWindSize.imageWidth,
              imageHeight = _this$getWindSize.imageHeight;

          this.wind.reSize(imageWidth, imageHeight);
        }

        this.wind.updateWindDir(uMin, uMax, vMin, vMax);
        this.wind.updateParticelNum(numParticles);
        this.wind.updateColorRampTexture(rampColors);
        this.wind.fadeOpacity = fadeOpacity;
        this.wind.speedFactor = speedFactor;
        this.wind.dropRate = dropRate;
        this.wind.dropRateBump = dropRateBump;

        var _this$wind$draw = this.wind.draw(),
            d = _this$wind$draw.d,
            w = _this$wind$draw.w,
            h = _this$wind$draw.h;

        this.rendererService.setBaseState();
        this.texture.update({
          data: d,
          width: w,
          height: h
        });
      }
    }
  }, {
    key: "drawColorMode",
    value: function drawColorMode() {
      var _ref3 = this.layer.getLayerConfig(),
          opacity = _ref3.opacity;

      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_texture: this.texture
        }
      });
    }
  }]);

  return WindModel;
}(_core_BaseModel__WEBPACK_IMPORTED_MODULE_11__.default);


//# sourceMappingURL=wind.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/models/windRender.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/models/windRender.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Wind": function() { return /* binding */ Wind; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/@antv/l7-layers/es/wind/models/utils.js");
/* harmony import */ var _windShader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./windShader */ "./node_modules/@antv/l7-layers/es/wind/models/windShader.js");






function getColorRamp(colors) {
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 1;
  var gradient = ctx.createLinearGradient(0, 0, 256, 0);

  for (var _i = 0, _Object$keys = Object.keys(colors); _i < _Object$keys.length; _i++) {
    var stop = _Object$keys[_i];
    gradient.addColorStop(+stop, colors[+stop]);
  }

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 1);
  canvas = null;
  return new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
}

function bindAttribute(gl, buffer, attribute, numComponents) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.enableVertexAttribArray(attribute);
  gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
}

function bindFramebuffer(gl, framebuffer, texture) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  if (texture) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  }
}

var Wind = function () {
  function Wind(options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Wind);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "width", 512);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "height", 512);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "pixels", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "fadeOpacity", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "speedFactor", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "dropRate", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "dropRateBump", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "gl", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "drawProgram", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "fullScreenProgram", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "updateProgram", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "rampColors", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "numParticles", 65536);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "numParticlesSize", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "particleStateResolution", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "quadBuffer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "particleIndexBuffer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "framebuffer", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "colorRampTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "backgroundTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "screenTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "particleStateTexture0", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "particleStateTexture1", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "windTexture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "windData", void 0);

    this.gl = options.glContext;
    this.width = options.imageWidth;
    this.height = options.imageHeight;
    this.fadeOpacity = options.fadeOpacity;
    this.speedFactor = options.speedFactor;
    this.dropRate = options.dropRate;
    this.dropRateBump = options.dropRateBump;
    this.rampColors = options.rampColors;
    this.init();
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Wind, [{
    key: "init",
    value: function init() {
      var gl = this.gl;
      this.fadeOpacity = 0.996;
      this.speedFactor = 0.25;
      this.dropRate = 0.003;
      this.dropRateBump = 0.01;
      this.drawProgram = _utils__WEBPACK_IMPORTED_MODULE_3__.createProgram(gl, _windShader__WEBPACK_IMPORTED_MODULE_4__.drawVert, _windShader__WEBPACK_IMPORTED_MODULE_4__.drawFrag);
      this.fullScreenProgram = _utils__WEBPACK_IMPORTED_MODULE_3__.createProgram(gl, _windShader__WEBPACK_IMPORTED_MODULE_4__.fullScreenVert, _windShader__WEBPACK_IMPORTED_MODULE_4__.fullScreenFrag);
      this.updateProgram = _utils__WEBPACK_IMPORTED_MODULE_3__.createProgram(gl, _windShader__WEBPACK_IMPORTED_MODULE_4__.updateVert, _windShader__WEBPACK_IMPORTED_MODULE_4__.updateFrag);
      this.quadBuffer = _utils__WEBPACK_IMPORTED_MODULE_3__.createBuffer(gl, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]));
      this.framebuffer = gl.createFramebuffer();
      this.colorRampTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(this.gl, this.gl.LINEAR, getColorRamp(this.rampColors), 16, 16);
      var emptyPixels = new Uint8Array(this.width * this.height * 4);
      this.backgroundTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);
      this.screenTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);
      var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
      this.numParticlesSize = particleRes * particleRes;
      var particleState = new Uint8Array(this.numParticlesSize * 4);

      for (var i = 0; i < particleState.length; i++) {
        particleState[i] = Math.floor(Math.random() * 256);
      }

      this.particleStateTexture0 = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      this.particleStateTexture1 = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      var particleIndices = new Float32Array(this.numParticlesSize);

      for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
        particleIndices[i$1] = i$1;
      }

      this.particleIndexBuffer = _utils__WEBPACK_IMPORTED_MODULE_3__.createBuffer(gl, particleIndices);
    }
  }, {
    key: "setWind",
    value: function setWind(windData) {
      this.windData = windData;
      this.windTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createDataTexture(this.gl, this.gl.LINEAR, windData.image);
    }
  }, {
    key: "updateParticelNum",
    value: function updateParticelNum(num) {
      var gl = this.gl;

      if (num !== this.numParticles) {
        this.numParticles = num;
        var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
        this.numParticlesSize = particleRes * particleRes;
        var particleState = new Uint8Array(this.numParticlesSize * 4);

        for (var i = 0; i < particleState.length; i++) {
          particleState[i] = Math.floor(Math.random() * 256);
        }

        this.particleStateTexture0 = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        this.particleStateTexture1 = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        var particleIndices = new Float32Array(this.numParticlesSize);

        for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
          particleIndices[i$1] = i$1;
        }

        this.particleIndexBuffer = _utils__WEBPACK_IMPORTED_MODULE_3__.createBuffer(gl, particleIndices);
      }
    }
  }, {
    key: "updateWindDir",
    value: function updateWindDir(uMin, uMax, vMin, vMax) {
      this.windData.uMin = uMin;
      this.windData.uMax = uMax;
      this.windData.vMin = vMin;
      this.windData.vMax = vMax;
    }
  }, {
    key: "updateColorRampTexture",
    value: function updateColorRampTexture(rampColors) {
      if (this.isColorChanged(rampColors)) {
        this.rampColors = rampColors;
        var gl = this.gl;
        gl.deleteTexture(this.colorRampTexture);
        this.colorRampTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.LINEAR, getColorRamp(rampColors), 16, 16);
      }
    }
  }, {
    key: "isColorChanged",
    value: function isColorChanged(rampColors) {
      var keys = Object.keys(rampColors);

      for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
        var item = _keys[_i2];

        var _key = Number(item);

        if (!this.rampColors[_key]) {
          return true;
        }

        if (this.rampColors[_key] && this.rampColors[_key] !== rampColors[_key]) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "reSize",
    value: function reSize(width, height) {
      if (width !== this.width || height !== this.height) {
        var gl = this.gl;
        gl.deleteTexture(this.backgroundTexture);
        gl.deleteTexture(this.screenTexture);
        this.width = width;
        this.height = height;
        var emptyPixels = new Uint8Array(width * height * 4);
        this.backgroundTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
        this.screenTexture = _utils__WEBPACK_IMPORTED_MODULE_3__.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$windData;

      if ((_this$windData = this.windData) !== null && _this$windData !== void 0 && _this$windData.image) {
        var gl = this.gl;
        _utils__WEBPACK_IMPORTED_MODULE_3__.bindTexture(gl, this.windTexture, 0);
        _utils__WEBPACK_IMPORTED_MODULE_3__.bindTexture(gl, this.particleStateTexture0, 1);
        this.drawScreen();
        this.updateParticles();
        return {
          d: this.pixels,
          w: this.width,
          h: this.height
        };
      } else {
        return {
          d: new Uint8Array([0, 0, 0, 0]),
          w: 1,
          h: 1
        };
      }
    }
  }, {
    key: "drawScreen",
    value: function drawScreen() {
      var gl = this.gl;
      bindFramebuffer(gl, this.framebuffer, this.screenTexture);
      gl.viewport(0, 0, this.width, this.height);
      this.drawFullTexture(this.backgroundTexture, this.fadeOpacity);
      this.drawParticles();
      gl.disable(gl.BLEND);
      this.pixels = new Uint8Array(4 * this.width * this.height);
      gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.pixels);
      bindFramebuffer(gl, null, null);
      gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      var temp = this.backgroundTexture;
      this.backgroundTexture = this.screenTexture;
      this.screenTexture = temp;
    }
  }, {
    key: "drawFullTexture",
    value: function drawFullTexture(texture, opacity) {
      var gl = this.gl;
      var program = this.fullScreenProgram;
      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
      gl.vertexAttribPointer(program.a_pos, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(program.a_pos);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      _utils__WEBPACK_IMPORTED_MODULE_3__.bindTexture(gl, texture, 2);
      gl.uniform1i(program.u_screen, 2);
      gl.uniform1f(program.u_opacity, opacity);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
  }, {
    key: "drawParticles",
    value: function drawParticles() {
      var gl = this.gl;
      var program = this.drawProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.particleIndexBuffer, program.a_index, 1);
      _utils__WEBPACK_IMPORTED_MODULE_3__.bindTexture(gl, this.colorRampTexture, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1i(program.u_color_ramp, 2);
      gl.uniform1f(program.u_particles_res, this.particleStateResolution);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.drawArrays(gl.POINTS, 0, this.numParticlesSize);
    }
  }, {
    key: "updateParticles",
    value: function updateParticles() {
      var gl = this.gl;
      bindFramebuffer(gl, this.framebuffer, this.particleStateTexture1);
      gl.viewport(0, 0, this.particleStateResolution, this.particleStateResolution);
      var program = this.updateProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.quadBuffer, program.a_pos, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1f(program.u_rand_seed, Math.random());
      gl.uniform2f(program.u_wind_res, this.windData.image.width * 2, this.windData.image.height * 2);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.uniform1f(program.u_speed_factor, this.speedFactor);
      gl.uniform1f(program.u_drop_rate, this.dropRate);
      gl.uniform1f(program.u_drop_rate_bump, this.dropRateBump);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      var temp = this.particleStateTexture0;
      this.particleStateTexture0 = this.particleStateTexture1;
      this.particleStateTexture1 = temp;
      bindFramebuffer(gl, null, null);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.gl.deleteBuffer(this.quadBuffer);
      this.gl.deleteBuffer(this.particleIndexBuffer);
      this.gl.deleteFramebuffer(this.framebuffer);
      this.gl.deleteShader(this.drawProgram.vertexShader);
      this.gl.deleteShader(this.drawProgram.fragmentShader);
      this.gl.deleteProgram(this.drawProgram);
      this.gl.deleteShader(this.fullScreenProgram.vertexShader);
      this.gl.deleteShader(this.fullScreenProgram.fragmentShader);
      this.gl.deleteProgram(this.fullScreenProgram);
      this.gl.deleteShader(this.updateProgram.vertexShader);
      this.gl.deleteShader(this.updateProgram.fragmentShader);
      this.gl.deleteProgram(this.updateProgram);
      this.gl.deleteTexture(this.colorRampTexture);
      this.gl.deleteTexture(this.backgroundTexture);
      this.gl.deleteTexture(this.screenTexture);
      this.gl.deleteTexture(this.particleStateTexture0);
      this.gl.deleteTexture(this.particleStateTexture1);
      this.gl.deleteTexture(this.windTexture);
    }
  }]);

  return Wind;
}();
//# sourceMappingURL=windRender.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-layers/es/wind/models/windShader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-layers/es/wind/models/windShader.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "drawVert": function() { return /* binding */ drawVert; },
/* harmony export */   "drawFrag": function() { return /* binding */ drawFrag; },
/* harmony export */   "updateVert": function() { return /* binding */ updateVert; },
/* harmony export */   "updateFrag": function() { return /* binding */ updateFrag; },
/* harmony export */   "fullScreenVert": function() { return /* binding */ fullScreenVert; },
/* harmony export */   "fullScreenFrag": function() { return /* binding */ fullScreenFrag; }
/* harmony export */ });
var drawVert = "\n precision mediump float;\n \n attribute float a_index;\n \n uniform sampler2D u_particles;\n uniform float u_particles_res;\n \n varying vec2 v_particle_pos;\n \n void main() {\n     vec4 color = texture2D(u_particles, vec2(\n         fract(a_index / u_particles_res),\n         floor(a_index / u_particles_res) / u_particles_res)\n     );\n                \n     // decode current particle position from the pixel's RGBA value\n     v_particle_pos = vec2( color.r / 255.0 + color.b, color.g / 255.0 + color.a);\n                         \n     gl_PointSize = 1.0;\n     gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n }";
var drawFrag = "\n precision mediump float;\n \n uniform sampler2D u_wind;\n uniform vec2 u_wind_min;\n uniform vec2 u_wind_max;\n uniform sampler2D u_color_ramp;\n \n varying vec2 v_particle_pos;\n \n void main() {\n     vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, v_particle_pos).rg);\n     float speed_t = length(velocity) / length(u_wind_max);\n     \n     // color ramp is encoded in a 16x16 texture    \n     vec2 ramp_pos = vec2( fract(16.0 * speed_t), floor(16.0 * speed_t) / 16.0);  \n \n     gl_FragColor = texture2D(u_color_ramp, ramp_pos);\n }";
var updateVert = "\n precision mediump float;\n \n attribute vec2 a_pos;\n \n varying vec2 v_tex_pos;\n \n void main() {\n     v_tex_pos = a_pos;\n     gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n     // framebuffer \u59CB\u7EC8\u7528\u94FA\u6EE1\u5C4F\u5E55\u7684 texture\n }";
var updateFrag = "\n precision highp float;\n \n uniform sampler2D u_particles;\n uniform sampler2D u_wind;\n uniform vec2 u_wind_res;\n uniform vec2 u_wind_min;\n uniform vec2 u_wind_max;\n uniform float u_rand_seed;\n uniform float u_speed_factor;\n uniform float u_drop_rate;\n uniform float u_drop_rate_bump;\n \n varying vec2 v_tex_pos;\n \n // pseudo-random generator\n const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n float rand(const vec2 co) {\n float t = dot(rand_constants.xy, co);\n     return fract(sin(t) * (rand_constants.z + t));\n }\n     \n // wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n vec2 lookup_wind(const vec2 uv) {\n     // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n     vec2 px = 1.0 / u_wind_res;\n     vec2 vc = (floor(uv * u_wind_res)) * px;\n     vec2 f = fract(uv * u_wind_res);\n     vec2 tl = texture2D(u_wind, vc).rg;\n     vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n     vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n     vec2 br = texture2D(u_wind, vc + px).rg;\n     return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n }\n \n void main() {\n     vec4 color = texture2D(u_particles, v_tex_pos);\n     vec2 pos = vec2(\n         color.r / 255.0 + color.b,\n         color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n     vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(pos));\n     float speed_t = length(velocity) / length(u_wind_max);\n                 \n     // take EPSG:4236 distortion into account for calculating where the particle moved\n     float distortion = cos(radians(pos.y * 180.0 - 90.0));\n     vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n \n     // update particle position, wrapping around the date line\n     pos = fract(1.0 + pos + offset);\n     \n     // a random seed to use for the particle drop\n     vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n     \n     // drop rate is a chance a particle will restart at random position, to avoid degeneration\n     float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n     float drop = step(1.0 - drop_rate, rand(seed));\n     \n     vec2 random_pos = vec2(\n         rand(seed + 1.3),\n         rand(seed + 2.1));\n         pos = mix(pos, random_pos, drop);\n         \n     // encode the new particle position back into RGBA\n     gl_FragColor = vec4(\n         fract(pos * 255.0),\n         floor(pos * 255.0) / 255.0);\n }";
var fullScreenVert = "\n     precision mediump float;\n     \n     attribute vec2 a_pos;\n     \n     varying vec2 v_tex_pos;\n     \n     void main() {\n         v_tex_pos = a_pos;\n         gl_Position = vec4(1.0 - 2.0 * a_pos, 0.0, 1.0);\n         gl_PointSize = 100.0;\n }";
var fullScreenFrag = "\n precision mediump float;\n \n uniform sampler2D u_screen;\n uniform float u_opacity;\n varying vec2 v_tex_pos;\n \n void main() {\n     vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n     \n     // a hack to guarantee opacity fade out even with a value close to 1.0\n     gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n }";
//# sourceMappingURL=windShader.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglAttribute.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglAttribute.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglAttribute; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");




var ReglAttribute = function () {
  function ReglAttribute(gl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ReglAttribute);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "attribute", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "buffer", void 0);

    var buffer = options.buffer,
        offset = options.offset,
        stride = options.stride,
        normalized = options.normalized,
        size = options.size,
        divisor = options.divisor;
    this.buffer = buffer;
    this.attribute = {
      buffer: buffer.get(),
      offset: offset || 0,
      stride: stride || 0,
      normalized: normalized || false,
      divisor: divisor || 0
    };

    if (size) {
      this.attribute.size = size;
    }
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ReglAttribute, [{
    key: "get",
    value: function get() {
      return this.attribute;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(options) {
      this.buffer.subData(options);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.destroy();
    }
  }]);

  return ReglAttribute;
}();


//# sourceMappingURL=ReglAttribute.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglBuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglBuffer.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglBuffer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/l7-renderer/es/regl/constants.js");






var ReglBuffer = function () {
  function ReglBuffer(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ReglBuffer);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "buffer", void 0);

    var data = options.data,
        usage = options.usage,
        type = options.type;
    this.buffer = reGl.buffer({
      data: data,
      usage: _constants__WEBPACK_IMPORTED_MODULE_4__.usageMap[usage || _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.STATIC_DRAW],
      type: _constants__WEBPACK_IMPORTED_MODULE_4__.dataTypeMap[type || _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.UNSIGNED_BYTE]
    });
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ReglBuffer, [{
    key: "get",
    value: function get() {
      return this.buffer;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.destroy();
    }
  }, {
    key: "subData",
    value: function subData(_ref) {
      var data = _ref.data,
          offset = _ref.offset;
      this.buffer.subdata(data, offset);
    }
  }]);

  return ReglBuffer;
}();


//# sourceMappingURL=ReglBuffer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglElements.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglElements.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglElements; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/l7-renderer/es/regl/constants.js");






var ReglElements = function () {
  function ReglElements(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ReglElements);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "elements", void 0);

    var data = options.data,
        usage = options.usage,
        type = options.type,
        count = options.count;
    this.elements = reGl.elements({
      data: data,
      usage: _constants__WEBPACK_IMPORTED_MODULE_4__.usageMap[usage || _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.STATIC_DRAW],
      type: _constants__WEBPACK_IMPORTED_MODULE_4__.dataTypeMap[type || _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.UNSIGNED_BYTE],
      count: count
    });
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ReglElements, [{
    key: "get",
    value: function get() {
      return this.elements;
    }
  }, {
    key: "subData",
    value: function subData(_ref) {
      var data = _ref.data;
      this.elements.subdata(data);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return ReglElements;
}();


//# sourceMappingURL=ReglElements.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglFramebuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglFramebuffer.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglFramebuffer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");




var ReglFramebuffer = function () {
  function ReglFramebuffer(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ReglFramebuffer);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "framebuffer", void 0);

    var width = options.width,
        height = options.height,
        color = options.color,
        colors = options.colors,
        depth = options.depth,
        stencil = options.stencil;
    var framebufferOptions = {
      width: width,
      height: height
    };

    if (Array.isArray(colors)) {
      framebufferOptions.colors = colors.map(function (c) {
        return c.get();
      });
    }

    if (color && typeof color !== 'boolean') {
      framebufferOptions.color = color.get();
    }

    this.framebuffer = reGl.framebuffer(framebufferOptions);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ReglFramebuffer, [{
    key: "get",
    value: function get() {
      return this.framebuffer;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.framebuffer.destroy();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
          height = _ref.height;
      this.framebuffer.resize(width, height);
    }
  }]);

  return ReglFramebuffer;
}();


//# sourceMappingURL=ReglFramebuffer.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglModel.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglModel.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglModel; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js");
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/l7-renderer/es/regl/constants.js");








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var ReglModel = function () {
  function ReglModel(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, ReglModel);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "reGl", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "destroyed", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "drawCommand", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "drawPickCommand", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "drawParams", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "options", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "uniforms", {});

    this.reGl = reGl;
    var vs = options.vs,
        fs = options.fs,
        attributes = options.attributes,
        uniforms = options.uniforms,
        primitive = options.primitive,
        count = options.count,
        elements = options.elements,
        depth = options.depth,
        blend = options.blend,
        stencil = options.stencil,
        cull = options.cull,
        instances = options.instances;
    var reglUniforms = {};
    this.options = options;

    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
      Object.keys(uniforms).forEach(function (uniformName) {
        reglUniforms[uniformName] = reGl.prop(uniformName);
      });
    }

    var reglAttributes = {};
    Object.keys(attributes).forEach(function (name) {
      reglAttributes[name] = attributes[name].get();
    });
    var drawParams = {
      attributes: reglAttributes,
      frag: fs,
      uniforms: reglUniforms,
      vert: vs,
      blend: {},
      primitive: _constants__WEBPACK_IMPORTED_MODULE_8__.primitiveMap[primitive === undefined ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.TRIANGLES : primitive]
    };

    if (instances) {
      drawParams.instances = instances;
    }

    if (count) {
      drawParams.count = count;
    }

    if (elements) {
      drawParams.elements = elements.get();
    }

    this.initDepthDrawParams({
      depth: depth
    }, drawParams);
    this.initBlendDrawParams({
      blend: blend
    }, drawParams);
    this.initStencilDrawParams({
      stencil: stencil
    }, drawParams);
    this.initCullDrawParams({
      cull: cull
    }, drawParams);
    this.drawCommand = reGl(drawParams);

    var pickDrawParams = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default()(drawParams);

    pickDrawParams.blend = _objectSpread(_objectSpread({}, pickDrawParams.blend), {}, {
      enable: false
    });
    this.drawPickCommand = reGl(pickDrawParams);
    this.drawParams = drawParams;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(ReglModel, [{
    key: "updateAttributesAndElements",
    value: function updateAttributesAndElements(attributes, elements) {
      var reglAttributes = {};
      Object.keys(attributes).forEach(function (name) {
        reglAttributes[name] = attributes[name].get();
      });
      this.drawParams.attributes = reglAttributes;
      this.drawParams.elements = elements.get();
      this.drawCommand = this.reGl(this.drawParams);

      var pickDrawParams = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default()(this.drawParams);

      pickDrawParams.blend = _objectSpread(_objectSpread({}, pickDrawParams.blend), {}, {
        enable: false
      });
      this.drawPickCommand = this.reGl(pickDrawParams);
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(attributes) {
      var reglAttributes = {};
      Object.keys(attributes).forEach(function (name) {
        reglAttributes[name] = attributes[name].get();
      });
      this.drawParams.attributes = reglAttributes;
      this.drawCommand = this.reGl(this.drawParams);

      var pickDrawParams = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_6___default()(this.drawParams);

      pickDrawParams.blend = _objectSpread(_objectSpread({}, pickDrawParams.blend), {}, {
        enable: false
      });
      this.drawPickCommand = this.reGl(pickDrawParams);
    }
  }, {
    key: "addUniforms",
    value: function addUniforms(uniforms) {
      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(uniforms));
    }
  }, {
    key: "draw",
    value: function draw(options, pick) {
      if (this.drawParams.attributes && Object.keys(this.drawParams.attributes).length === 0) {
        return;
      }

      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(options.uniforms || {}));

      var reglDrawProps = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        var type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(uniforms[uniformName]);

        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || uniforms[uniformName].BYTES_PER_ELEMENT) {
          reglDrawProps[uniformName] = uniforms[uniformName];
        } else {
          reglDrawProps[uniformName] = uniforms[uniformName].get();
        }
      });

      if (!pick) {
        this.drawCommand(reglDrawProps);
      } else {
        this.drawPickCommand(reglDrawProps);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.drawParams.elements.destroy();

      if (this.options.attributes) {
        Object.values(this.options.attributes).forEach(function (attr) {
          attr.destroy();
        });
      }

      this.destroyed = true;
    }
  }, {
    key: "initDepthDrawParams",
    value: function initDepthDrawParams(_ref, drawParams) {
      var depth = _ref.depth;

      if (depth) {
        drawParams.depth = {
          enable: depth.enable === undefined ? true : !!depth.enable,
          mask: depth.mask === undefined ? true : !!depth.mask,
          func: _constants__WEBPACK_IMPORTED_MODULE_8__.depthFuncMap[depth.func || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.LESS],
          range: depth.range || [0, 1]
        };
      }
    }
  }, {
    key: "initBlendDrawParams",
    value: function initBlendDrawParams(_ref2, drawParams) {
      var blend = _ref2.blend;

      if (blend) {
        var enable = blend.enable,
            func = blend.func,
            equation = blend.equation,
            _blend$color = blend.color,
            color = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;
        drawParams.blend = {
          enable: !!enable,
          func: {
            srcRGB: _constants__WEBPACK_IMPORTED_MODULE_8__.blendFuncMap[func && func.srcRGB || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.SRC_ALPHA],
            srcAlpha: _constants__WEBPACK_IMPORTED_MODULE_8__.blendFuncMap[func && func.srcAlpha || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.SRC_ALPHA],
            dstRGB: _constants__WEBPACK_IMPORTED_MODULE_8__.blendFuncMap[func && func.dstRGB || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.ONE_MINUS_SRC_ALPHA],
            dstAlpha: _constants__WEBPACK_IMPORTED_MODULE_8__.blendFuncMap[func && func.dstAlpha || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.ONE_MINUS_SRC_ALPHA]
          },
          equation: {
            rgb: _constants__WEBPACK_IMPORTED_MODULE_8__.blendEquationMap[equation && equation.rgb || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FUNC_ADD],
            alpha: _constants__WEBPACK_IMPORTED_MODULE_8__.blendEquationMap[equation && equation.alpha || _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.FUNC_ADD]
          },
          color: color
        };
      }
    }
  }, {
    key: "initStencilDrawParams",
    value: function initStencilDrawParams(_ref3, drawParams) {
      var stencil = _ref3.stencil;

      if (stencil) {
        var enable = stencil.enable,
            _stencil$mask = stencil.mask,
            mask = _stencil$mask === void 0 ? -1 : _stencil$mask,
            _stencil$func = stencil.func,
            func = _stencil$func === void 0 ? {
          cmp: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.ALWAYS,
          ref: 0,
          mask: -1
        } : _stencil$func,
            _stencil$opFront = stencil.opFront,
            opFront = _stencil$opFront === void 0 ? {
          fail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP,
          zfail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP,
          zpass: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP
        } : _stencil$opFront,
            _stencil$opBack = stencil.opBack,
            opBack = _stencil$opBack === void 0 ? {
          fail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP,
          zfail: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP,
          zpass: _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.KEEP
        } : _stencil$opBack;
        drawParams.stencil = {
          enable: !!enable,
          mask: mask,
          func: _objectSpread(_objectSpread({}, func), {}, {
            cmp: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilFuncMap[func.cmp]
          }),
          opFront: {
            fail: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opFront.fail],
            zfail: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opFront.zfail],
            zpass: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opFront.zpass]
          },
          opBack: {
            fail: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opBack.fail],
            zfail: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opBack.zfail],
            zpass: _constants__WEBPACK_IMPORTED_MODULE_8__.stencilOpMap[opBack.zpass]
          }
        };
      }
    }
  }, {
    key: "initCullDrawParams",
    value: function initCullDrawParams(_ref4, drawParams) {
      var cull = _ref4.cull;

      if (cull) {
        var enable = cull.enable,
            _cull$face = cull.face,
            face = _cull$face === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_7__.gl.BACK : _cull$face;
        drawParams.cull = {
          enable: !!enable,
          face: _constants__WEBPACK_IMPORTED_MODULE_8__.cullFaceMap[face]
        };
      }
    }
  }, {
    key: "extractUniforms",
    value: function extractUniforms(uniforms) {
      var _this = this;

      var extractedUniforms = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        _this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');
      });
      return extractedUniforms;
    }
  }, {
    key: "extractUniformsRecursively",
    value: function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
      var _this2 = this;

      if (uniformValue === null || typeof uniformValue === 'number' || typeof uniformValue === 'boolean' || Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' || lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4___default()(uniformValue) || uniformValue === '' || 'resize' in uniformValue) {
        uniforms["".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;
        return;
      }

      if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default()(uniformValue)) {
        Object.keys(uniformValue).forEach(function (childName) {
          _this2.extractUniformsRecursively(childName, uniformValue[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName));
        });
      }

      if (Array.isArray(uniformValue)) {
        uniformValue.forEach(function (child, idx) {
          Object.keys(child).forEach(function (childName) {
            _this2.extractUniformsRecursively(childName, child[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName, "[").concat(idx, "]"));
          });
        });
      }
    }
  }]);

  return ReglModel;
}();


//# sourceMappingURL=ReglModel.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/ReglTexture2D.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/ReglTexture2D.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglTexture2D; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/l7-renderer/es/regl/constants.js");






var ReglTexture2D = function () {
  function ReglTexture2D(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ReglTexture2D);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "texture", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "width", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "height", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "isDistroy", false);

    var data = options.data,
        _options$type = options.type,
        type = _options$type === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.UNSIGNED_BYTE : _options$type,
        width = options.width,
        height = options.height,
        _options$flipY = options.flipY,
        flipY = _options$flipY === void 0 ? false : _options$flipY,
        _options$format = options.format,
        format = _options$format === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.RGBA : _options$format,
        _options$mipmap = options.mipmap,
        mipmap = _options$mipmap === void 0 ? false : _options$mipmap,
        _options$wrapS = options.wrapS,
        wrapS = _options$wrapS === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.CLAMP_TO_EDGE : _options$wrapS,
        _options$wrapT = options.wrapT,
        wrapT = _options$wrapT === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.CLAMP_TO_EDGE : _options$wrapT,
        _options$aniso = options.aniso,
        aniso = _options$aniso === void 0 ? 0 : _options$aniso,
        _options$alignment = options.alignment,
        alignment = _options$alignment === void 0 ? 1 : _options$alignment,
        _options$premultiplyA = options.premultiplyAlpha,
        premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA,
        _options$mag = options.mag,
        mag = _options$mag === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.NEAREST : _options$mag,
        _options$min = options.min,
        min = _options$min === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.NEAREST : _options$min,
        _options$colorSpace = options.colorSpace,
        colorSpace = _options$colorSpace === void 0 ? _antv_l7_core__WEBPACK_IMPORTED_MODULE_3__.gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace,
        _options$x = options.x,
        x = _options$x === void 0 ? 0 : _options$x,
        _options$y = options.y,
        y = _options$y === void 0 ? 0 : _options$y,
        _options$copy = options.copy,
        copy = _options$copy === void 0 ? false : _options$copy;
    this.width = width;
    this.height = height;
    var textureOptions = {
      width: width,
      height: height,
      type: _constants__WEBPACK_IMPORTED_MODULE_4__.dataTypeMap[type],
      format: _constants__WEBPACK_IMPORTED_MODULE_4__.formatMap[format],
      wrapS: _constants__WEBPACK_IMPORTED_MODULE_4__.wrapModeMap[wrapS],
      wrapT: _constants__WEBPACK_IMPORTED_MODULE_4__.wrapModeMap[wrapT],
      mag: _constants__WEBPACK_IMPORTED_MODULE_4__.filterMap[mag],
      min: _constants__WEBPACK_IMPORTED_MODULE_4__.filterMap[min],
      alignment: alignment,
      flipY: flipY,
      colorSpace: _constants__WEBPACK_IMPORTED_MODULE_4__.colorSpaceMap[colorSpace],
      premultiplyAlpha: premultiplyAlpha,
      aniso: aniso,
      x: x,
      y: y,
      copy: copy
    };

    if (data) {
      textureOptions.data = data;
    }

    if (typeof mipmap === 'number') {
      textureOptions.mipmap = _constants__WEBPACK_IMPORTED_MODULE_4__.mipmapMap[mipmap];
    } else if (typeof mipmap === 'boolean') {
      textureOptions.mipmap = mipmap;
    }

    this.texture = reGl.texture(textureOptions);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(ReglTexture2D, [{
    key: "get",
    value: function get() {
      return this.texture;
    }
  }, {
    key: "update",
    value: function update() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.texture(props);
    }
  }, {
    key: "bind",
    value: function bind() {
      this.texture._texture.bind();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
          height = _ref.height;
      this.texture.resize(width, height);
      this.width = width;
      this.height = height;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isDistroy) {
        var _this$texture;

        (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      }

      this.isDistroy = true;
    }
  }]);

  return ReglTexture2D;
}();


//# sourceMappingURL=ReglTexture2D.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/constants.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "primitiveMap": function() { return /* binding */ primitiveMap; },
/* harmony export */   "usageMap": function() { return /* binding */ usageMap; },
/* harmony export */   "dataTypeMap": function() { return /* binding */ dataTypeMap; },
/* harmony export */   "formatMap": function() { return /* binding */ formatMap; },
/* harmony export */   "mipmapMap": function() { return /* binding */ mipmapMap; },
/* harmony export */   "filterMap": function() { return /* binding */ filterMap; },
/* harmony export */   "wrapModeMap": function() { return /* binding */ wrapModeMap; },
/* harmony export */   "colorSpaceMap": function() { return /* binding */ colorSpaceMap; },
/* harmony export */   "depthFuncMap": function() { return /* binding */ depthFuncMap; },
/* harmony export */   "blendEquationMap": function() { return /* binding */ blendEquationMap; },
/* harmony export */   "blendFuncMap": function() { return /* binding */ blendFuncMap; },
/* harmony export */   "stencilFuncMap": function() { return /* binding */ stencilFuncMap; },
/* harmony export */   "stencilOpMap": function() { return /* binding */ stencilOpMap; },
/* harmony export */   "cullFaceMap": function() { return /* binding */ cullFaceMap; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");


var _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap;


var primitiveMap = (_primitiveMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.POINTS, 'points'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINES, 'lines'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINE_LOOP, 'line loop'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINE_STRIP, 'line strip'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLES, 'triangles'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLE_FAN, 'triangle fan'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_primitiveMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLE_STRIP, 'triangle strip'), _primitiveMap);
var usageMap = (_usageMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_usageMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.STATIC_DRAW, 'static'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_usageMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DYNAMIC_DRAW, 'dynamic'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_usageMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.STREAM_DRAW, 'stream'), _usageMap);
var dataTypeMap = (_dataTypeMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.BYTE, 'int8'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_INT, 'int16'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.INT, 'int32'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_BYTE, 'uint8'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_SHORT, 'uint16'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_INT, 'uint32'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_dataTypeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FLOAT, 'float'), _dataTypeMap);
var formatMap = (_formatMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALPHA, 'alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LUMINANCE, 'luminance'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LUMINANCE_ALPHA, 'luminance alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB, 'rgb'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGBA, 'rgba'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGBA4, 'rgba4'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB5_A1, 'rgb5 a1'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB565, 'rgb565'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DEPTH_COMPONENT, 'depth'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_formatMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DEPTH_STENCIL, 'depth stencil'), _formatMap);
var mipmapMap = (_mipmapMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_mipmapMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DONT_CARE, 'dont care'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_mipmapMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NICEST, 'nice'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_mipmapMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FASTEST, 'fast'), _mipmapMap);
var filterMap = (_filterMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST, 'nearest'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR, 'linear'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR_MIPMAP_LINEAR, 'mipmap'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST_MIPMAP_LINEAR, 'nearest mipmap linear'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR_MIPMAP_NEAREST, 'linear mipmap nearest'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_filterMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST_MIPMAP_NEAREST, 'nearest mipmap nearest'), _filterMap);
var wrapModeMap = (_wrapModeMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_wrapModeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.REPEAT, 'repeat'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_wrapModeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.CLAMP_TO_EDGE, 'clamp'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_wrapModeMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.MIRRORED_REPEAT, 'mirror'), _wrapModeMap);
var colorSpaceMap = (_colorSpaceMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_colorSpaceMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NONE, 'none'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_colorSpaceMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.BROWSER_DEFAULT_WEBGL, 'browser'), _colorSpaceMap);
var depthFuncMap = (_depthFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEVER, 'never'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALWAYS, 'always'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LESS, 'less'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LEQUAL, 'lequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.GREATER, 'greater'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.GEQUAL, 'gequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.EQUAL, 'equal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_depthFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NOTEQUAL, 'notequal'), _depthFuncMap);
var blendEquationMap = (_blendEquationMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendEquationMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_ADD, 'add'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendEquationMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.MIN_EXT, 'min'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendEquationMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.MAX_EXT, 'max'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendEquationMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_SUBTRACT, 'subtract'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendEquationMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_REVERSE_SUBTRACT, 'reverse subtract'), _blendEquationMap);
var blendFuncMap = (_blendFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ZERO, 'zero'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE, 'one'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_COLOR, 'src color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_COLOR, 'one minus src color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_ALPHA, 'src alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_ALPHA, 'one minus src alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DST_COLOR, 'dst color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_DST_COLOR, 'one minus dst color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DST_ALPHA, 'dst alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_DST_ALPHA, 'one minus dst alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.CONSTANT_COLOR, 'constant color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_CONSTANT_COLOR, 'one minus constant color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.CONSTANT_ALPHA, 'constant alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_CONSTANT_ALPHA, 'one minus constant alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_blendFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_ALPHA_SATURATE, 'src alpha saturate'), _blendFuncMap);
var stencilFuncMap = (_stencilFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEVER, 'never'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALWAYS, 'always'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LESS, 'less'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.LEQUAL, 'lequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.GREATER, 'greater'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.GEQUAL, 'gequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.EQUAL, 'equal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilFuncMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.NOTEQUAL, 'notequal'), _stencilFuncMap);
var stencilOpMap = (_stencilOpMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.ZERO, 'zero'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.KEEP, 'keep'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.REPLACE, 'replace'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.INVERT, 'invert'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.INCR, 'increment'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DECR, 'decrement'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.INCR_WRAP, 'increment wrap'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_stencilOpMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.DECR_WRAP, 'decrement wrap'), _stencilOpMap);
var cullFaceMap = (_cullFaceMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_cullFaceMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.FRONT, 'front'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_cullFaceMap, _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl.BACK, 'back'), _cullFaceMap);
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-renderer/es/regl/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/l7-renderer/es/regl/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ReglRendererService; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var inversify__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! inversify */ "./node_modules/inversify/lib/inversify.js");
/* harmony import */ var l7regl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! l7regl */ "./node_modules/l7regl/dist/regl.js");
/* harmony import */ var l7regl__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(l7regl__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _ReglAttribute__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ReglAttribute */ "./node_modules/@antv/l7-renderer/es/regl/ReglAttribute.js");
/* harmony import */ var _ReglBuffer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ReglBuffer */ "./node_modules/@antv/l7-renderer/es/regl/ReglBuffer.js");
/* harmony import */ var _ReglElements__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ReglElements */ "./node_modules/@antv/l7-renderer/es/regl/ReglElements.js");
/* harmony import */ var _ReglFramebuffer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ReglFramebuffer */ "./node_modules/@antv/l7-renderer/es/regl/ReglFramebuffer.js");
/* harmony import */ var _ReglModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ReglModel */ "./node_modules/@antv/l7-renderer/es/regl/ReglModel.js");
/* harmony import */ var _ReglTexture2D__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ReglTexture2D */ "./node_modules/@antv/l7-renderer/es/regl/ReglTexture2D.js");





var _dec, _class;












var ReglRendererService = (_dec = (0,inversify__WEBPACK_IMPORTED_MODULE_6__.injectable)(), _dec(_class = function () {
  function ReglRendererService() {
    var _this = this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, ReglRendererService);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "extensionObject", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "gl", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "$container", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "canvas", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "width", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "height", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "isDirty", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createModel", function (options) {
      return new _ReglModel__WEBPACK_IMPORTED_MODULE_9__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createAttribute", function (options) {
      return new _ReglAttribute__WEBPACK_IMPORTED_MODULE_10__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createBuffer", function (options) {
      return new _ReglBuffer__WEBPACK_IMPORTED_MODULE_11__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createElements", function (options) {
      return new _ReglElements__WEBPACK_IMPORTED_MODULE_12__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createTexture2D", function (options) {
      return new _ReglTexture2D__WEBPACK_IMPORTED_MODULE_13__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "createFramebuffer", function (options) {
      return new _ReglFramebuffer__WEBPACK_IMPORTED_MODULE_14__.default(_this.gl, options);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "useFramebuffer", function (framebuffer, drawCommands) {
      _this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "clear", function (options) {
      var _this$gl;

      var color = options.color,
          depth = options.depth,
          stencil = options.stencil,
          _options$framebuffer = options.framebuffer,
          framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
      var reglClearOptions = {
        color: color,
        depth: depth,
        stencil: stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      (_this$gl = _this.gl) === null || _this$gl === void 0 ? void 0 : _this$gl.clear(reglClearOptions);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "viewport", function (_ref) {
      var x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height;

      _this.gl._gl.viewport(x, y, width, height);

      _this.width = width;
      _this.height = height;

      _this.gl._refresh();
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "readPixels", function (options) {
      var framebuffer = options.framebuffer,
          x = options.x,
          y = options.y,
          width = options.width,
          height = options.height;
      var readPixelsOptions = {
        x: x,
        y: y,
        width: width,
        height: height
      };

      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }

      return _this.gl.read(readPixelsOptions);
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "getViewportSize", function () {
      return {
        width: _this.gl._gl.drawingBufferWidth,
        height: _this.gl._gl.drawingBufferHeight
      };
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "getContainer", function () {
      if (_antv_l7_utils__WEBPACK_IMPORTED_MODULE_5__.isMini) {
        return _this.canvas;
      } else {
        var _this$canvas;

        return (_this$canvas = _this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.parentElement;
      }
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "getCanvas", function () {
      return _this.canvas;
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "getGLContext", function () {
      return _this.gl._gl;
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "destroy", function () {
      _this.canvas = null;

      _this.gl.destroy();

      _this.gl = null;
    });
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(ReglRendererService, [{
    key: "init",
    value: function () {
      var _init = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee(canvas, cfg) {
        var _this2 = this;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.canvas = canvas;
                _context.next = 3;
                return new Promise(function (resolve, reject) {
                  l7regl__WEBPACK_IMPORTED_MODULE_7___default()({
                    canvas: _this2.canvas,
                    attributes: {
                      alpha: true,
                      antialias: cfg.antialias,
                      premultipliedAlpha: true,
                      preserveDrawingBuffer: cfg.preserveDrawingBuffer,
                      stencil: cfg.stencil
                    },
                    extensions: ['OES_element_index_uint', 'OES_standard_derivatives', 'ANGLE_instanced_arrays'],
                    optionalExtensions: ['oes_texture_float_linear', 'OES_texture_float', 'EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture'],
                    profile: true,
                    onDone: function onDone(err, r) {
                      if (err || !r) {
                        reject(err);
                      }

                      resolve(r);
                    }
                  });
                });

              case 3:
                this.gl = _context.sent;
                this.extensionObject = {
                  OES_texture_float: this.testExtension('OES_texture_float')
                };

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x, _x2) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getPointSizeRange",
    value: function getPointSizeRange() {
      return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE);
    }
  }, {
    key: "testExtension",
    value: function testExtension(name) {
      return !!this.getGLContext().getExtension(name);
    }
  }, {
    key: "setState",
    value: function setState() {
      this.gl({
        cull: {
          enable: false,
          face: 'back'
        },
        viewport: {
          x: 0,
          y: 0,
          height: this.width,
          width: this.height
        },
        blend: {
          enable: true,
          equation: 'add'
        },
        framebuffer: null
      });

      this.gl._refresh();
    }
  }, {
    key: "setBaseState",
    value: function setBaseState() {
      this.gl({
        cull: {
          enable: false,
          face: 'back'
        },
        viewport: {
          x: 0,
          y: 0,
          height: this.width,
          width: this.height
        },
        blend: {
          enable: false,
          equation: 'add'
        },
        framebuffer: null
      });

      this.gl._refresh();
    }
  }, {
    key: "setCustomLayerDefaults",
    value: function setCustomLayerDefaults() {
      var gl = this.getGLContext();
      gl.disable(gl.CULL_FACE);
    }
  }, {
    key: "setDirty",
    value: function setDirty(flag) {
      this.isDirty = flag;
    }
  }, {
    key: "getDirty",
    value: function getDirty() {
      return this.isDirty;
    }
  }]);

  return ReglRendererService;
}()) || _class);

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-scene/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/l7-scene/es/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": function() { return /* binding */ Scene; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_l7_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-component */ "./node_modules/@antv/l7-component/es/index.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_layers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-layers */ "./node_modules/@antv/l7-layers/es/index.js");
/* harmony import */ var _antv_l7_renderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/l7-renderer */ "./node_modules/@antv/l7-renderer/es/regl/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");





function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







var Scene = function () {
  function Scene(config) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, Scene);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "sceneService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "controlService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "layerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "iconService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "markerService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "popupService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "fontService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "interactionService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(this, "container", void 0);

    var id = config.id,
        map = config.map,
        canvas = config.canvas,
        hasBaseMap = config.hasBaseMap;
    var sceneContainer = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.createSceneContainer)();
    this.container = sceneContainer;
    map.setContainer(sceneContainer, id, canvas, hasBaseMap);
    sceneContainer.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IRendererService).to(_antv_l7_renderer__WEBPACK_IMPORTED_MODULE_8__.default).inSingletonScope();
    this.sceneService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.ISceneService);
    this.mapService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IMapService);
    this.iconService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IIconService);
    this.fontService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IFontService);
    this.controlService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IControlService);
    this.layerService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.ILayerService);
    this.markerService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IMarkerService);
    this.interactionService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IInteractionService);
    this.popupService = sceneContainer.get(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IPopupService);

    if (_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.isMini) {
      this.sceneService.initMiniScene(config);
    } else {
      this.initComponent(id);
      this.sceneService.init(config);
      this.initControl();
    }
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(Scene, [{
    key: "map",
    get: function get() {
      return this.mapService.map;
    }
  }, {
    key: "loaded",
    get: function get() {
      return this.sceneService.loaded;
    }
  }, {
    key: "getServiceContainer",
    value: function getServiceContainer() {
      return this.container;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.mapService.getSize();
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return this.mapService.getMinZoom();
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return this.mapService.getMaxZoom();
    }
  }, {
    key: "getType",
    value: function getType() {
      return this.mapService.getType();
    }
  }, {
    key: "getMapContainer",
    value: function getMapContainer() {
      return this.mapService.getMapContainer();
    }
  }, {
    key: "getMapCanvasContainer",
    value: function getMapCanvasContainer() {
      return this.mapService.getMapCanvasContainer();
    }
  }, {
    key: "getMapService",
    value: function getMapService() {
      return this.mapService;
    }
  }, {
    key: "exportPng",
    value: function exportPng(type) {
      return this.sceneService.exportPng(type);
    }
  }, {
    key: "exportMap",
    value: function exportMap(type) {
      return this.sceneService.exportPng(type);
    }
  }, {
    key: "registerRenderService",
    value: function registerRenderService(render) {
      var _this = this;

      if (this.sceneService.loaded) {
        var renderSerivce = new render(this);
        renderSerivce.init();
      } else {
        this.on('loaded', function () {
          var renderSerivce = new render(_this);
          renderSerivce.init();
        });
      }
    }
  }, {
    key: "setBgColor",
    value: function setBgColor(color) {
      this.mapService.setBgColor(color);
    }
  }, {
    key: "addLayer",
    value: function addLayer(layer) {
      var layerContainer = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.createLayerContainer)(this.container);
      layer.setContainer(layerContainer, this.container);
      this.sceneService.addLayer(layer);
      var layerConfig = layer.getLayerConfig();

      if (layerConfig) {
        var mask = layerConfig.mask,
            maskfence = layerConfig.maskfence,
            _layerConfig$maskColo = layerConfig.maskColor,
            maskColor = _layerConfig$maskColo === void 0 ? '#000' : _layerConfig$maskColo,
            _layerConfig$maskOpac = layerConfig.maskOpacity,
            maskOpacity = _layerConfig$maskOpac === void 0 ? 0 : _layerConfig$maskOpac;

        if (mask && maskfence) {
          var maskInstance = new _antv_l7_layers__WEBPACK_IMPORTED_MODULE_6__.MaskLayer().source(maskfence).shape('fill').color(maskColor).style({
            opacity: maskOpacity
          });
          this.addMask(maskInstance, layer.id);
        }
      } else {
        console.warn('addLayer should run after scene loaded!');
      }
    }
  }, {
    key: "addMask",
    value: function addMask(mask, layerId) {
      var parent = this.getLayer(layerId);

      if (parent) {
        var layerContainer = (0,_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.createLayerContainer)(this.container);
        mask.setContainer(layerContainer, this.container);
        parent.addMaskLayer(mask);
        this.sceneService.addLayer(mask);
      } else {
        console.warn('parent layer not find!');
      }
    }
  }, {
    key: "getPickedLayer",
    value: function getPickedLayer() {
      return this.layerService.pickedLayerId;
    }
  }, {
    key: "getLayers",
    value: function getLayers() {
      return this.layerService.getLayers();
    }
  }, {
    key: "getLayer",
    value: function getLayer(id) {
      return this.layerService.getLayer(id);
    }
  }, {
    key: "getLayerByName",
    value: function getLayerByName(name) {
      return this.layerService.getLayerByName(name);
    }
  }, {
    key: "removeLayer",
    value: function removeLayer(layer, parentLayer) {
      this.layerService.remove(layer, parentLayer);
    }
  }, {
    key: "removeAllLayer",
    value: function removeAllLayer() {
      this.layerService.removeAllLayers();
    }
  }, {
    key: "render",
    value: function render() {
      this.sceneService.render();
    }
  }, {
    key: "setEnableRender",
    value: function setEnableRender(flag) {
      this.layerService.setEnableRender(flag);
    }
  }, {
    key: "addIconFont",
    value: function addIconFont(name, fontUnicode) {
      this.fontService.addIconFont(name, fontUnicode);
    }
  }, {
    key: "addIconFonts",
    value: function addIconFonts(options) {
      var _this2 = this;

      options.forEach(function (_ref) {
        var _ref2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, 2),
            name = _ref2[0],
            fontUnicode = _ref2[1];

        _this2.fontService.addIconFont(name, fontUnicode);
      });
    }
  }, {
    key: "addFontFace",
    value: function addFontFace(fontFamily, fontPath) {
      this.sceneService.addFontFace(fontFamily, fontPath);
    }
  }, {
    key: "addImage",
    value: function addImage(id, img) {
      if (!_antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.isMini) {
        this.iconService.addImage(id, img);
      } else {
        this.iconService.addImageMini(id, img, this.sceneService);
      }
    }
  }, {
    key: "hasImage",
    value: function hasImage(id) {
      return this.iconService.hasImage(id);
    }
  }, {
    key: "removeImage",
    value: function removeImage(id) {
      this.iconService.removeImage(id);
    }
  }, {
    key: "addIconFontGlyphs",
    value: function addIconFontGlyphs(fontFamily, glyphs) {
      this.fontService.addIconGlyphs(glyphs);
    }
  }, {
    key: "addControl",
    value: function addControl(ctr) {
      this.controlService.addControl(ctr, this.container);
    }
  }, {
    key: "removeControl",
    value: function removeControl(ctr) {
      this.controlService.removeControl(ctr);
    }
  }, {
    key: "getControlByName",
    value: function getControlByName(name) {
      return this.controlService.getControlByName(name);
    }
  }, {
    key: "addMarker",
    value: function addMarker(marker) {
      this.markerService.addMarker(marker);
    }
  }, {
    key: "addMarkerLayer",
    value: function addMarkerLayer(layer) {
      this.markerService.addMarkerLayer(layer);
    }
  }, {
    key: "removeMarkerLayer",
    value: function removeMarkerLayer(layer) {
      this.markerService.removeMarkerLayer(layer);
    }
  }, {
    key: "removeAllMakers",
    value: function removeAllMakers() {
      this.markerService.removeAllMarkers();
    }
  }, {
    key: "addPopup",
    value: function addPopup(popup) {
      this.popupService.addPopup(popup);
    }
  }, {
    key: "on",
    value: function on(type, handle) {
      _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.SceneEventList.indexOf(type) === -1 ? this.mapService.on(type, handle) : this.sceneService.on(type, handle);
    }
  }, {
    key: "once",
    value: function once(type, handle) {
      _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.SceneEventList.indexOf(type) === -1 ? this.mapService.once(type, handle) : this.sceneService.once(type, handle);
    }
  }, {
    key: "off",
    value: function off(type, handle) {
      _antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.SceneEventList.indexOf(type) === -1 ? this.mapService.off(type, handle) : this.sceneService.off(type, handle);
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.mapService.getZoom();
    }
  }, {
    key: "getCenter",
    value: function getCenter(options) {
      return this.mapService.getCenter(options);
    }
  }, {
    key: "setCenter",
    value: function setCenter(center, options) {
      return this.mapService.setCenter(center, options);
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.mapService.getPitch();
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      return this.mapService.setPitch(pitch);
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.mapService.getRotation();
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      return this.mapService.getBounds();
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.mapService.setRotation(rotation);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.mapService.zoomIn();
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.mapService.zoomOut();
    }
  }, {
    key: "panTo",
    value: function panTo(p) {
      this.mapService.panTo(p);
    }
  }, {
    key: "panBy",
    value: function panBy(x, y) {
      this.mapService.panBy(x, y);
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.mapService.getContainer();
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.mapService.setZoom(zoom);
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bound, options) {
      var _this$sceneService$ge = this.sceneService.getSceneConfig(),
          fitBoundsOptions = _this$sceneService$ge.fitBoundsOptions,
          animate = _this$sceneService$ge.animate;

      this.mapService.fitBounds(bound, options || _objectSpread(_objectSpread({}, fitBoundsOptions), {}, {
        animate: animate
      }));
    }
  }, {
    key: "setZoomAndCenter",
    value: function setZoomAndCenter(zoom, center) {
      this.mapService.setZoomAndCenter(zoom, center);
    }
  }, {
    key: "setMapStyle",
    value: function setMapStyle(style) {
      this.mapService.setMapStyle(style);
    }
  }, {
    key: "setMapStatus",
    value: function setMapStatus(options) {
      this.mapService.setMapStatus(options);
    }
  }, {
    key: "pixelToLngLat",
    value: function pixelToLngLat(pixel) {
      return this.mapService.pixelToLngLat(pixel);
    }
  }, {
    key: "lngLatToPixel",
    value: function lngLatToPixel(lnglat) {
      return this.mapService.lngLatToPixel(lnglat);
    }
  }, {
    key: "containerToLngLat",
    value: function containerToLngLat(pixel) {
      return this.mapService.containerToLngLat(pixel);
    }
  }, {
    key: "lngLatToContainer",
    value: function lngLatToContainer(lnglat) {
      return this.mapService.lngLatToContainer(lnglat);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.sceneService.destroy();
    }
  }, {
    key: "registerPostProcessingPass",
    value: function registerPostProcessingPass(constructor, name) {
      this.container.bind(_antv_l7_core__WEBPACK_IMPORTED_MODULE_5__.TYPES.IPostProcessingPass).to(constructor).whenTargetNamed(name);
    }
  }, {
    key: "enableShaderPick",
    value: function enableShaderPick() {
      this.layerService.enableShaderPick();
    }
  }, {
    key: "diasbleShaderPick",
    value: function diasbleShaderPick() {
      this.layerService.disableShaderPick();
    }
  }, {
    key: "getPointSizeRange",
    value: function getPointSizeRange() {
      return this.sceneService.getPointSizeRange();
    }
  }, {
    key: "initComponent",
    value: function initComponent(id) {
      this.controlService.init({
        container: _antv_l7_utils__WEBPACK_IMPORTED_MODULE_7__.DOM.getContainer(id)
      }, this.container);
      this.markerService.init(this.container);
      this.popupService.init(this.container);
    }
  }, {
    key: "initControl",
    value: function initControl() {
      var _this$sceneService$ge2 = this.sceneService.getSceneConfig(),
          logoVisible = _this$sceneService$ge2.logoVisible,
          logoPosition = _this$sceneService$ge2.logoPosition;

      if (logoVisible) {
        this.addControl(new _antv_l7_component__WEBPACK_IMPORTED_MODULE_4__.Logo({
          position: logoPosition
        }));
      }
    }
  }]);

  return Scene;
}();


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/factory.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/factory.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getParser": function() { return /* binding */ getParser; },
/* harmony export */   "registerParser": function() { return /* binding */ registerParser; },
/* harmony export */   "getTransform": function() { return /* binding */ getTransform; },
/* harmony export */   "registerTransform": function() { return /* binding */ registerTransform; }
/* harmony export */ });
var TRANSFORMS = {};
var PARSERS = {};
var getParser = function getParser(type) {
  return PARSERS[type];
};
var registerParser = function registerParser(type, parserFunction) {
  PARSERS[type] = parserFunction;
};
var getTransform = function getTransform(type) {
  return TRANSFORMS[type];
};
var registerTransform = function registerTransform(type, transFunction) {
  TRANSFORMS[type] = transFunction;
};
//# sourceMappingURL=factory.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTransform": function() { return /* reexport safe */ _factory__WEBPACK_IMPORTED_MODULE_0__.getTransform; },
/* harmony export */   "registerTransform": function() { return /* reexport safe */ _factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform; },
/* harmony export */   "getParser": function() { return /* reexport safe */ _factory__WEBPACK_IMPORTED_MODULE_0__.getParser; },
/* harmony export */   "registerParser": function() { return /* reexport safe */ _factory__WEBPACK_IMPORTED_MODULE_0__.registerParser; },
/* harmony export */   "RasterTileType": function() { return /* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_15__.RasterTileType; },
/* harmony export */   "DEFAULT_DATA": function() { return /* binding */ DEFAULT_DATA; },
/* harmony export */   "DEFAULT_PARSER": function() { return /* binding */ DEFAULT_PARSER; }
/* harmony export */ });
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./factory */ "./node_modules/@antv/l7-source/es/factory.js");
/* harmony import */ var _parser_csv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser/csv */ "./node_modules/@antv/l7-source/es/parser/csv.js");
/* harmony import */ var _parser_geojson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/geojson */ "./node_modules/@antv/l7-source/es/parser/geojson.js");
/* harmony import */ var _parser_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/image */ "./node_modules/@antv/l7-source/es/parser/image.js");
/* harmony import */ var _parser_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser/json */ "./node_modules/@antv/l7-source/es/parser/json.js");
/* harmony import */ var _parser_mvt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser/mvt */ "./node_modules/@antv/l7-source/es/parser/mvt.js");
/* harmony import */ var _parser_raster__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser/raster */ "./node_modules/@antv/l7-source/es/parser/raster.js");
/* harmony import */ var _parser_raster_tile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parser/raster-tile */ "./node_modules/@antv/l7-source/es/parser/raster-tile.js");
/* harmony import */ var _source__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source */ "./node_modules/@antv/l7-source/es/source.js");
/* harmony import */ var _transform_cluster__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transform/cluster */ "./node_modules/@antv/l7-source/es/transform/cluster.js");
/* harmony import */ var _transform_filter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./transform/filter */ "./node_modules/@antv/l7-source/es/transform/filter.js");
/* harmony import */ var _transform_grid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform/grid */ "./node_modules/@antv/l7-source/es/transform/grid.js");
/* harmony import */ var _transform_hexagon__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/hexagon */ "./node_modules/@antv/l7-source/es/transform/hexagon.js");
/* harmony import */ var _transform_join__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./transform/join */ "./node_modules/@antv/l7-source/es/transform/join.js");
/* harmony import */ var _transform_map__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./transform/map */ "./node_modules/@antv/l7-source/es/transform/map.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interface */ "./node_modules/@antv/l7-source/es/interface.js");















(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('rasterTile', _parser_raster_tile__WEBPACK_IMPORTED_MODULE_7__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('mvt', _parser_mvt__WEBPACK_IMPORTED_MODULE_5__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('geojson', _parser_geojson__WEBPACK_IMPORTED_MODULE_2__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('image', _parser_image__WEBPACK_IMPORTED_MODULE_3__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('csv', _parser_csv__WEBPACK_IMPORTED_MODULE_1__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('json', _parser_json__WEBPACK_IMPORTED_MODULE_4__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerParser)('raster', _parser_raster__WEBPACK_IMPORTED_MODULE_6__.default);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('cluster', _transform_cluster__WEBPACK_IMPORTED_MODULE_9__.cluster);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('filter', _transform_filter__WEBPACK_IMPORTED_MODULE_10__.filter);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('join', _transform_join__WEBPACK_IMPORTED_MODULE_13__.join);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('map', _transform_map__WEBPACK_IMPORTED_MODULE_14__.map);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('grid', _transform_grid__WEBPACK_IMPORTED_MODULE_11__.aggregatorToGrid);
(0,_factory__WEBPACK_IMPORTED_MODULE_0__.registerTransform)('hexagon', _transform_hexagon__WEBPACK_IMPORTED_MODULE_12__.pointToHexbin);


var DEFAULT_DATA = _parser_json__WEBPACK_IMPORTED_MODULE_4__.defaultData;
var DEFAULT_PARSER = _parser_json__WEBPACK_IMPORTED_MODULE_4__.defaultParser;
/* harmony default export */ __webpack_exports__["default"] = (_source__WEBPACK_IMPORTED_MODULE_8__.default);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/interface.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RasterTileType": function() { return /* binding */ RasterTileType; }
/* harmony export */ });
var RasterTileType;

(function (RasterTileType) {
  RasterTileType["IMAGE"] = "image";
  RasterTileType["ARRAYBUFFER"] = "arraybuffer";
})(RasterTileType || (RasterTileType = {}));
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/csv.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/csv.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ csv; }
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var _json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json */ "./node_modules/@antv/l7-source/es/parser/json.js");


function csv(data, cfg) {
  var csvData = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParse)(data);
  return (0,_json__WEBPACK_IMPORTED_MODULE_0__.default)(csvData, cfg);
}
//# sourceMappingURL=csv.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/geojson.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/geojson.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ geoJSON; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mapbox/geojson-rewind */ "./node_modules/@mapbox/geojson-rewind/index.js");
/* harmony import */ var _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/dist/es/index.js");
/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/dist/es/index.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





function djb2hash(field) {
  var str = field.toString();
  var hash = 5381;
  var i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  return hash >>> 0;
}

function getFeatureID(feature, key) {
  if (key === undefined) {
    return null;
  }

  if (key === 'id' && feature.id) {
    return feature.id;
  }

  if (feature[key]) {
    return feature[key];
  }

  if (feature.properties && feature.properties[key]) {
    return djb2hash(feature.properties[key] + '') % 1000019;
  }

  return null;
}

function geoJSON(data, cfg) {
  var resultData = [];
  var featureKeys = {};

  if (!data.features) {
    data.features = [];
    return {
      dataArray: []
    };
  }

  data.features = data.features.filter(function (item) {
    var geometry = item.geometry;
    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;
  });
  _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_1___default()(data, true);

  if (data.features.length === 0) {
    return {
      dataArray: [],
      featureKeys: featureKeys
    };
  }

  _turf_meta__WEBPACK_IMPORTED_MODULE_3__.flattenEach(data, function (currentFeature, featureIndex) {
    var featureId = getFeatureID(currentFeature, cfg === null || cfg === void 0 ? void 0 : cfg.featureId);

    if (featureId === null) {
      featureId = featureIndex;
    }

    var sortedID = featureId;
    var coord = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(currentFeature);

    var dataItem = _objectSpread(_objectSpread({}, currentFeature.properties), {}, {
      coordinates: coord,
      _id: sortedID
    });

    resultData.push(dataItem);
  });
  return {
    dataArray: resultData,
    featureKeys: featureKeys
  };
}
//# sourceMappingURL=geojson.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/image.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/image.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ image; }
/* harmony export */ });
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");

function image(data, cfg) {
  var _cfg$extent = cfg.extent,
      extent = _cfg$extent === void 0 ? [121.168, 30.2828, 121.384, 30.4219] : _cfg$extent;
  var images = new Promise(function (resolve) {
    if (data instanceof HTMLImageElement || (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.isImageBitmap)(data)) {
      resolve([data]);
    } else {
      loadData(data, function (res) {
        resolve(res);
      });
    }
  });
  var resultData = {
    originData: data,
    images: images,
    _id: 1,
    dataArray: [{
      _id: 0,
      coordinates: [[extent[0], extent[1]], [extent[2], extent[3]]]
    }]
  };
  return resultData;
}

function loadData(data, done) {
  var url = data;
  var imageDatas = [];

  if (typeof url === 'string') {
    (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.getImage)({
      url: url
    }, function (err, img) {
      if (img) {
        imageDatas.push(img);
        done(imageDatas);
      }
    });
  } else {
    var imageCount = url.length;
    var imageindex = 0;
    url.forEach(function (item) {
      (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.getImage)({
        url: item
      }, function (err, img) {
        imageindex++;

        if (img) {
          imageDatas.push(img);
        }

        if (imageindex === imageCount) {
          done(imageDatas);
        }
      });
    });
  }

  return image;
}
//# sourceMappingURL=image.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/json.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/json.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ json; },
/* harmony export */   "defaultData": function() { return /* binding */ defaultData; },
/* harmony export */   "defaultParser": function() { return /* binding */ defaultParser; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mapbox/geojson-rewind */ "./node_modules/@mapbox/geojson-rewind/index.js");
/* harmony import */ var _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_2__);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


function json(data, cfg) {
  var x = cfg.x,
      y = cfg.y,
      x1 = cfg.x1,
      y1 = cfg.y1,
      coordinates = cfg.coordinates;
  var resultData = [];

  if (!Array.isArray(data)) {
    return {
      dataArray: []
    };
  }

  data.forEach(function (col, featureIndex) {
    var coords = [];

    if (x && y) {
      coords = [parseFloat(col[x]), parseFloat(col[y])];
    }

    if (x && y && x1 && y1) {
      var from = [parseFloat(col[x]), parseFloat(col[y])];
      var to = [parseFloat(col[x1]), parseFloat(col[y1])];
      coords = [from, to];
    }

    if (coordinates) {
      var type = 'Polygon';

      if (!Array.isArray(coordinates[0])) {
        type = 'Point';
      }

      if (Array.isArray(coordinates[0]) && !Array.isArray(coordinates[0][0])) {
        type = 'LineString';
      }

      var geometry = {
        type: type,
        coordinates: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(col[coordinates])
      };
      _mapbox_geojson_rewind__WEBPACK_IMPORTED_MODULE_2___default()(geometry, true);
      coords = geometry.coordinates;
    }

    var dataItem = _objectSpread(_objectSpread({}, col), {}, {
      _id: featureIndex,
      coordinates: coords
    });

    resultData.push(dataItem);
  });
  return {
    dataArray: resultData
  };
}
var defaultData = [{
  lng1: 100,
  lat1: 30.0,
  lng2: 130,
  lat2: 30
}];
var defaultParser = {
  parser: {
    type: 'json',
    x: 'lng1',
    y: 'lat1',
    x1: 'lng2',
    y1: 'lat2'
  }
};
//# sourceMappingURL=json.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/mvt.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/mvt.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "osmTileXY2LonLat": function() { return /* binding */ osmTileXY2LonLat; },
/* harmony export */   "default": function() { return /* binding */ mapboxVectorTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mapbox/vector-tile */ "./node_modules/@mapbox/vector-tile/index.js");
/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pbf */ "./node_modules/pbf/index.js");
/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(pbf__WEBPACK_IMPORTED_MODULE_5__);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
var TILE_SIZE = 512;
function osmTileXY2LonLat(x, y, zoom) {
  var lon = x / Math.pow(2, zoom) * 360 - 180;
  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
  var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lon, lat];
}

function signedArea(ring) {
  var sum = 0;

  for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2.x - p1.x) * (p1.y + p2.y);
  }

  return sum;
}

function classifyRings(rings) {
  var len = rings.length;

  if (len <= 1) {
    return [rings];
  }

  var polygons = [];
  var polygon;
  var ccw;

  for (var i = 0; i < len; i++) {
    var area = signedArea(rings[i]);

    if (area === 0) {
      continue;
    }

    if (ccw === undefined) {
      ccw = area < 0;
    }

    if (ccw === area < 0) {
      if (polygon) {
        polygons.push(polygon);
      }

      polygon = [rings[i]];
    } else {
      polygon.push(rings[i]);
    }
  }

  if (polygon) {
    polygons.push(polygon);
  }

  return polygons;
}

var VectorTileFeatureTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

function GetGeoJSON(z, vectorTileFeature) {
  var extent = vectorTileFeature.extent;
  var coords = vectorTileFeature.loadGeometry();
  var currenType = vectorTileFeature.type;
  var currentProperties = vectorTileFeature.properties;
  var currentId = vectorTileFeature.id;
  var size = extent * Math.pow(2, z);
  var type = VectorTileFeatureTypes[currenType];
  var i;
  var j;

  function project(line) {
    for (var index = 0; index < line.length; index++) {
      var point = line[index];
      line[index] = [point.x / size * TILE_SIZE, point.y / size * TILE_SIZE];
    }
  }

  switch (currenType) {
    case 1:
      var points = [];

      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }

      coords = points;
      project(coords);
      break;

    case 2:
      for (i = 0; i < coords.length; i++) {
        project(coords[i]);
      }

      break;

    case 3:
      coords = classifyRings(coords);

      for (i = 0; i < coords.length; i++) {
        for (j = 0; j < coords[i].length; j++) {
          project(coords[i][j]);
        }
      }

      break;
  }

  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = 'Multi' + type;
  }

  var result = {
    type: 'Feature',
    geometry: {
      type: type,
      coordinates: coords
    },
    properties: currentProperties,
    id: currentId,
    tileOrigin: [0, 0],
    coord: ''
  };
  return result;
}

var getVectorTile = function () {
  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee(url, tileParams, tile, coord) {
    var tileUrl;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tileUrl = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.getURLFromTemplate)(url, tileParams);
            return _context.abrupt("return", new Promise(function (resolve) {
              var xhr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_3__.getArrayBuffer)({
                url: tileUrl
              }, function (err, data) {
                if (err || !data) {
                  resolve({
                    layers: {}
                  });
                } else {
                  var vectorTile = new _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_4__.VectorTile(new (pbf__WEBPACK_IMPORTED_MODULE_5___default())(data));
                  var tileOrigin = osmTileXY2LonLat(tileParams.x, tileParams.y, tileParams.z);
                  var zoom = tileParams.z;

                  for (var _i = 0, _Object$keys = Object.keys(vectorTile.layers); _i < _Object$keys.length; _i++) {
                    var sourceLayer = _Object$keys[_i];
                    var features = [];
                    var vectorTileLayer = vectorTile.layers[sourceLayer];

                    for (var i = 0; i < vectorTile.layers[sourceLayer].length; i++) {
                      var vectorTileFeature = vectorTile.layers[sourceLayer].feature(i);
                      var feature = void 0;

                      if (coord === 'lnglat') {
                        feature = vectorTileFeature.toGeoJSON(tileParams.x, tileParams.y, tileParams.z);
                      } else {
                        feature = GetGeoJSON(zoom, vectorTileFeature);
                        vectorTileLayer.l7TileOrigin = tileOrigin;
                        vectorTileLayer.l7TileCoord = coord;
                      }

                      features.push(feature);
                    }

                    vectorTileLayer.features = features;
                  }

                  resolve(vectorTile);
                }
              });

              tile.xhrCancel = function () {
                return xhr.abort();
              };
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getVectorTile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

function mapboxVectorTile(data, cfg) {
  var coord = (cfg === null || cfg === void 0 ? void 0 : cfg.coord) || 'lnglat';

  var getTileData = function getTileData(tileParams, tile) {
    return getVectorTile(data, tileParams, tile, coord);
  };

  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {
    getTileData: getTileData
  });

  return {
    data: data,
    dataArray: [],
    tilesetOptions: tilesetOptions,
    isTile: true
  };
}
//# sourceMappingURL=mvt.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/raster-tile.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/raster-tile.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ rasterTile; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../interface */ "./node_modules/@antv/l7-source/es/interface.js");
/* harmony import */ var _utils_getTile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getTile */ "./node_modules/@antv/l7-source/es/utils/getTile.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
function rasterTile(data, cfg) {
  var tileDataType = (cfg === null || cfg === void 0 ? void 0 : cfg.dataType) || _interface__WEBPACK_IMPORTED_MODULE_1__.RasterTileType.IMAGE;

  var getTileData = function getTileData(tileParams, tile) {
    if (tileDataType === _interface__WEBPACK_IMPORTED_MODULE_1__.RasterTileType.IMAGE) {
      return (0,_utils_getTile__WEBPACK_IMPORTED_MODULE_2__.getTileImage)(data, tileParams, tile);
    } else {
      return (0,_utils_getTile__WEBPACK_IMPORTED_MODULE_2__.getTileBuffer)(data, tileParams, tile, (cfg === null || cfg === void 0 ? void 0 : cfg.format) || _utils_getTile__WEBPACK_IMPORTED_MODULE_2__.defaultFormat);
    }
  };

  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {
    getTileData: getTileData
  });

  return {
    data: data,
    dataArray: [],
    tilesetOptions: tilesetOptions,
    isTile: true
  };
}
//# sourceMappingURL=raster-tile.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/parser/raster.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/parser/raster.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ raster; }
/* harmony export */ });
function raster(data, cfg) {
  var extent = cfg.extent,
      width = cfg.width,
      height = cfg.height,
      min = cfg.min,
      max = cfg.max;
  var resultData = {
    _id: 1,
    dataArray: [{
      _id: 1,
      data: Array.from(data),
      width: width,
      height: height,
      min: min,
      max: max,
      coordinates: [[extent[0], extent[1]], [extent[2], extent[3]]]
    }]
  };
  return resultData;
}
//# sourceMappingURL=raster.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/source.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/source.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Source; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/mergeWith */ "./node_modules/lodash/mergeWith.js");
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_mergeWith__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js");
/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _antv_async_hook__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/async-hook */ "./node_modules/@antv/async-hook/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./factory */ "./node_modules/@antv/l7-source/es/factory.js");
/* harmony import */ var _transform_cluster__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./transform/cluster */ "./node_modules/@antv/l7-source/es/transform/cluster.js");
/* harmony import */ var _utils_statistics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/statistics */ "./node_modules/@antv/l7-source/es/utils/statistics.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/util */ "./node_modules/@antv/l7-source/es/utils/util.js");












function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(srcValue)) {
    return srcValue;
  }
}

var Source = function (_EventEmitter) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Source, _EventEmitter);

  var _super = _createSuper(Source);

  function Source(data, cfg) {
    var _this;

    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Source);

    _this = _super.call(this);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "data", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "center", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "extent", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "hooks", {
      init: new _antv_async_hook__WEBPACK_IMPORTED_MODULE_11__.SyncHook()
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "parser", {
      type: 'geojson'
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "transforms", []);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "cluster", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "clusterOptions", {
      enable: false,
      radius: 40,
      maxZoom: 20,
      zoom: -99,
      method: 'count'
    });

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "tileset", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "mapService", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "invalidExtent", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "dataArrayChanged", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "originData", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "rawData", void 0);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "cfg", {});

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__.default)(_this), "clusterIndex", void 0);

    _this.originData = data;

    _this.initCfg(cfg);

    _this.hooks.init.tap('parser', function () {
      _this.excuteParser();
    });

    _this.hooks.init.tap('cluster', function () {
      _this.initCluster();
    });

    _this.hooks.init.tap('transform', function () {
      _this.executeTrans();
    });

    _this.init();

    return _this;
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Source, [{
    key: "getClusters",
    value: function getClusters(zoom) {
      return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);
    }
  }, {
    key: "getClustersLeaves",
    value: function getClustersLeaves(id) {
      return this.clusterIndex.getLeaves(id, Infinity);
    }
  }, {
    key: "updateClusterData",
    value: function updateClusterData(zoom) {
      var _this2 = this;

      var _this$clusterOptions = this.clusterOptions,
          _this$clusterOptions$ = _this$clusterOptions.method,
          method = _this$clusterOptions$ === void 0 ? 'sum' : _this$clusterOptions$,
          field = _this$clusterOptions.field;
      var data = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(zoom));
      this.clusterOptions.zoom = zoom;
      data.forEach(function (p) {
        if (!p.id) {
          p.properties.point_count = 1;
        }
      });

      if (field || lodash_isFunction__WEBPACK_IMPORTED_MODULE_9___default()(method)) {
        data = data.map(function (item) {
          var id = item.id;

          if (id) {
            var points = _this2.clusterIndex.getLeaves(id, Infinity);

            var properties = points.map(function (d) {
              return d.properties;
            });
            var statNum;

            if (lodash_isString__WEBPACK_IMPORTED_MODULE_8___default()(method) && field) {
              var column = (0,_utils_util__WEBPACK_IMPORTED_MODULE_17__.getColumn)(properties, field);
              statNum = _utils_statistics__WEBPACK_IMPORTED_MODULE_16__.statMap[method](column);
            }

            if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_9___default()(method)) {
              statNum = method(properties);
            }

            item.properties.stat = statNum;
          } else {
            item.properties.point_count = 1;
          }

          return item;
        });
      }

      this.data = (0,_factory__WEBPACK_IMPORTED_MODULE_14__.getParser)('geojson')({
        type: 'FeatureCollection',
        features: data
      });
      this.executeTrans();
    }
  }, {
    key: "getFeatureById",
    value: function getFeatureById(id) {
      var _this$parser$type = this.parser.type,
          type = _this$parser$type === void 0 ? 'geojson' : _this$parser$type;

      if (type === 'geojson' && !this.cluster) {
        var feature = id < this.originData.features.length ? this.originData.features[id] : 'null';

        var newFeature = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_10___default()(feature);

        if (this.transforms.length !== 0 || this.dataArrayChanged) {
          var item = this.data.dataArray.find(function (dataItem) {
            return dataItem._id === id;
          });
          newFeature.properties = item;
        }

        return newFeature;
      } else {
        return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';
      }
    }
  }, {
    key: "updateFeaturePropertiesById",
    value: function updateFeaturePropertiesById(id, properties) {
      this.data.dataArray = this.data.dataArray.map(function (dataItem) {
        if (dataItem._id === id) {
          return _objectSpread(_objectSpread({}, dataItem), properties);
        }

        return dataItem;
      });
      this.dataArrayChanged = true;
      this.emit('update');
    }
  }, {
    key: "getFeatureId",
    value: function getFeatureId(field, value) {
      var feature = this.data.dataArray.find(function (dataItem) {
        return dataItem[field] === value;
      });
      return feature === null || feature === void 0 ? void 0 : feature._id;
    }
  }, {
    key: "setData",
    value: function setData(data, options) {
      this.originData = data;
      this.dataArrayChanged = false;
      this.initCfg(options);
      this.init();
      this.emit('update');
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$tileset;

      this.removeAllListeners();
      this.originData = null;
      this.clusterIndex = null;
      this.data = null;
      (_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : _this$tileset.destroy();
    }
  }, {
    key: "initCfg",
    value: function initCfg(option) {
      this.cfg = lodash_mergeWith__WEBPACK_IMPORTED_MODULE_7___default()(this.cfg, option, mergeCustomizer);
      var cfg = this.cfg;

      if (cfg) {
        if (cfg.parser) {
          this.parser = cfg.parser;
        }

        if (cfg.transforms) {
          this.transforms = cfg.transforms;
        }

        this.cluster = cfg.cluster || false;

        if (cfg.clusterOptions) {
          this.cluster = true;
          this.clusterOptions = _objectSpread(_objectSpread({}, this.clusterOptions), cfg.clusterOptions);
        }
      }
    }
  }, {
    key: "init",
    value: function init() {
      this.hooks.init.call(this);
    }
  }, {
    key: "excuteParser",
    value: function excuteParser() {
      var parser = this.parser;
      var type = parser.type || 'geojson';
      var sourceParser = (0,_factory__WEBPACK_IMPORTED_MODULE_14__.getParser)(type);
      this.data = sourceParser(this.originData, parser);
      this.extent = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_12__.extent)(this.data.dataArray);
      this.setCenter(this.extent);
      this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];
      this.tileset = this.initTileset();
    }
  }, {
    key: "setCenter",
    value: function setCenter(bbox) {
      this.center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];

      if (isNaN(this.center[0]) || isNaN(this.center[1])) {
        this.center = [108.92361111111111, 34.54083333333333];
      }
    }
  }, {
    key: "initTileset",
    value: function initTileset() {
      var tilesetOptions = this.data.tilesetOptions;

      if (!tilesetOptions) {
        return;
      }

      if (this.tileset) {
        this.tileset.updateOptions(tilesetOptions);
        return this.tileset;
      }

      var tileset = new _antv_l7_utils__WEBPACK_IMPORTED_MODULE_12__.TilesetManager(_objectSpread({}, tilesetOptions));
      return tileset;
    }
  }, {
    key: "executeTrans",
    value: function executeTrans() {
      var _this3 = this;

      var trans = this.transforms;
      trans.forEach(function (tran) {
        var type = tran.type;
        var data = (0,_factory__WEBPACK_IMPORTED_MODULE_14__.getTransform)(type)(_this3.data, tran);
        Object.assign(_this3.data, data);
      });
    }
  }, {
    key: "initCluster",
    value: function initCluster() {
      if (!this.cluster) {
        return;
      }

      var clusterOptions = this.clusterOptions || {};
      this.clusterIndex = (0,_transform_cluster__WEBPACK_IMPORTED_MODULE_15__.cluster)(this.data, clusterOptions);
    }
  }, {
    key: "caculClusterExtent",
    value: function caculClusterExtent(bufferRatio) {
      var newBounds = [[-Infinity, -Infinity], [Infinity, Infinity]];

      if (!this.invalidExtent) {
        newBounds = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_12__.padBounds)((0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_12__.bBoxToBounds)(this.extent), bufferRatio);
      }

      return newBounds[0].concat(newBounds[1]);
    }
  }]);

  return Source;
}(eventemitter3__WEBPACK_IMPORTED_MODULE_13__.EventEmitter);


//# sourceMappingURL=source.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/cluster.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/cluster.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cluster": function() { return /* binding */ cluster; },
/* harmony export */   "formatData": function() { return /* binding */ formatData; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! supercluster/dist/supercluster */ "./node_modules/supercluster/dist/supercluster.js");
/* harmony import */ var supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_1__);


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


function cluster(data, option) {
  var _option$radius = option.radius,
      radius = _option$radius === void 0 ? 40 : _option$radius,
      _option$maxZoom = option.maxZoom,
      maxZoom = _option$maxZoom === void 0 ? 18 : _option$maxZoom,
      _option$minZoom = option.minZoom,
      minZoom = _option$minZoom === void 0 ? 0 : _option$minZoom,
      _option$zoom = option.zoom,
      zoom = _option$zoom === void 0 ? 2 : _option$zoom;

  if (data.pointIndex) {
    var clusterData = data.pointIndex.getClusters(data.extent, Math.floor(zoom));
    data.dataArray = formatData(clusterData);
    return data;
  }

  var pointIndex = new (supercluster_dist_supercluster__WEBPACK_IMPORTED_MODULE_1___default())({
    radius: radius,
    minZoom: minZoom,
    maxZoom: maxZoom
  });
  var geojson = {
    type: 'FeatureCollection',
    features: []
  };
  geojson.features = data.dataArray.map(function (item) {
    return {
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: item.coordinates
      },
      properties: _objectSpread({}, item)
    };
  });
  pointIndex.load(geojson.features);
  return pointIndex;
}
function formatData(clusterPoint) {
  return clusterPoint.map(function (point, index) {
    return _objectSpread({
      coordinates: point.geometry.coordinates,
      _id: index + 1
    }, point.properties);
  });
}
//# sourceMappingURL=cluster.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/filter.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filter": function() { return /* binding */ filter; }
/* harmony export */ });
function filter(data, options) {
  var callback = options.callback;

  if (callback) {
    data.dataArray = data.dataArray.filter(callback);
  }

  return data;
}
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/grid.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/grid.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aggregatorToGrid": function() { return /* binding */ aggregatorToGrid; }
/* harmony export */ });
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var R_EARTH = 6378000;
function aggregatorToGrid(data, option) {
  var dataArray = data.dataArray;
  var _option$size = option.size,
      size = _option$size === void 0 ? 10 : _option$size;
  var pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;

  var _pointsGridHash2 = _pointsGridHash(dataArray, size),
      gridHash = _pointsGridHash2.gridHash,
      gridOffset = _pointsGridHash2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);

  return {
    yOffset: pixlSize,
    xOffset: pixlSize,
    radius: pixlSize,
    type: 'grid',
    dataArray: layerData
  };
}

function _pointsGridHash(dataArray, size) {
  var latMin = Infinity;
  var latMax = -Infinity;
  var pLat;

  var _iterator = _createForOfIteratorHelper(dataArray),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var point = _step.value;
      pLat = point.coordinates[1];

      if (Number.isFinite(pLat)) {
        latMin = pLat < latMin ? pLat : latMin;
        latMax = pLat > latMax ? pLat : latMax;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(size, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return {
      gridHash: {},
      gridOffset: gridOffset
    };
  }

  var gridHash = {};

  var _iterator2 = _createForOfIteratorHelper(dataArray),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _point = _step2.value;
      var lat = _point.coordinates[1];
      var lng = _point.coordinates[0];

      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        var latIdx = Math.floor((lat + 90) / gridOffset.yOffset);
        var lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);

        var _key = "".concat(latIdx, "-").concat(lonIdx);

        gridHash[_key] = gridHash[_key] || {
          count: 0,
          points: []
        };
        gridHash[_key].count += 1;

        gridHash[_key].points.push(_point);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return {
    gridHash: gridHash,
    gridOffset: gridOffset
  };
}

function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);

  var xOffset = _calculateLonOffset(latitude, cellSize);

  return {
    yOffset: yOffset,
    xOffset: xOffset
  };
}

function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);
    var item = {};

    if (option.field && option.method) {
      var columns = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.Satistics.getColumn(gridHash[key].points, option.field);
      item[option.method] = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.Satistics.statMap[option.method](columns);
    }

    Object.assign(item, {
      _id: i,
      coordinates: (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_0__.aProjectFlat)([-180 + gridOffset.xOffset * (lonIdx + 0.5), -90 + gridOffset.yOffset * (latIdx + 0.5)]),
      rawData: gridHash[key].points,
      count: gridHash[key].count
    });
    accu.push(item);
    return accu;
  }, []);
}
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/hexagon.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/hexagon.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pointToHexbin": function() { return /* binding */ pointToHexbin; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var d3_hexbin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-hexbin */ "./node_modules/d3-hexbin/index.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var R_EARTH = 6378000;
function pointToHexbin(data, option) {
  var dataArray = data.dataArray;
  var _option$size = option.size,
      size = _option$size === void 0 ? 10 : _option$size,
      _option$method = option.method,
      method = _option$method === void 0 ? 'sum' : _option$method;
  var pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;
  var screenPoints = dataArray.map(function (point) {
    var _aProjectFlat = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.aProjectFlat)(point.coordinates),
        _aProjectFlat2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_aProjectFlat, 2),
        x = _aProjectFlat2[0],
        y = _aProjectFlat2[1];

    return _objectSpread(_objectSpread({}, point), {}, {
      coordinates: [x, y]
    });
  });
  var newHexbin = (0,d3_hexbin__WEBPACK_IMPORTED_MODULE_3__.hexbin)().radius(pixlSize).x(function (d) {
    return d.coordinates[0];
  }).y(function (d) {
    return d.coordinates[1];
  });
  var hexbinBins = newHexbin(screenPoints);
  var result = {
    dataArray: hexbinBins.map(function (hex, index) {
      var _ref;

      if (option.field && method) {
        var columns = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.Satistics.getColumn(hex, option.field);
        hex[method] = _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.Satistics.statMap[method](columns);
      }

      return _ref = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, option.method, hex[method]), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, "count", hex.length), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, "rawData", hex), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, "coordinates", [hex.x, hex.y]), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_ref, "_id", index), _ref;
    }),
    radius: pixlSize,
    xOffset: pixlSize,
    yOffset: pixlSize,
    type: 'hexagon'
  };
  return result;
}
//# sourceMappingURL=hexagon.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/join.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/join.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "join": function() { return /* binding */ join; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function join(geoData, options) {
  var sourceField = options.sourceField,
      targetField = options.targetField,
      data = options.data;
  var dataObj = {};
  data.forEach(function (element) {
    dataObj[element[sourceField]] = element;
  });
  geoData.dataArray = geoData.dataArray.map(function (item) {
    var joinName = item[targetField];
    return _objectSpread(_objectSpread({}, item), dataObj[joinName]);
  });
  return geoData;
}
//# sourceMappingURL=join.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/transform/map.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/transform/map.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "map": function() { return /* binding */ map; }
/* harmony export */ });
function map(data, options) {
  var callback = options.callback;

  if (callback) {
    data.dataArray = data.dataArray.map(callback);
  }

  return data;
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/utils/getTile.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/utils/getTile.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTileBuffer": function() { return /* binding */ getTileBuffer; },
/* harmony export */   "getTileImage": function() { return /* binding */ getTileImage; },
/* harmony export */   "defaultFormat": function() { return /* binding */ defaultFormat; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");



var getTileBuffer = function () {
  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(url, tileParams, tile, rasterParser) {
    var imgUrl;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            imgUrl = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.getURLFromTemplate)(url, tileParams);
            return _context.abrupt("return", new Promise(function (resolve, reject) {
              var xhr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.getTiffImage)({
                url: imgUrl
              }, function (err, img) {
                if (err) {
                  reject(err);
                } else if (img) {
                  resolve(img);
                }
              }, rasterParser);

              tile.xhrCancel = function () {
                return xhr.abort();
              };
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getTileBuffer(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
var getTileImage = function () {
  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(url, tileParams, tile) {
    var imgUrl;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            imgUrl = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.getURLFromTemplate)(url, tileParams);
            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              var xhr = (0,_antv_l7_utils__WEBPACK_IMPORTED_MODULE_2__.getImage)({
                url: imgUrl
              }, function (err, img) {
                if (err) {
                  reject(err);
                } else if (img) {
                  resolve(img);
                }
              });

              tile.xhrCancel = function () {
                return xhr.abort();
              };
            }));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getTileImage(_x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
}();
var defaultFormat = function defaultFormat() {
  return {
    rasterData: new Uint8Array([0]),
    width: 1,
    height: 1
  };
};
//# sourceMappingURL=getTile.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/utils/statistics.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/utils/statistics.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": function() { return /* binding */ sum; },
/* harmony export */   "max": function() { return /* binding */ max; },
/* harmony export */   "min": function() { return /* binding */ min; },
/* harmony export */   "mean": function() { return /* binding */ mean; },
/* harmony export */   "statMap": function() { return /* binding */ statMap; }
/* harmony export */ });
function max(x) {
  if (x.length === 0) {
    throw new Error('max requires at least one data point');
  }

  var value = x[0];

  for (var i = 1; i < x.length; i++) {
    if (x[i] > value) {
      value = x[i];
    }
  }

  return value;
}

function min(x) {
  if (x.length === 0) {
    throw new Error('min requires at least one data point');
  }

  var value = x[0];

  for (var i = 1; i < x.length; i++) {
    if (x[i] < value) {
      value = x[i];
    }
  }

  return value;
}

function sum(x) {
  if (x.length === 0) {
    return 0;
  }

  var sumNum = x[0];
  var correction = 0;
  var transition;

  for (var i = 1; i < x.length; i++) {
    transition = sumNum + x[i] * 1;

    if (Math.abs(sumNum) >= Math.abs(x[i])) {
      correction += sumNum - transition + x[i];
    } else {
      correction += x[i] - transition + sumNum;
    }

    sumNum = transition;
  }

  return sumNum + correction * 1;
}

function mean(x) {
  if (x.length === 0) {
    throw new Error('mean requires at least one data point');
  }

  return sum(x) / x.length;
}


var statMap = {
  min: min,
  max: max,
  mean: mean,
  sum: sum
};
//# sourceMappingURL=statistics.js.map

/***/ }),

/***/ "./node_modules/@antv/l7-source/es/utils/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/l7-source/es/utils/util.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getColumn": function() { return /* binding */ getColumn; }
/* harmony export */ });
function getColumn(data, columnName) {
  return data.map(function (item) {
    return item[columnName] * 1;
  });
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/l7/es/index.js":
/*!*******************************************!*\
  !*** ./node_modules/@antv/l7/es/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.AttributeType; },
/* harmony export */   "BasePostProcessingPass": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BasePostProcessingPass; },
/* harmony export */   "BlendType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.BlendType; },
/* harmony export */   "CameraUniform": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.CameraUniform; },
/* harmony export */   "CoordinateSystem": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem; },
/* harmony export */   "CoordinateUniform": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.CoordinateUniform; },
/* harmony export */   "InteractionEvent": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.InteractionEvent; },
/* harmony export */   "MapServiceEvent": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.MapServiceEvent; },
/* harmony export */   "PassType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.PassType; },
/* harmony export */   "PositionType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.PositionType; },
/* harmony export */   "ScaleTypes": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.ScaleTypes; },
/* harmony export */   "SceneEventList": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.SceneEventList; },
/* harmony export */   "StyleScaleType": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.StyleScaleType; },
/* harmony export */   "TYPES": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.TYPES; },
/* harmony export */   "container": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.container; },
/* harmony export */   "createLayerContainer": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.createLayerContainer; },
/* harmony export */   "createSceneContainer": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.createSceneContainer; },
/* harmony export */   "gl": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.gl; },
/* harmony export */   "lazyInject": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.lazyInject; },
/* harmony export */   "lazyMultiInject": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.lazyMultiInject; },
/* harmony export */   "packCircleVertex": function() { return /* reexport safe */ _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__.packCircleVertex; },
/* harmony export */   "Scene": function() { return /* reexport safe */ _antv_l7_scene__WEBPACK_IMPORTED_MODULE_2__.Scene; },
/* harmony export */   "Earth": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.Earth; },
/* harmony export */   "GaodeMap": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.GaodeMap; },
/* harmony export */   "GaodeMapV2": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.GaodeMapV2; },
/* harmony export */   "Map": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.Map; },
/* harmony export */   "Mapbox": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.Mapbox; },
/* harmony export */   "Version": function() { return /* reexport safe */ _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__.Version; },
/* harmony export */   "BaseLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.BaseLayer; },
/* harmony export */   "CanvasLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.CanvasLayer; },
/* harmony export */   "CanvasUpdateType": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.CanvasUpdateType; },
/* harmony export */   "CityBuildingLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.CityBuildingLayer; },
/* harmony export */   "EarthLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.EarthLayer; },
/* harmony export */   "GeometryLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.GeometryLayer; },
/* harmony export */   "HeatmapLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.HeatmapLayer; },
/* harmony export */   "ImageLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.ImageLayer; },
/* harmony export */   "LineLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.LineLayer; },
/* harmony export */   "MaskLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.MaskLayer; },
/* harmony export */   "PointLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.PointLayer; },
/* harmony export */   "PolygonLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.PolygonLayer; },
/* harmony export */   "RasterLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.RasterLayer; },
/* harmony export */   "WindLayer": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.WindLayer; },
/* harmony export */   "lineStyleType": function() { return /* reexport safe */ _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__.lineStyleType; },
/* harmony export */   "Control": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Control; },
/* harmony export */   "Layers": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Layers; },
/* harmony export */   "Logo": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Logo; },
/* harmony export */   "Marker": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Marker; },
/* harmony export */   "MarkerLayer": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.MarkerLayer; },
/* harmony export */   "Popup": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Popup; },
/* harmony export */   "Scale": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Scale; },
/* harmony export */   "Zoom": function() { return /* reexport safe */ _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__.Zoom; },
/* harmony export */   "$XMLHttpRequest": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.$XMLHttpRequest; },
/* harmony export */   "$location": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.$location; },
/* harmony export */   "$window": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.$window; },
/* harmony export */   "AJAXError": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.AJAXError; },
/* harmony export */   "BKDRHash": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.BKDRHash; },
/* harmony export */   "DOM": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.DOM; },
/* harmony export */   "FrequencyController": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.FrequencyController; },
/* harmony export */   "LRUCache": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.LRUCache; },
/* harmony export */   "LoadTileDataStatus": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.LoadTileDataStatus; },
/* harmony export */   "Satistics": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.Satistics; },
/* harmony export */   "Tile": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.Tile; },
/* harmony export */   "TilesetManager": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.TilesetManager; },
/* harmony export */   "UpdateTileStrategy": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.UpdateTileStrategy; },
/* harmony export */   "aProjectFlat": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.aProjectFlat; },
/* harmony export */   "amap2Project": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.amap2Project; },
/* harmony export */   "anchorTranslate": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.anchorTranslate; },
/* harmony export */   "anchorType": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.anchorType; },
/* harmony export */   "applyAnchorClass": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.applyAnchorClass; },
/* harmony export */   "bBoxToBounds": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.bBoxToBounds; },
/* harmony export */   "bindAll": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.bindAll; },
/* harmony export */   "boundsContains": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.boundsContains; },
/* harmony export */   "calAngle": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.calAngle; },
/* harmony export */   "calDistance": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.calDistance; },
/* harmony export */   "decodePickingColor": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.decodePickingColor; },
/* harmony export */   "dispatchMapCameraParams": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchMapCameraParams; },
/* harmony export */   "dispatchMouseDown": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchMouseDown; },
/* harmony export */   "dispatchMouseMove": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchMouseMove; },
/* harmony export */   "dispatchMouseUp": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchMouseUp; },
/* harmony export */   "dispatchPointerDown": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchPointerDown; },
/* harmony export */   "dispatchPointerMove": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchPointerMove; },
/* harmony export */   "dispatchPointerUp": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchPointerUp; },
/* harmony export */   "dispatchTouchEnd": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchTouchEnd; },
/* harmony export */   "dispatchTouchMove": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchTouchMove; },
/* harmony export */   "dispatchTouchStart": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.dispatchTouchStart; },
/* harmony export */   "djb2hash": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.djb2hash; },
/* harmony export */   "encodePickingColor": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.encodePickingColor; },
/* harmony export */   "extent": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.extent; },
/* harmony export */   "flow": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.flow; },
/* harmony export */   "generateColorRamp": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.generateColorRamp; },
/* harmony export */   "getAngle": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getAngle; },
/* harmony export */   "getArrayBuffer": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getArrayBuffer; },
/* harmony export */   "getCullFace": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getCullFace; },
/* harmony export */   "getImage": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getImage; },
/* harmony export */   "getJSON": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getJSON; },
/* harmony export */   "getMask": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getMask; },
/* harmony export */   "getReferrer": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getReferrer; },
/* harmony export */   "getTiffImage": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getTiffImage; },
/* harmony export */   "getTileIndices": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getTileIndices; },
/* harmony export */   "getTileWarpXY": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getTileWarpXY; },
/* harmony export */   "getURLFromTemplate": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.getURLFromTemplate; },
/* harmony export */   "isColor": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isColor; },
/* harmony export */   "isImageBitmap": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isImageBitmap; },
/* harmony export */   "isMini": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isMini; },
/* harmony export */   "isMiniAli": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isMiniAli; },
/* harmony export */   "isURLTemplate": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isURLTemplate; },
/* harmony export */   "isWeChatMiniProgram": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isWeChatMiniProgram; },
/* harmony export */   "isWorker": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.isWorker; },
/* harmony export */   "latitude": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.latitude; },
/* harmony export */   "lngLatToMeters": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.lngLatToMeters; },
/* harmony export */   "lnglatDistance": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.lnglatDistance; },
/* harmony export */   "longitude": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.longitude; },
/* harmony export */   "metersToLngLat": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.metersToLngLat; },
/* harmony export */   "miniWindow": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.miniWindow; },
/* harmony export */   "normalize": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.normalize; },
/* harmony export */   "osmLonLat2TileXY": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.osmLonLat2TileXY; },
/* harmony export */   "osmTileXY2LonLat": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.osmTileXY2LonLat; },
/* harmony export */   "padBounds": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.padBounds; },
/* harmony export */   "postData": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.postData; },
/* harmony export */   "project": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.project; },
/* harmony export */   "rgb2arr": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.rgb2arr; },
/* harmony export */   "tileToBounds": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.tileToBounds; },
/* harmony export */   "tranfrormCoord": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.tranfrormCoord; },
/* harmony export */   "unProjectFlat": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.unProjectFlat; },
/* harmony export */   "validateLngLat": function() { return /* reexport safe */ _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__.validateLngLat; },
/* harmony export */   "version": function() { return /* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_7__.version; },
/* harmony export */   "Source": function() { return /* reexport safe */ _antv_l7_source__WEBPACK_IMPORTED_MODULE_0__.default; }
/* harmony export */ });
/* harmony import */ var _antv_l7_source__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/l7-source */ "./node_modules/@antv/l7-source/es/index.js");
/* harmony import */ var _antv_l7_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/l7-core */ "./node_modules/@antv/l7-core/es/index.js");
/* harmony import */ var _antv_l7_scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/l7-scene */ "./node_modules/@antv/l7-scene/es/index.js");
/* harmony import */ var _antv_l7_maps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/l7-maps */ "./node_modules/@antv/l7-maps/es/index.js");
/* harmony import */ var _antv_l7_layers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/l7-layers */ "./node_modules/@antv/l7-layers/es/index.js");
/* harmony import */ var _antv_l7_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/l7-component */ "./node_modules/@antv/l7-component/es/index.js");
/* harmony import */ var _antv_l7_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/l7-utils */ "./node_modules/@antv/l7-utils/es/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./version */ "./node_modules/@antv/l7/es/version.js");









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/l7/es/version.js":
/*!*********************************************!*\
  !*** ./node_modules/@antv/l7/es/version.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": function() { return /* binding */ version; }
/* harmony export */ });
var version = '2.9.13';

//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/@mapbox/geojson-area/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@mapbox/geojson-area/index.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wgs84 = __webpack_require__(/*! wgs84 */ "./node_modules/wgs84/index.js");

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

/***/ }),

/***/ "./node_modules/@mapbox/geojson-rewind/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/geojson-rewind/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var geojsonArea = __webpack_require__(/*! @mapbox/geojson-area */ "./node_modules/@mapbox/geojson-area/index.js");

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'GeometryCollection':
            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], !outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}


/***/ }),

/***/ "./node_modules/@mapbox/point-geometry/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/point-geometry/index.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";


module.exports = Point;

/**
 * A standalone point geometry with useful accessor, comparison, and
 * modification methods.
 *
 * @class Point
 * @param {Number} x the x-coordinate. this could be longitude or screen
 * pixels, or any other sort of unit.
 * @param {Number} y the y-coordinate. this could be latitude or screen
 * pixels, or any other sort of unit.
 * @example
 * var point = new Point(-77, 38);
 */
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {

    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function() { return new Point(this.x, this.y); },

    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add:     function(p) { return this.clone()._add(p); },

    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub:     function(p) { return this.clone()._sub(p); },

    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint:    function(p) { return this.clone()._multByPoint(p); },

    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint:     function(p) { return this.clone()._divByPoint(p); },

    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult:    function(k) { return this.clone()._mult(k); },

    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div:     function(k) { return this.clone()._div(k); },

    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate:  function(a) { return this.clone()._rotate(a); },

    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },

    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function(m) { return this.clone()._matMult(m); },

    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit:    function() { return this.clone()._unit(); },

    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp:    function() { return this.clone()._perp(); },

    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round:   function() { return this.clone()._round(); },

    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function(other) {
        return this.x === other.x &&
               this.y === other.y;
    },

    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin() for .
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _multByPoint: function(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
    },

    _divByPoint: function(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _rotateAround: function(angle, p) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

/**
 * Construct a point from an array if necessary, otherwise if the input
 * is already a Point, or an unknown type, return it unchanged
 * @param {Array<Number>|Point|*} a any kind of input value
 * @return {Point} constructed point, or passed-through value.
 * @example
 * // this
 * var point = Point.convert([0, 1]);
 * // is equivalent to
 * var point = new Point(0, 1);
 */
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports.VectorTile = __webpack_require__(/*! ./lib/vectortile.js */ "./node_modules/@mapbox/vector-tile/lib/vectortile.js");
module.exports.VectorTileFeature = __webpack_require__(/*! ./lib/vectortilefeature.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js");
module.exports.VectorTileLayer = __webpack_require__(/*! ./lib/vectortilelayer.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js");


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortile.js":
/*!************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortile.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var VectorTileLayer = __webpack_require__(/*! ./vectortilelayer */ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js");

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}



/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Point = __webpack_require__(/*! @mapbox/point-geometry */ "./node_modules/@mapbox/point-geometry/index.js");

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature.id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) continue;

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var VectorTileFeature = __webpack_require__(/*! ./vectortilefeature.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js");

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};


/***/ }),

/***/ "./node_modules/@turf/invariant/dist/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@turf/invariant/dist/es/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCoord": function() { return /* binding */ getCoord; },
/* harmony export */   "getCoords": function() { return /* binding */ getCoords; },
/* harmony export */   "containsNumber": function() { return /* binding */ containsNumber; },
/* harmony export */   "geojsonType": function() { return /* binding */ geojsonType; },
/* harmony export */   "featureOf": function() { return /* binding */ featureOf; },
/* harmony export */   "collectionOf": function() { return /* binding */ collectionOf; },
/* harmony export */   "getGeom": function() { return /* binding */ getGeom; },
/* harmony export */   "getType": function() { return /* binding */ getType; }
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" &&
            coord.geometry !== null &&
            coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) &&
        coord.length >= 2 &&
        !Array.isArray(coord[0]) &&
        !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[0]) &&
        (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            value.type);
    }
}
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            feature.geometry.type);
    }
}
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                feature.geometry.type);
        }
    }
}
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}


/***/ }),

/***/ "./node_modules/@turf/meta/dist/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/meta/dist/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coordAll": function() { return /* binding */ coordAll; },
/* harmony export */   "coordEach": function() { return /* binding */ coordEach; },
/* harmony export */   "coordReduce": function() { return /* binding */ coordReduce; },
/* harmony export */   "featureEach": function() { return /* binding */ featureEach; },
/* harmony export */   "featureReduce": function() { return /* binding */ featureReduce; },
/* harmony export */   "findPoint": function() { return /* binding */ findPoint; },
/* harmony export */   "findSegment": function() { return /* binding */ findSegment; },
/* harmony export */   "flattenEach": function() { return /* binding */ flattenEach; },
/* harmony export */   "flattenReduce": function() { return /* binding */ flattenReduce; },
/* harmony export */   "geomEach": function() { return /* binding */ geomEach; },
/* harmony export */   "geomReduce": function() { return /* binding */ geomReduce; },
/* harmony export */   "lineEach": function() { return /* binding */ lineEach; },
/* harmony export */   "lineReduce": function() { return /* binding */ lineReduce; },
/* harmony export */   "propEach": function() { return /* binding */ propEach; },
/* harmony export */   "propReduce": function() { return /* binding */ propReduce; },
/* harmony export */   "segmentEach": function() { return /* binding */ segmentEach; },
/* harmony export */   "segmentReduce": function() { return /* binding */ segmentReduce; }
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");


/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
    k,
    l,
    geometry,
    stopG,
    coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    coordIndex = 0,
    isGeometryCollection,
    type = geojson.type,
    isFeatureCollection = type === "FeatureCollection",
    isFeature = type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[featureIndex].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[geomIndex]
        : geometryMaybeCollection;

      // Handles null Geometry -- Skips this geometry
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;

      wrapShrink =
        excludeWrapCoord &&
        (geomType === "Polygon" || geomType === "MultiPolygon")
          ? 1
          : 0;

      switch (geomType) {
        case null:
          break;
        case "Point":
          if (
            callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (
              callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false
            )
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (
                callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (
                  callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false
                )
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (
              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===
              false
            )
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function (
      currentCoord,
      coordIndex,
      featureIndex,
      multiFeatureIndex,
      geometryIndex
    ) {
      if (coordIndex === 0 && initialValue === undefined)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}

/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentFeature;
    else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
  var i,
    j,
    g,
    geometry,
    stopG,
    geometryMaybeCollection,
    isGeometryCollection,
    featureProperties,
    featureBBox,
    featureId,
    featureIndex = 0,
    isFeatureCollection = geojson.type === "FeatureCollection",
    isFeature = geojson.type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[i].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    featureProperties = isFeatureCollection
      ? geojson.features[i].properties
      : isFeature
      ? geojson.properties
      : {};
    featureBBox = isFeatureCollection
      ? geojson.features[i].bbox
      : isFeature
      ? geojson.bbox
      : undefined;
    featureId = isFeatureCollection
      ? geojson.features[i].id
      : isFeature
      ? geojson.id
      : undefined;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[g]
        : geometryMaybeCollection;

      // Handle null Geometry
      if (geometry === null) {
        if (
          callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false
        )
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (
            callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false
          )
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (
              callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    // Only increase `featureIndex` per each feature
    featureIndex++;
  }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function (
      currentGeometry,
      featureIndex,
      featureProperties,
      featureBBox,
      featureId
    ) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (
          callback(
            (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geometry, properties, { bbox: bbox, id: id }),
            featureIndex,
            0
          ) === false
        )
          return false;
        return;
    }

    var geomType;

    // Callback for multi-geometry
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }

    for (
      var multiFeatureIndex = 0;
      multiFeatureIndex < geometry.coordinates.length;
      multiFeatureIndex++
    ) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate,
      };
      if (
        callback((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geom, properties), featureIndex, multiFeatureIndex) ===
        false
      )
        return false;
    }
  });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function (currentFeature, featureIndex, multiFeatureIndex) {
      if (
        featureIndex === 0 &&
        multiFeatureIndex === 0 &&
        initialValue === undefined
      )
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;

    // Exclude null Geometries
    if (!feature.geometry) return;
    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
    var type = feature.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;

    // Generate 2-vertex line segments
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (
      coordEach(
        feature,
        function (
          currentCoord,
          coordIndex,
          featureIndexCoord,
          multiPartIndexCoord,
          geometryIndex
        ) {
          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
          if (
            previousCoords === undefined ||
            featureIndex > previousFeatureIndex ||
            multiPartIndexCoord > previousMultiIndex ||
            geometryIndex > prevGeomIndex
          ) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
            [previousCoords, currentCoord],
            feature.properties
          );
          if (
            callback(
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            ) === false
          )
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false
    )
      return false;
  });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentIndex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function (
      currentSegment,
      featureIndex,
      multiFeatureIndex,
      geometryIndex,
      segmentIndex
    ) {
      if (started === false && initialValue === undefined)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error("geojson is required");

  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (
          var geometryIndex = 0;
          geometryIndex < coords.length;
          geometryIndex++
        ) {
          if (
            callback(
              (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(coords[geometryIndex], feature.properties),
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
        }
        break;
    }
  });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find SegmentIndex
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex =
          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find Coord Index
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex =
          coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}




/***/ }),

/***/ "./node_modules/@turf/union/dist/es/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@turf/union/dist/es/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var polygon_clipping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! polygon-clipping */ "./node_modules/polygon-clipping/dist/polygon-clipping.umd.js");
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");



/**
 * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
 * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
 * @param {Object} [options={}] Optional Parameters
 * @param {Object} [options.properties={}] Translate Properties to output Feature
 * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature, or null if the inputs are empty
 * @example
 * var poly1 = turf.polygon([[
 *     [-82.574787, 35.594087],
 *     [-82.574787, 35.615581],
 *     [-82.545261, 35.615581],
 *     [-82.545261, 35.594087],
 *     [-82.574787, 35.594087]
 * ]], {"fill": "#0f0"});
 * var poly2 = turf.polygon([[
 *     [-82.560024, 35.585153],
 *     [-82.560024, 35.602602],
 *     [-82.52964, 35.602602],
 *     [-82.52964, 35.585153],
 *     [-82.560024, 35.585153]
 * ]], {"fill": "#00f"});
 *
 * var union = turf.union(poly1, poly2);
 *
 * //addToMap
 * var addToMap = [poly1, poly2, union];
 */
function union(poly1, poly2, options) {
    if (options === void 0) { options = {}; }
    var geom1 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_1__.getGeom)(poly1);
    var geom2 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_1__.getGeom)(poly2);
    var unioned = polygon_clipping__WEBPACK_IMPORTED_MODULE_0__.union(geom1.coordinates, geom2.coordinates);
    if (unioned.length === 0)
        return null;
    if (unioned.length === 1)
        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_2__.polygon)(unioned[0], options.properties);
    else
        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_2__.multiPolygon)(unioned, options.properties);
}
/* harmony default export */ __webpack_exports__["default"] = (union);


/***/ }),

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Node": function() { return /* binding */ Node; },
/* harmony export */   "Parser": function() { return /* binding */ Parser; },
/* harmony export */   "Position": function() { return /* binding */ Position; },
/* harmony export */   "SourceLocation": function() { return /* binding */ SourceLocation; },
/* harmony export */   "TokContext": function() { return /* binding */ TokContext; },
/* harmony export */   "Token": function() { return /* binding */ Token; },
/* harmony export */   "TokenType": function() { return /* binding */ TokenType; },
/* harmony export */   "defaultOptions": function() { return /* binding */ defaultOptions; },
/* harmony export */   "getLineInfo": function() { return /* binding */ getLineInfo; },
/* harmony export */   "isIdentifierChar": function() { return /* binding */ isIdentifierChar; },
/* harmony export */   "isIdentifierStart": function() { return /* binding */ isIdentifierStart; },
/* harmony export */   "isNewLine": function() { return /* binding */ isNewLine; },
/* harmony export */   "keywordTypes": function() { return /* binding */ keywords$1; },
/* harmony export */   "lineBreak": function() { return /* binding */ lineBreak; },
/* harmony export */   "lineBreakG": function() { return /* binding */ lineBreakG; },
/* harmony export */   "nonASCIIwhitespace": function() { return /* binding */ nonASCIIwhitespace; },
/* harmony export */   "parse": function() { return /* binding */ parse; },
/* harmony export */   "parseExpressionAt": function() { return /* binding */ parseExpressionAt; },
/* harmony export */   "tokContexts": function() { return /* binding */ types$1; },
/* harmony export */   "tokTypes": function() { return /* binding */ types; },
/* harmony export */   "tokenizer": function() { return /* binding */ tokenizer; },
/* harmony export */   "version": function() { return /* binding */ version; }
/* harmony export */ });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 10.
  ecmaVersion: 10,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (this.type !== types.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseIdent(true);
        this.checkExport(exports, node.exported.name, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval  something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0)
            { refDestructuringErrors.doubleProto = key.start; }
          // Backwards-compat kludge. Can be removed in version 6.0
        } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= node.left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var coalesce = this.type === types.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types.bracketL);
  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseExprImport = function() {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  var meta = this.parseIdent(true);

  switch (this.type) {
  case types.parenL:
    return this.parseDynamicImport(node)
  case types.dot:
    node.meta = meta;
    return this.parseImportMeta(node)
  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types.parenR)) {
    var errorPos = this.start;
    if (this.eat(types.comma) && this.eat(types.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$3.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module")
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, false);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.pos, forceU)
};

RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.nextIndex(this.pos, forceU), forceU)
};

RegExpValidationState.prototype.advance = function advance (forceU) {
    if ( forceU === void 0 ) forceU = false;

  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat (ch, forceU) {
    if ( forceU === void 0 ) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if ( forceU === void 0 ) forceU = false;

  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* ] */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) { return this.finishOp(types.assign, 3) }
    }
    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.readToken_question = function() { // '?'
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(types.coalesce, 2)
    }
  }
  return this.finishOp(types.question, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 63: // '?'
    return this.readToken_question()

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
      lastCode = code;
      continue
    }

    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8)
  }

  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
  return parseFloat(str.replace(/_/g, ""))
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null
  }

  // `BigInt(value)` throws syntax error if the string contains numeric separators.
  return BigInt(str.replace(/_/g, ""))
}

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  case 56:
  case 57:
    if (inTemplate) {
      var codePos = this.pos - 1;

      this.invalidStringToken(
        codePos,
        "Invalid escape sequence in template string"
      );

      return null
    }
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "7.4.1";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "slice": function() { return /* binding */ slice; },
/* harmony export */   "map": function() { return /* binding */ map; }
/* harmony export */ });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisectRight": function() { return /* binding */ bisectRight; },
/* harmony export */   "bisectLeft": function() { return /* binding */ bisectLeft; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");



var ascendingBisect = (0,_bisector__WEBPACK_IMPORTED_MODULE_1__.default)(_ascending__WEBPACK_IMPORTED_MODULE_0__.default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__.default)(f(d), x);
  };
}


/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__.pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  var v = (0,_variance__WEBPACK_IMPORTED_MODULE_0__.default)(array, f);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__.default,
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__.default,
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__.default;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = (0,_ticks__WEBPACK_IMPORTED_MODULE_6__.tickStep)(x0, x1, tz);
      tz = (0,_range__WEBPACK_IMPORTED_MODULE_5__.default)(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[(0,_bisect__WEBPACK_IMPORTED_MODULE_1__.default)(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__.default)(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__.default)([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0,_constant__WEBPACK_IMPORTED_MODULE_2__.default)(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)) : (0,_constant__WEBPACK_IMPORTED_MODULE_2__.default)(_), histogram) : threshold;
  };

  return histogram;
}


/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-array/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisect": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "bisectRight": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectRight; },
/* harmony export */   "bisectLeft": function() { return /* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectLeft; },
/* harmony export */   "ascending": function() { return /* reexport safe */ _ascending__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "bisector": function() { return /* reexport safe */ _bisector__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "cross": function() { return /* reexport safe */ _cross__WEBPACK_IMPORTED_MODULE_3__.default; },
/* harmony export */   "descending": function() { return /* reexport safe */ _descending__WEBPACK_IMPORTED_MODULE_4__.default; },
/* harmony export */   "deviation": function() { return /* reexport safe */ _deviation__WEBPACK_IMPORTED_MODULE_5__.default; },
/* harmony export */   "extent": function() { return /* reexport safe */ _extent__WEBPACK_IMPORTED_MODULE_6__.default; },
/* harmony export */   "histogram": function() { return /* reexport safe */ _histogram__WEBPACK_IMPORTED_MODULE_7__.default; },
/* harmony export */   "thresholdFreedmanDiaconis": function() { return /* reexport safe */ _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__.default; },
/* harmony export */   "thresholdScott": function() { return /* reexport safe */ _threshold_scott__WEBPACK_IMPORTED_MODULE_9__.default; },
/* harmony export */   "thresholdSturges": function() { return /* reexport safe */ _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__.default; },
/* harmony export */   "max": function() { return /* reexport safe */ _max__WEBPACK_IMPORTED_MODULE_11__.default; },
/* harmony export */   "mean": function() { return /* reexport safe */ _mean__WEBPACK_IMPORTED_MODULE_12__.default; },
/* harmony export */   "median": function() { return /* reexport safe */ _median__WEBPACK_IMPORTED_MODULE_13__.default; },
/* harmony export */   "merge": function() { return /* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_14__.default; },
/* harmony export */   "min": function() { return /* reexport safe */ _min__WEBPACK_IMPORTED_MODULE_15__.default; },
/* harmony export */   "pairs": function() { return /* reexport safe */ _pairs__WEBPACK_IMPORTED_MODULE_16__.default; },
/* harmony export */   "permute": function() { return /* reexport safe */ _permute__WEBPACK_IMPORTED_MODULE_17__.default; },
/* harmony export */   "quantile": function() { return /* reexport safe */ _quantile__WEBPACK_IMPORTED_MODULE_18__.default; },
/* harmony export */   "range": function() { return /* reexport safe */ _range__WEBPACK_IMPORTED_MODULE_19__.default; },
/* harmony export */   "scan": function() { return /* reexport safe */ _scan__WEBPACK_IMPORTED_MODULE_20__.default; },
/* harmony export */   "shuffle": function() { return /* reexport safe */ _shuffle__WEBPACK_IMPORTED_MODULE_21__.default; },
/* harmony export */   "sum": function() { return /* reexport safe */ _sum__WEBPACK_IMPORTED_MODULE_22__.default; },
/* harmony export */   "ticks": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.default; },
/* harmony export */   "tickIncrement": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickIncrement; },
/* harmony export */   "tickStep": function() { return /* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickStep; },
/* harmony export */   "transpose": function() { return /* reexport safe */ _transpose__WEBPACK_IMPORTED_MODULE_24__.default; },
/* harmony export */   "variance": function() { return /* reexport safe */ _variance__WEBPACK_IMPORTED_MODULE_25__.default; },
/* harmony export */   "zip": function() { return /* reexport safe */ _zip__WEBPACK_IMPORTED_MODULE_26__.default; }
/* harmony export */ });
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./node_modules/d3-array/src/cross.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-array/src/descending.js");
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "./node_modules/d3-array/src/mean.js");
/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "./node_modules/d3-array/src/median.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-array/src/merge.js");
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "./node_modules/d3-array/src/permute.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "./node_modules/d3-array/src/scan.js");
/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");
/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "./node_modules/d3-array/src/zip.js");





























/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__.default)(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__.default)(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}


/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__.default)(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__.default)(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return (0,_quantile__WEBPACK_IMPORTED_MODULE_2__.default)(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__.default), 0.5);
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}


/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "pair": function() { return /* binding */ pair; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__.default;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__.default;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}


/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__.map.call(values, _number__WEBPACK_IMPORTED_MODULE_2__.default).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__.default);
  return Math.ceil((max - min) / (2 * ((0,_quantile__WEBPACK_IMPORTED_MODULE_3__.default)(values, 0.75) - (0,_quantile__WEBPACK_IMPORTED_MODULE_3__.default)(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0,_deviation__WEBPACK_IMPORTED_MODULE_0__.default)(values) * Math.pow(values.length, -1 / 3)));
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "tickIncrement": function() { return /* binding */ tickIncrement; },
/* harmony export */   "tickStep": function() { return /* binding */ tickStep; }
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = (0,_min__WEBPACK_IMPORTED_MODULE_0__.default)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}


/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__.default)(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__.default)(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}


/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_transpose__WEBPACK_IMPORTED_MODULE_0__.default)(arguments);
}


/***/ }),

/***/ "./node_modules/d3-collection/src/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-collection/src/entries.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}


/***/ }),

/***/ "./node_modules/d3-collection/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-collection/src/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nest": function() { return /* reexport safe */ _nest__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "set": function() { return /* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "map": function() { return /* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "keys": function() { return /* reexport safe */ _keys__WEBPACK_IMPORTED_MODULE_3__.default; },
/* harmony export */   "values": function() { return /* reexport safe */ _values__WEBPACK_IMPORTED_MODULE_4__.default; },
/* harmony export */   "entries": function() { return /* reexport safe */ _entries__WEBPACK_IMPORTED_MODULE_5__.default; }
/* harmony export */ });
/* harmony import */ var _nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nest */ "./node_modules/d3-collection/src/nest.js");
/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set */ "./node_modules/d3-collection/src/set.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys */ "./node_modules/d3-collection/src/keys.js");
/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./values */ "./node_modules/d3-collection/src/values.js");
/* harmony import */ var _entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entries */ "./node_modules/d3-collection/src/entries.js");








/***/ }),

/***/ "./node_modules/d3-collection/src/keys.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/keys.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}


/***/ }),

/***/ "./node_modules/d3-collection/src/map.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/map.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefix": function() { return /* binding */ prefix; }
/* harmony export */ });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);


/***/ }),

/***/ "./node_modules/d3-collection/src/nest.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/nest.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = (0,_map__WEBPACK_IMPORTED_MODULE_0__.default)(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return (0,_map__WEBPACK_IMPORTED_MODULE_0__.default)();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),

/***/ "./node_modules/d3-collection/src/set.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/set.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__.default.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__.prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);


/***/ }),

/***/ "./node_modules/d3-collection/src/values.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-collection/src/values.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ cubehelix; },
/* harmony export */   "Cubehelix": function() { return /* binding */ Cubehelix; }
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_1__.rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_2__.default)(Cubehelix, cubehelix, (0,_define_js__WEBPACK_IMPORTED_MODULE_2__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.brighter : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.darker : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_1__.deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "color": function() { return /* reexport safe */ _color_js__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "rgb": function() { return /* reexport safe */ _color_js__WEBPACK_IMPORTED_MODULE_0__.rgb; },
/* harmony export */   "hsl": function() { return /* reexport safe */ _color_js__WEBPACK_IMPORTED_MODULE_0__.hsl; },
/* harmony export */   "lab": function() { return /* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "hcl": function() { return /* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_1__.hcl; },
/* harmony export */   "lch": function() { return /* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_1__.lch; },
/* harmony export */   "gray": function() { return /* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_1__.gray; },
/* harmony export */   "cubehelix": function() { return /* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__.default; }
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");





/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gray": function() { return /* binding */ gray; },
/* harmony export */   "default": function() { return /* binding */ lab; },
/* harmony export */   "Lab": function() { return /* binding */ Lab; },
/* harmony export */   "lch": function() { return /* binding */ lch; },
/* harmony export */   "hcl": function() { return /* binding */ hcl; },
/* harmony export */   "Hcl": function() { return /* binding */ Hcl; }
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deg2rad": function() { return /* binding */ deg2rad; },
/* harmony export */   "rad2deg": function() { return /* binding */ rad2deg; }
/* harmony export */ });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "csvParse": function() { return /* binding */ csvParse; },
/* harmony export */   "csvParseRows": function() { return /* binding */ csvParseRows; },
/* harmony export */   "csvFormat": function() { return /* binding */ csvFormat; },
/* harmony export */   "csvFormatBody": function() { return /* binding */ csvFormatBody; },
/* harmony export */   "csvFormatRows": function() { return /* binding */ csvFormatRows; },
/* harmony export */   "csvFormatRow": function() { return /* binding */ csvFormatRow; },
/* harmony export */   "csvFormatValue": function() { return /* binding */ csvFormatValue; }
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__.default)(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": function() { return /* binding */ format; },
/* harmony export */   "formatPrefix": function() { return /* binding */ formatPrefix; },
/* harmony export */   "default": function() { return /* binding */ defaultLocale; }
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; },
/* harmony export */   "formatDecimalParts": function() { return /* binding */ formatDecimalParts; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefixExponent": function() { return /* binding */ prefixExponent; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ formatSpecifier; },
/* harmony export */   "FormatSpecifier": function() { return /* binding */ FormatSpecifier; }
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ __webpack_exports__["default"] = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.default,
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default)(x * 100, p); },
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default,
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__.default,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__.default)(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__.default)(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-hexbin/index.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-hexbin/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hexbin": function() { return /* reexport safe */ _src_hexbin__WEBPACK_IMPORTED_MODULE_0__.default; }
/* harmony export */ });
/* harmony import */ var _src_hexbin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/hexbin */ "./node_modules/d3-hexbin/src/hexbin.js");



/***/ }),

/***/ "./node_modules/d3-hexbin/src/hexbin.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-hexbin/src/hexbin.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) continue;

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) bin.push(point);
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/build/d3-interpolate.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-interpolate/build/d3-interpolate.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// https://d3js.org/d3-interpolate/ Version 1.0.0. Copyright 2016 Mike Bostock.
(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js")) :
  0;
}(this, function (exports,d3Color) { 'use strict';

  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0
        + (4 - 6 * t2 + 3 * t3) * v1
        + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
        + t3 * v3) / 6;
  }

  function basis$1(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
          v1 = values[i],
          v2 = values[i + 1],
          v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
          v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  function basisClosed(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
          v0 = values[(i + n - 1) % n],
          v1 = values[i % n],
          v2 = values[(i + 1) % n],
          v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant(isNaN(a) ? b : a);
  }

  var rgb$1 = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb(start, end) {
      var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = color(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb.gamma = rgbGamma;

    return rgb;
  })(1);

  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length,
          r = new Array(n),
          g = new Array(n),
          b = new Array(n),
          i, color;
      for (i = 0; i < n; ++i) {
        color = d3Color.rgb(colors[i]);
        r[i] = color.r || 0;
        g[i] = color.g || 0;
        b[i] = color.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color.opacity = 1;
      return function(t) {
        color.r = r(t);
        color.g = g(t);
        color.b = b(t);
        return color + "";
      };
    };
  }

  var rgbBasis = rgbSpline(basis$1);
  var rgbBasisClosed = rgbSpline(basisClosed);

  function array(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(nb),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function number(a, b) {
    return a = +a, b -= a, function(t) {
      return a + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = value(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: number(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function value(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant(b)
        : (t === "number" ? number
        : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
        : b instanceof d3Color.color ? rgb$1
        : Array.isArray(b) ? array
        : object)(a, b);
  }

  function round(a, b) {
    return a = +a, b -= a, function(t) {
      return Math.round(a + b * t);
    };
  }

  var degrees = 180 / Math.PI;

  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };

  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var cssNode;
  var cssRoot;
  var cssView;
  var svgNode;
  function parseCss(value) {
    if (value === "none") return identity;
    if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    var m = value.slice(7, -1).split(",");
    return decompose(+m[0], +m[1], +m[2], +m[3], +m[4], +m[5]);
  }

  function parseSvg(value) {
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value == null ? "" : value);
    var m = svgNode.transform.baseVal.consolidate().matrix;
    return decompose(m.a, m.b, m.c, m.d, m.e, m.f);
  }

  function interpolateTransform(parse, pxComma, pxParen, degParen) {

    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }

    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }

    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
        q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }

    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }

    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }

    return function(a, b) {
      var s = [], // string constants and placeholders
          q = []; // number interpolators
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null; // gc
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }

  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  var rho = Math.SQRT2;
  var rho2 = 2;
  var rho4 = 4;
  var epsilon2 = 1e-12;
  function cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }

  function sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }

  function tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000;

    return i;
  }

  function hsl$1(hue) {
    return function(start, end) {
      var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
  }

  var hsl$2 = hsl$1(hue);
  var hslLong = hsl$1(nogamma);

  function lab$1(start, end) {
    var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
        a = nogamma(start.a, end.a),
        b = nogamma(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.l = l(t);
      start.a = a(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  function hcl$1(hue) {
    return function(start, end) {
      var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
          c = nogamma(start.c, end.c),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.c = c(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
  }

  var hcl$2 = hcl$1(hue);
  var hclLong = hcl$1(nogamma);

  function cubehelix$1(hue) {
    return (function cubehelixGamma(y) {
      y = +y;

      function cubehelix(start, end) {
        var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }

      cubehelix.gamma = cubehelixGamma;

      return cubehelix;
    })(1);
  }

  var cubehelix$2 = cubehelix$1(hue);
  var cubehelixLong = cubehelix$1(nogamma);

  function quantize(interpolate, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i) samples[i] = interpolate(i / (n - 1));
    return samples;
  }

  exports.interpolate = value;
  exports.interpolateArray = array;
  exports.interpolateBasis = basis$1;
  exports.interpolateBasisClosed = basisClosed;
  exports.interpolateNumber = number;
  exports.interpolateObject = object;
  exports.interpolateRound = round;
  exports.interpolateString = string;
  exports.interpolateTransformCss = interpolateTransformCss;
  exports.interpolateTransformSvg = interpolateTransformSvg;
  exports.interpolateZoom = zoom;
  exports.interpolateRgb = rgb$1;
  exports.interpolateRgbBasis = rgbBasis;
  exports.interpolateRgbBasisClosed = rgbBasisClosed;
  exports.interpolateHsl = hsl$2;
  exports.interpolateHslLong = hslLong;
  exports.interpolateLab = lab$1;
  exports.interpolateHcl = hcl$2;
  exports.interpolateHclLong = hclLong;
  exports.interpolateCubehelix = cubehelix$2;
  exports.interpolateCubehelixLong = cubehelixLong;
  exports.quantize = quantize;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

/***/ }),

/***/ "./node_modules/d3-scale/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-scale/src/array.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "map": function() { return /* binding */ map; },
/* harmony export */   "slice": function() { return /* binding */ slice; }
/* harmony export */ });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ band; },
/* harmony export */   "point": function() { return /* binding */ point; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordinal */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = (0,_ordinal__WEBPACK_IMPORTED_MODULE_2__.default)().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": function() { return /* binding */ identity; },
/* harmony export */   "copy": function() { return /* binding */ copy; },
/* harmony export */   "transformer": function() { return /* binding */ transformer; },
/* harmony export */   "default": function() { return /* binding */ continuous; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/build/d3-interpolate.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/d3-scale/src/number.js");






var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant__WEBPACK_IMPORTED_MODULE_3__.default)(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisect)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_2__.map.call(_, _number__WEBPACK_IMPORTED_MODULE_4__.default), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_2__.slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = _array__WEBPACK_IMPORTED_MODULE_2__.slice.call(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/diverging.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/diverging.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ diverging; },
/* harmony export */   "divergingLog": function() { return /* binding */ divergingLog; },
/* harmony export */   "divergingSymlog": function() { return /* binding */ divergingSymlog; },
/* harmony export */   "divergingPow": function() { return /* binding */ divergingPow; },
/* harmony export */   "divergingSqrt": function() { return /* binding */ divergingSqrt; }
/* harmony export */ });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sequential */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");








function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__.identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = (0,_linear__WEBPACK_IMPORTED_MODULE_2__.linearish)(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return (0,_sequential__WEBPACK_IMPORTED_MODULE_4__.copy)(scale, diverging());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = (0,_log__WEBPACK_IMPORTED_MODULE_3__.loggish)(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return (0,_sequential__WEBPACK_IMPORTED_MODULE_4__.copy)(scale, divergingLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = (0,_symlog__WEBPACK_IMPORTED_MODULE_5__.symlogish)(transformer());

  scale.copy = function() {
    return (0,_sequential__WEBPACK_IMPORTED_MODULE_4__.copy)(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = (0,_pow__WEBPACK_IMPORTED_MODULE_6__.powish)(transformer());

  scale.copy = function() {
    return (0,_sequential__WEBPACK_IMPORTED_MODULE_4__.copy)(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/identity.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ identity; }
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number */ "./node_modules/d3-scale/src/number.js");




function identity(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_0__.map.call(_, _number__WEBPACK_IMPORTED_MODULE_2__.default), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? _array__WEBPACK_IMPORTED_MODULE_0__.map.call(domain, _number__WEBPACK_IMPORTED_MODULE_2__.default) : [0, 1];

  return (0,_linear__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-scale/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scaleBand": function() { return /* reexport safe */ _band__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "scalePoint": function() { return /* reexport safe */ _band__WEBPACK_IMPORTED_MODULE_0__.point; },
/* harmony export */   "scaleIdentity": function() { return /* reexport safe */ _identity__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "scaleLinear": function() { return /* reexport safe */ _linear__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "scaleLog": function() { return /* reexport safe */ _log__WEBPACK_IMPORTED_MODULE_3__.default; },
/* harmony export */   "scaleSymlog": function() { return /* reexport safe */ _symlog__WEBPACK_IMPORTED_MODULE_4__.default; },
/* harmony export */   "scaleOrdinal": function() { return /* reexport safe */ _ordinal__WEBPACK_IMPORTED_MODULE_5__.default; },
/* harmony export */   "scaleImplicit": function() { return /* reexport safe */ _ordinal__WEBPACK_IMPORTED_MODULE_5__.implicit; },
/* harmony export */   "scalePow": function() { return /* reexport safe */ _pow__WEBPACK_IMPORTED_MODULE_6__.default; },
/* harmony export */   "scaleSqrt": function() { return /* reexport safe */ _pow__WEBPACK_IMPORTED_MODULE_6__.sqrt; },
/* harmony export */   "scaleQuantile": function() { return /* reexport safe */ _quantile__WEBPACK_IMPORTED_MODULE_7__.default; },
/* harmony export */   "scaleQuantize": function() { return /* reexport safe */ _quantize__WEBPACK_IMPORTED_MODULE_8__.default; },
/* harmony export */   "scaleThreshold": function() { return /* reexport safe */ _threshold__WEBPACK_IMPORTED_MODULE_9__.default; },
/* harmony export */   "scaleTime": function() { return /* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_10__.default; },
/* harmony export */   "scaleUtc": function() { return /* reexport safe */ _utcTime__WEBPACK_IMPORTED_MODULE_11__.default; },
/* harmony export */   "scaleSequential": function() { return /* reexport safe */ _sequential__WEBPACK_IMPORTED_MODULE_12__.default; },
/* harmony export */   "scaleSequentialLog": function() { return /* reexport safe */ _sequential__WEBPACK_IMPORTED_MODULE_12__.sequentialLog; },
/* harmony export */   "scaleSequentialPow": function() { return /* reexport safe */ _sequential__WEBPACK_IMPORTED_MODULE_12__.sequentialPow; },
/* harmony export */   "scaleSequentialSqrt": function() { return /* reexport safe */ _sequential__WEBPACK_IMPORTED_MODULE_12__.sequentialSqrt; },
/* harmony export */   "scaleSequentialSymlog": function() { return /* reexport safe */ _sequential__WEBPACK_IMPORTED_MODULE_12__.sequentialSymlog; },
/* harmony export */   "scaleSequentialQuantile": function() { return /* reexport safe */ _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__.default; },
/* harmony export */   "scaleDiverging": function() { return /* reexport safe */ _diverging__WEBPACK_IMPORTED_MODULE_14__.default; },
/* harmony export */   "scaleDivergingLog": function() { return /* reexport safe */ _diverging__WEBPACK_IMPORTED_MODULE_14__.divergingLog; },
/* harmony export */   "scaleDivergingPow": function() { return /* reexport safe */ _diverging__WEBPACK_IMPORTED_MODULE_14__.divergingPow; },
/* harmony export */   "scaleDivergingSqrt": function() { return /* reexport safe */ _diverging__WEBPACK_IMPORTED_MODULE_14__.divergingSqrt; },
/* harmony export */   "scaleDivergingSymlog": function() { return /* reexport safe */ _diverging__WEBPACK_IMPORTED_MODULE_14__.divergingSymlog; },
/* harmony export */   "tickFormat": function() { return /* reexport safe */ _tickFormat__WEBPACK_IMPORTED_MODULE_15__.default; }
/* harmony export */ });
/* harmony import */ var _band__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./band */ "./node_modules/d3-scale/src/band.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-scale/src/identity.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ordinal */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var _quantize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./quantize */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var _threshold__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./time */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var _utcTime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utcTime */ "./node_modules/d3-scale/src/utcTime.js");
/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sequential */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sequentialQuantile */ "./node_modules/d3-scale/src/sequentialQuantile.js");
/* harmony import */ var _diverging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diverging */ "./node_modules/d3-scale/src/diverging.js");
/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tickFormat */ "./node_modules/d3-scale/src/tickFormat.js");

































/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initRange": function() { return /* binding */ initRange; },
/* harmony export */   "initInterpolator": function() { return /* binding */ initInterpolator; }
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearish": function() { return /* binding */ linearish; },
/* harmony export */   "default": function() { return /* binding */ linear; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tickFormat */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.ticks)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat__WEBPACK_IMPORTED_MODULE_3__.default)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous__WEBPACK_IMPORTED_MODULE_1__.default)(_continuous__WEBPACK_IMPORTED_MODULE_1__.identity, _continuous__WEBPACK_IMPORTED_MODULE_1__.identity);

  scale.copy = function() {
    return (0,_continuous__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, linear());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/log.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/log.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loggish": function() { return /* binding */ loggish; },
/* harmony export */   "default": function() { return /* binding */ log; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nice */ "./node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.ticks)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain((0,_nice__WEBPACK_IMPORTED_MODULE_1__.default)(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish((0,_continuous__WEBPACK_IMPORTED_MODULE_2__.transformer)()).domain([1, 10]);

  scale.copy = function() {
    return (0,_continuous__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, log()).base(scale.base());
  };

  _init__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/nice.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/nice.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "implicit": function() { return /* binding */ implicit; },
/* harmony export */   "default": function() { return /* binding */ ordinal; }
/* harmony export */ });
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




var implicit = {name: "implicit"};

function ordinal() {
  var index = (0,d3_collection__WEBPACK_IMPORTED_MODULE_0__.map)(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = (0,d3_collection__WEBPACK_IMPORTED_MODULE_0__.map)();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__.slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "powish": function() { return /* binding */ powish; },
/* harmony export */   "default": function() { return /* binding */ pow; },
/* harmony export */   "sqrt": function() { return /* binding */ sqrt; }
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous__WEBPACK_IMPORTED_MODULE_1__.identity, _continuous__WEBPACK_IMPORTED_MODULE_1__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous__WEBPACK_IMPORTED_MODULE_1__.identity, _continuous__WEBPACK_IMPORTED_MODULE_1__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear__WEBPACK_IMPORTED_MODULE_0__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous__WEBPACK_IMPORTED_MODULE_1__.transformer)());

  scale.copy = function() {
    return (0,_continuous__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ quantile; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantile)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisect)(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__.slice.call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ quantize; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");





function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisect)(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = _array__WEBPACK_IMPORTED_MODULE_1__.slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_3__.initRange.apply((0,_linear__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/sequential.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/sequential.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copy": function() { return /* binding */ copy; },
/* harmony export */   "default": function() { return /* binding */ sequential; },
/* harmony export */   "sequentialLog": function() { return /* binding */ sequentialLog; },
/* harmony export */   "sequentialSymlog": function() { return /* binding */ sequentialSymlog; },
/* harmony export */   "sequentialPow": function() { return /* binding */ sequentialPow; },
/* harmony export */   "sequentialSqrt": function() { return /* binding */ sequentialSqrt; }
/* harmony export */ });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pow */ "./node_modules/d3-scale/src/pow.js");







function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__.identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = (0,_linear__WEBPACK_IMPORTED_MODULE_2__.linearish)(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = (0,_log__WEBPACK_IMPORTED_MODULE_3__.loggish)(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = (0,_symlog__WEBPACK_IMPORTED_MODULE_4__.symlogish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = (0,_pow__WEBPACK_IMPORTED_MODULE_5__.powish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__.initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/sequentialQuantile.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-scale/src/sequentialQuantile.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ sequentialQuantile; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function sequentialQuantile() {
  var domain = [],
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_1__.identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator(((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisect)(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__.initInterpolator.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/symlog.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/symlog.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symlogish": function() { return /* binding */ symlogish; },
/* harmony export */   "default": function() { return /* binding */ symlog; }
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return (0,_linear__WEBPACK_IMPORTED_MODULE_0__.linearish)(scale);
}

function symlog() {
  var scale = symlogish((0,_continuous__WEBPACK_IMPORTED_MODULE_1__.transformer)());

  scale.copy = function() {
    return (0,_continuous__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, symlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ threshold; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");




function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisect)(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_1__.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.default)(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/time.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/time.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calendar": function() { return /* binding */ calendar; },
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/millisecond.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/d3-scale/src/array.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nice */ "./node_modules/d3-scale/src/nice.js");








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = (0,_continuous__WEBPACK_IMPORTED_MODULE_2__.default)(_continuous__WEBPACK_IMPORTED_MODULE_2__.identity, _continuous__WEBPACK_IMPORTED_MODULE_2__.identity),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.bisector)(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(_array__WEBPACK_IMPORTED_MODULE_1__.map.call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain((0,_nice__WEBPACK_IMPORTED_MODULE_4__.default)(d, interval))
        : scale;
  };

  scale.copy = function() {
    return (0,_continuous__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return _init__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_5__.default, d3_time__WEBPACK_IMPORTED_MODULE_6__.default, d3_time__WEBPACK_IMPORTED_MODULE_7__.sunday, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time__WEBPACK_IMPORTED_MODULE_10__.default, d3_time__WEBPACK_IMPORTED_MODULE_11__.default, d3_time__WEBPACK_IMPORTED_MODULE_12__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_13__.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/utcTime.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/utcTime.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/millisecond.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./node_modules/d3-scale/src/init.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return _init__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_time__WEBPACK_IMPORTED_MODULE_0__.calendar)(d3_time__WEBPACK_IMPORTED_MODULE_2__.default, d3_time__WEBPACK_IMPORTED_MODULE_3__.default, d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday, d3_time__WEBPACK_IMPORTED_MODULE_5__.default, d3_time__WEBPACK_IMPORTED_MODULE_6__.default, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_10__.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "./node_modules/d3-time-format/src/defaultLocale.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-time-format/src/defaultLocale.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeFormat": function() { return /* binding */ timeFormat; },
/* harmony export */   "timeParse": function() { return /* binding */ timeParse; },
/* harmony export */   "utcFormat": function() { return /* binding */ utcFormat; },
/* harmony export */   "utcParse": function() { return /* binding */ utcParse; },
/* harmony export */   "default": function() { return /* binding */ defaultLocale; }
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-time-format/src/locale.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-time-format/src/locale.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ formatLocale; }
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_1__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.monday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_3__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcSunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "./node_modules/d3-time/src/day.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-time/src/day.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "days": function() { return /* binding */ days; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var day = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (day);
var days = day.range;


/***/ }),

/***/ "./node_modules/d3-time/src/duration.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/duration.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "durationSecond": function() { return /* binding */ durationSecond; },
/* harmony export */   "durationMinute": function() { return /* binding */ durationMinute; },
/* harmony export */   "durationHour": function() { return /* binding */ durationHour; },
/* harmony export */   "durationDay": function() { return /* binding */ durationDay; },
/* harmony export */   "durationWeek": function() { return /* binding */ durationWeek; }
/* harmony export */ });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),

/***/ "./node_modules/d3-time/src/hour.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/hour.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hours": function() { return /* binding */ hours; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var hour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["default"] = (hour);
var hours = hour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/interval.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/interval.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ newInterval; }
/* harmony export */ });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "./node_modules/d3-time/src/millisecond.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-time/src/millisecond.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "milliseconds": function() { return /* binding */ milliseconds; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var millisecond = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["default"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "./node_modules/d3-time/src/minute.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/minute.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "minutes": function() { return /* binding */ minutes; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var minute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (minute);
var minutes = minute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/month.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-time/src/month.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "months": function() { return /* binding */ months; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var month = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (month);
var months = month.range;


/***/ }),

/***/ "./node_modules/d3-time/src/second.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/second.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "seconds": function() { return /* binding */ seconds; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var second = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["default"] = (second);
var seconds = second.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcDay.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/utcDay.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcDays": function() { return /* binding */ utcDays; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcDay = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcHour.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcHour.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcHours": function() { return /* binding */ utcHours; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcHour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["default"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMinute.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-time/src/utcMinute.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcMinutes": function() { return /* binding */ utcMinutes; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcMinute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMonth.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/utcMonth.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcMonths": function() { return /* binding */ utcMonths; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcMonth = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcWeek.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcSunday": function() { return /* binding */ utcSunday; },
/* harmony export */   "utcMonday": function() { return /* binding */ utcMonday; },
/* harmony export */   "utcTuesday": function() { return /* binding */ utcTuesday; },
/* harmony export */   "utcWednesday": function() { return /* binding */ utcWednesday; },
/* harmony export */   "utcThursday": function() { return /* binding */ utcThursday; },
/* harmony export */   "utcFriday": function() { return /* binding */ utcFriday; },
/* harmony export */   "utcSaturday": function() { return /* binding */ utcSaturday; },
/* harmony export */   "utcSundays": function() { return /* binding */ utcSundays; },
/* harmony export */   "utcMondays": function() { return /* binding */ utcMondays; },
/* harmony export */   "utcTuesdays": function() { return /* binding */ utcTuesdays; },
/* harmony export */   "utcWednesdays": function() { return /* binding */ utcWednesdays; },
/* harmony export */   "utcThursdays": function() { return /* binding */ utcThursdays; },
/* harmony export */   "utcFridays": function() { return /* binding */ utcFridays; },
/* harmony export */   "utcSaturdays": function() { return /* binding */ utcSaturdays; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcYear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcYear.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcYears": function() { return /* binding */ utcYears; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcYear = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "./node_modules/d3-time/src/week.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/week.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sunday": function() { return /* binding */ sunday; },
/* harmony export */   "monday": function() { return /* binding */ monday; },
/* harmony export */   "tuesday": function() { return /* binding */ tuesday; },
/* harmony export */   "wednesday": function() { return /* binding */ wednesday; },
/* harmony export */   "thursday": function() { return /* binding */ thursday; },
/* harmony export */   "friday": function() { return /* binding */ friday; },
/* harmony export */   "saturday": function() { return /* binding */ saturday; },
/* harmony export */   "sundays": function() { return /* binding */ sundays; },
/* harmony export */   "mondays": function() { return /* binding */ mondays; },
/* harmony export */   "tuesdays": function() { return /* binding */ tuesdays; },
/* harmony export */   "wednesdays": function() { return /* binding */ wednesdays; },
/* harmony export */   "thursdays": function() { return /* binding */ thursdays; },
/* harmony export */   "fridays": function() { return /* binding */ fridays; },
/* harmony export */   "saturdays": function() { return /* binding */ saturdays; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function weekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/year.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/year.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "years": function() { return /* binding */ years; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var year = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (year);
var years = year.range;


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/Function.js":
/*!***************************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/Function.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _vm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vm */ "./node_modules/l7eval5/dist/esm/vm.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var code = args.pop();
  return (0,_vm__WEBPACK_IMPORTED_MODULE_0__.compileFunction)(code || "", args);
}

/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/evaluate.js":
/*!***************************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/evaluate.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vm */ "./node_modules/l7eval5/dist/esm/vm.js");

/* harmony default export */ __webpack_exports__["default"] = (function (code, ctx, options) {
  return (0,_vm__WEBPACK_IMPORTED_MODULE_0__.runInContext)(code, ctx, options);
});

/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interpreter": function() { return /* reexport safe */ _interpreter_main__WEBPACK_IMPORTED_MODULE_0__.Interpreter; },
/* harmony export */   "vm": function() { return /* reexport module object */ _vm__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "evaluate": function() { return /* reexport safe */ _evaluate__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "Function": function() { return /* reexport safe */ _Function__WEBPACK_IMPORTED_MODULE_3__.default; }
/* harmony export */ });
/* harmony import */ var _interpreter_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interpreter/main */ "./node_modules/l7eval5/dist/esm/interpreter/main.js");
/* harmony import */ var _vm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vm */ "./node_modules/l7eval5/dist/esm/vm.js");
/* harmony import */ var _evaluate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./evaluate */ "./node_modules/l7eval5/dist/esm/evaluate.js");
/* harmony import */ var _Function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Function */ "./node_modules/l7eval5/dist/esm/Function.js");





/* harmony default export */ __webpack_exports__["default"] = (_evaluate__WEBPACK_IMPORTED_MODULE_2__.default);

/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/interpreter/main.js":
/*!***********************************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/interpreter/main.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interpreter": function() { return /* binding */ Interpreter; }
/* harmony export */ });
/* harmony import */ var acorn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages */ "./node_modules/l7eval5/dist/esm/interpreter/messages.js");
function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var version = "0.0.3";

function defineFunctionName(func, name) {
  Object.defineProperty(func, "name", {
    value: name,
    writable: false,
    enumerable: false,
    configurable: true
  });
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var Break = Symbol("Break");
var Continue = Symbol("Continue");
var DefaultCase = Symbol("DefaultCase");
var EmptyStatementReturn = Symbol("EmptyStatementReturn");
var WithScopeName = Symbol("WithScopeName");
var SuperScopeName = Symbol("SuperScopeName");
var RootScopeName = Symbol("RootScopeName");
var GlobalScopeName = Symbol("GlobalScopeName");

function isFunction(func) {
  return typeof func === "function";
}

var InternalInterpreterReflection =
/*#__PURE__*/
function () {
  function InternalInterpreterReflection(interpreter) {
    this.interpreter = interpreter;
  }

  var _proto = InternalInterpreterReflection.prototype;

  _proto.generator = function generator() {
    var interpreter = this.interpreter;

    function getCurrentScope() {
      return this.getCurrentScope();
    }

    function getGlobalScope() {
      return this.getGlobalScope();
    }

    function getCurrentContext() {
      return this.getCurrentContext();
    }

    return {
      getOptions: interpreter.getOptions.bind(interpreter),
      getCurrentScope: getCurrentScope.bind(interpreter),
      getGlobalScope: getGlobalScope.bind(interpreter),
      getCurrentContext: getCurrentContext.bind(interpreter),
      getExecStartTime: interpreter.getExecStartTime.bind(interpreter)
    };
  };

  return InternalInterpreterReflection;
}();

function internalEval(reflection, code, useGlobalScope) {
  if (useGlobalScope === void 0) {
    useGlobalScope = true;
  }

  if (!(reflection instanceof InternalInterpreterReflection)) {
    throw new Error("Illegal call");
  }

  if (typeof code !== "string") return code;
  if (!code) return void 0;
  var instance = reflection.generator();
  var opts = instance.getOptions();
  var options = {
    timeout: opts.timeout,
    _initEnv: function _initEnv() {
      // set caller context
      if (!useGlobalScope) {
        this.setCurrentContext(instance.getCurrentContext());
      } // share timeout


      this.execStartTime = instance.getExecStartTime();
      this.execEndTime = this.execStartTime;
    }
  };
  var currentScope = useGlobalScope ? instance.getGlobalScope() : instance.getCurrentScope();
  var interpreter = new Interpreter(currentScope, options);
  return interpreter.evaluate(code);
}

Object.defineProperty(internalEval, "__IS_EVAL_FUNC", {
  value: true,
  writable: false,
  enumerable: false,
  configurable: false
});

function internalFunction(reflection) {
  if (!(reflection instanceof InternalInterpreterReflection)) {
    throw new Error("Illegal call");
  }

  var instance = reflection.generator();

  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }

  var code = params.pop();
  var interpreter = new Interpreter(instance.getGlobalScope(), instance.getOptions());
  var wrapCode = "\n\t\t    (function anonymous(" + params.join(",") + "){\n\t\t        " + code + "\n\t\t    });\n\t\t    ";
  return interpreter.evaluate(wrapCode);
}

Object.defineProperty(internalFunction, "__IS_FUNCTION_FUNC", {
  value: true,
  writable: false,
  enumerable: false,
  configurable: false
});

var Return = function Return(value) {
  this.value = value;
};

var BreakLabel = function BreakLabel(value) {
  this.value = value;
};

var ContinueLabel = function ContinueLabel(value) {
  this.value = value;
};
/**
 * scope chain
 *
 * superScope
 *     
 * rootScope
 *     
 * globalScope
 *     
 * functionScope
 *
 */


var Scope = function Scope(data, parent, name) {
  if (parent === void 0) {
    parent = null;
  }

  this.name = name;
  this.parent = parent;
  this.data = data;
  this.labelStack = [];
};

function noop() {}

function createScope(parent, name) {
  if (parent === void 0) {
    parent = null;
  }

  return new Scope(Object.create(null), parent, name);
}

function createRootContext(data) {
  return Object.create(data);
}

var BuildInObjects = {
  NaN: NaN,
  Infinity: Infinity,
  undefined: undefined,
  // null,
  Object: Object,
  Array: Array,
  String: String,
  Boolean: Boolean,
  Number: Number,
  Date: Date,
  RegExp: RegExp,
  Error: Error,
  URIError: URIError,
  TypeError: TypeError,
  RangeError: RangeError,
  SyntaxError: SyntaxError,
  ReferenceError: ReferenceError,
  Float32Array: Float32Array,
  Float64Array: Float64Array,
  Uint32Array: Uint32Array,
  Math: Math,
  parseInt: parseInt,
  parseFloat: parseFloat,
  isNaN: isNaN,
  isFinite: isFinite,
  decodeURI: decodeURI,
  decodeURIComponent: decodeURIComponent,
  encodeURI: encodeURI,
  encodeURIComponent: encodeURIComponent,
  escape: escape,
  unescape: unescape,
  eval: internalEval,
  Function: internalFunction
}; // ES5 Object

if (typeof JSON !== "undefined") {
  BuildInObjects.JSON = JSON;
} //ES6 Object


if (typeof Promise !== "undefined") {
  BuildInObjects.Promise = Promise;
}

if (typeof Set !== "undefined") {
  BuildInObjects.Set = Set;
}

if (typeof Map !== "undefined") {
  BuildInObjects.Map = Map;
}

if (typeof Symbol !== "undefined") {
  BuildInObjects.Symbol = Symbol;
}

if (typeof Proxy !== "undefined") {
  BuildInObjects.Proxy = Proxy;
}

if (typeof WeakMap !== "undefined") {
  BuildInObjects.WeakMap = WeakMap;
}

if (typeof WeakSet !== "undefined") {
  BuildInObjects.WeakSet = WeakSet;
}

if (typeof Reflect !== "undefined") {
  BuildInObjects.Reflect = Reflect;
}

var Interpreter =
/*#__PURE__*/
function () {
  function Interpreter(context, options) {
    if (context === void 0) {
      context = Interpreter.global;
    }

    if (options === void 0) {
      options = {};
    }

    this.sourceList = [];
    this.collectDeclVars = Object.create(null);
    this.collectDeclFuncs = Object.create(null);
    this.isVarDeclMode = false;
    this.lastExecNode = null;
    this.isRunning = false;
    this.options = {
      ecmaVersion: options.ecmaVersion || Interpreter.ecmaVersion,
      timeout: options.timeout || 0,
      rootContext: options.rootContext,
      globalContextInFunction: options.globalContextInFunction === undefined ? Interpreter.globalContextInFunction : options.globalContextInFunction,
      _initEnv: options._initEnv
    };
    this.context = context || Object.create(null);
    this.callStack = [];
    this.initEnvironment(this.context);
  }

  var _proto2 = Interpreter.prototype;

  _proto2.initEnvironment = function initEnvironment(ctx) {
    var scope; //init global scope

    if (ctx instanceof Scope) {
      scope = ctx;
    } else {
      var rootScope = null;
      var superScope = this.createSuperScope(ctx);

      if (this.options.rootContext) {
        rootScope = new Scope(createRootContext(this.options.rootContext), superScope, RootScopeName);
      }

      scope = new Scope(ctx, rootScope || superScope, GlobalScopeName);
    }

    this.globalScope = scope;
    this.currentScope = this.globalScope; //init global context to this

    this.globalContext = scope.data;
    this.currentContext = scope.data; // collect var/function declare

    this.collectDeclVars = Object.create(null);
    this.collectDeclFuncs = Object.create(null);
    this.execStartTime = Date.now();
    this.execEndTime = this.execStartTime;
    var _initEnv = this.options._initEnv;

    if (_initEnv) {
      _initEnv.call(this);
    }
  };

  _proto2.getExecStartTime = function getExecStartTime() {
    return this.execStartTime;
  };

  _proto2.getExecutionTime = function getExecutionTime() {
    return this.execEndTime - this.execStartTime;
  };

  _proto2.setExecTimeout = function setExecTimeout(timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }

    this.options.timeout = timeout;
  };

  _proto2.getOptions = function getOptions() {
    return this.options;
  };

  _proto2.getGlobalScope = function getGlobalScope() {
    return this.globalScope;
  };

  _proto2.getCurrentScope = function getCurrentScope() {
    return this.currentScope;
  };

  _proto2.getCurrentContext = function getCurrentContext() {
    return this.currentContext;
  };

  _proto2.isInterruptThrow = function isInterruptThrow(err) {
    return err instanceof _messages__WEBPACK_IMPORTED_MODULE_1__.InterruptThrowError || err instanceof _messages__WEBPACK_IMPORTED_MODULE_1__.InterruptThrowReferenceError || err instanceof _messages__WEBPACK_IMPORTED_MODULE_1__.InterruptThrowSyntaxError;
  };

  _proto2.createSuperScope = function createSuperScope(ctx) {
    var data = Object.assign({}, BuildInObjects);
    var buildInObjectKeys = Object.keys(data);
    buildInObjectKeys.forEach(function (key) {
      if (key in ctx) {
        delete data[key];
      }
    });
    return new Scope(data, null, SuperScopeName);
  };

  _proto2.setCurrentContext = function setCurrentContext(ctx) {
    this.currentContext = ctx;
  };

  _proto2.setCurrentScope = function setCurrentScope(scope) {
    this.currentScope = scope;
  };

  _proto2.evaluate = function evaluate(code) {
    if (code === void 0) {
      code = "";
    }

    var node;
    if (!code) return;
    node = (0,acorn__WEBPACK_IMPORTED_MODULE_0__.parse)(code, {
      ranges: true,
      locations: true,
      ecmaVersion: this.options.ecmaVersion || Interpreter.ecmaVersion
    });
    return this.evaluateNode(node, code);
  };

  _proto2.appendCode = function appendCode(code) {
    return this.evaluate(code);
  };

  _proto2.evaluateNode = function evaluateNode(node, source) {
    var _this = this;

    if (source === void 0) {
      source = "";
    }

    this.value = undefined;
    this.source = source;
    this.sourceList.push(source);
    this.isRunning = true; //reset timeout

    this.execStartTime = Date.now();
    this.execEndTime = this.execStartTime; // reset

    this.collectDeclVars = Object.create(null);
    this.collectDeclFuncs = Object.create(null);
    var currentScope = this.getCurrentScope();
    var currentContext = this.getCurrentContext();
    var labelStack = currentScope.labelStack.concat([]);
    var callStack = this.callStack.concat([]);

    var reset = function reset() {
      _this.setCurrentScope(currentScope); //reset scope


      _this.setCurrentContext(currentContext); //reset context


      currentScope.labelStack = labelStack; //reset label stack

      _this.callStack = callStack; //reset call stack
    }; // start run


    try {
      var bodyClosure = this.createClosure(node); // add declares to data

      this.addDeclarationsToScope(this.collectDeclVars, this.collectDeclFuncs, this.getCurrentScope());
      bodyClosure();
    } catch (e) {
      throw e;
    } finally {
      reset();
      this.execEndTime = Date.now();
    }

    this.isRunning = false;
    return this.getValue();
  };

  _proto2.createErrorMessage = function createErrorMessage(msg, value, node) {
    var message = msg[1].replace("%0", String(value));

    if (node !== null) {
      message += this.getNodePosition(node || this.lastExecNode);
    }

    return message;
  };

  _proto2.createError = function createError(message, error) {
    return new error(message);
  };

  _proto2.createThrowError = function createThrowError(message, error) {
    return this.createError(message, error);
  };

  _proto2.createInternalThrowError = function createInternalThrowError(msg, value, node) {
    return this.createError(this.createErrorMessage(msg, value, node), msg[2]);
  };

  _proto2.checkTimeout = function checkTimeout() {
    if (!this.isRunning) return false;
    var timeout = this.options.timeout || 0;
    var now = Date.now();

    if (now - this.execStartTime > timeout) {
      return true;
    }

    return false;
  };

  _proto2.getNodePosition = function getNodePosition(node) {
    if (node) {
      var errorCode = ""; //this.source.slice(node.start, node.end);

      return node.loc ? " [" + node.loc.start.line + ":" + node.loc.start.column + "]" + errorCode : "";
    }

    return "";
  };

  _proto2.createClosure = function createClosure(node) {
    var _this2 = this;

    var closure;

    switch (node.type) {
      case "BinaryExpression":
        closure = this.binaryExpressionHandler(node);
        break;

      case "LogicalExpression":
        closure = this.logicalExpressionHandler(node);
        break;

      case "UnaryExpression":
        closure = this.unaryExpressionHandler(node);
        break;

      case "UpdateExpression":
        closure = this.updateExpressionHandler(node);
        break;

      case "ObjectExpression":
        closure = this.objectExpressionHandler(node);
        break;

      case "ArrayExpression":
        closure = this.arrayExpressionHandler(node);
        break;

      case "CallExpression":
        closure = this.callExpressionHandler(node);
        break;

      case "NewExpression":
        closure = this.newExpressionHandler(node);
        break;

      case "MemberExpression":
        closure = this.memberExpressionHandler(node);
        break;

      case "ThisExpression":
        closure = this.thisExpressionHandler(node);
        break;

      case "SequenceExpression":
        closure = this.sequenceExpressionHandler(node);
        break;

      case "Literal":
        closure = this.literalHandler(node);
        break;

      case "Identifier":
        closure = this.identifierHandler(node);
        break;

      case "AssignmentExpression":
        closure = this.assignmentExpressionHandler(node);
        break;

      case "FunctionDeclaration":
        closure = this.functionDeclarationHandler(node);
        break;

      case "VariableDeclaration":
        closure = this.variableDeclarationHandler(node);
        break;

      case "BlockStatement":
      case "Program":
        closure = this.programHandler(node);
        break;

      case "ExpressionStatement":
        closure = this.expressionStatementHandler(node);
        break;

      case "EmptyStatement":
        closure = this.emptyStatementHandler(node);
        break;

      case "ReturnStatement":
        closure = this.returnStatementHandler(node);
        break;

      case "FunctionExpression":
        closure = this.functionExpressionHandler(node);
        break;

      case "IfStatement":
        closure = this.ifStatementHandler(node);
        break;

      case "ConditionalExpression":
        closure = this.conditionalExpressionHandler(node);
        break;

      case "ForStatement":
        closure = this.forStatementHandler(node);
        break;

      case "WhileStatement":
        closure = this.whileStatementHandler(node);
        break;

      case "DoWhileStatement":
        closure = this.doWhileStatementHandler(node);
        break;

      case "ForInStatement":
        closure = this.forInStatementHandler(node);
        break;

      case "WithStatement":
        closure = this.withStatementHandler(node);
        break;

      case "ThrowStatement":
        closure = this.throwStatementHandler(node);
        break;

      case "TryStatement":
        closure = this.tryStatementHandler(node);
        break;

      case "ContinueStatement":
        closure = this.continueStatementHandler(node);
        break;

      case "BreakStatement":
        closure = this.breakStatementHandler(node);
        break;

      case "SwitchStatement":
        closure = this.switchStatementHandler(node);
        break;

      case "LabeledStatement":
        closure = this.labeledStatementHandler(node);
        break;

      case "DebuggerStatement":
        closure = this.debuggerStatementHandler(node);
        break;

      default:
        throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.NodeTypeSyntaxError, node.type, node);
    }

    return function () {
      var timeout = _this2.options.timeout;

      if (timeout && timeout > 0 && _this2.checkTimeout()) {
        throw _this2.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.ExecutionTimeOutError, timeout, null);
      }

      _this2.lastExecNode = node;
      return closure.apply(void 0, arguments);
    };
  } // a==b a/b
  ;

  _proto2.binaryExpressionHandler = function binaryExpressionHandler(node) {
    var _this3 = this;

    var leftExpression = this.createClosure(node.left);
    var rightExpression = this.createClosure(node.right);
    return function () {
      var leftValue = leftExpression();
      var rightValue = rightExpression();

      switch (node.operator) {
        case "==":
          return leftValue == rightValue;

        case "!=":
          return leftValue != rightValue;

        case "===":
          return leftValue === rightValue;

        case "!==":
          return leftValue !== rightValue;

        case "<":
          return leftValue < rightValue;

        case "<=":
          return leftValue <= rightValue;

        case ">":
          return leftValue > rightValue;

        case ">=":
          return leftValue >= rightValue;

        case "<<":
          return leftValue << rightValue;

        case ">>":
          return leftValue >> rightValue;

        case ">>>":
          return leftValue >>> rightValue;

        case "+":
          return leftValue + rightValue;

        case "-":
          return leftValue - rightValue;

        case "*":
          return leftValue * rightValue;

        case "**":
          return Math.pow(leftValue, rightValue);

        case "/":
          return leftValue / rightValue;

        case "%":
          return leftValue % rightValue;

        case "|":
          return leftValue | rightValue;

        case "^":
          return leftValue ^ rightValue;

        case "&":
          return leftValue & rightValue;

        case "in":
          return leftValue in rightValue;

        case "instanceof":
          return leftValue instanceof rightValue;

        default:
          throw _this3.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.BinaryOperatorSyntaxError, node.operator, node);
      }
    };
  } // a && b
  ;

  _proto2.logicalExpressionHandler = function logicalExpressionHandler(node) {
    var _this4 = this;

    var leftExpression = this.createClosure(node.left);
    var rightExpression = this.createClosure(node.right);
    return function () {
      switch (node.operator) {
        case "||":
          return leftExpression() || rightExpression();

        case "&&":
          return leftExpression() && rightExpression();

        default:
          throw _this4.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.LogicalOperatorSyntaxError, node.operator, node);
      }
    };
  } // protected isRootScope(node: ESTree.Expression | ESTree.Pattern): boolean {
  // 	if (node.type === "Identifier") {
  // 		const scope = this.getScopeFromName(node.name, this.getCurrentScope());
  // 		return scope.name === "rootScope";
  // 	}
  // 	return false;
  // }
  // typeof a !a()
  ;

  _proto2.unaryExpressionHandler = function unaryExpressionHandler(node) {
    var _this5 = this;

    switch (node.operator) {
      case "delete":
        var objectGetter = this.createObjectGetter(node.argument);
        var nameGetter = this.createNameGetter(node.argument);
        return function () {
          // not allowed to delete root scope property
          // rootContext has move to prototype chai, so no judgment required
          // if (this.isRootScope(node.argument)) {
          // 	return false;
          // }
          var obj = objectGetter();
          var name = nameGetter();
          return delete obj[name];
        };

      default:
        var expression; // for typeof undefined var
        // typeof adf9ad

        if (node.operator === "typeof" && node.argument.type === "Identifier") {
          var _objectGetter = this.createObjectGetter(node.argument);

          var _nameGetter = this.createNameGetter(node.argument);

          expression = function expression() {
            return _objectGetter()[_nameGetter()];
          };
        } else {
          expression = this.createClosure(node.argument);
        }

        return function () {
          var value = expression();

          switch (node.operator) {
            case "-":
              return -value;

            case "+":
              return +value;

            case "!":
              return !value;

            case "~":
              return ~value;

            case "void":
              return void value;

            case "typeof":
              return typeof value;

            default:
              throw _this5.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.UnaryOperatorSyntaxError, node.operator, node);
          }
        };
    }
  } // ++a --a
  ;

  _proto2.updateExpressionHandler = function updateExpressionHandler(node) {
    var _this6 = this;

    var objectGetter = this.createObjectGetter(node.argument);
    var nameGetter = this.createNameGetter(node.argument);
    return function () {
      var obj = objectGetter();
      var name = nameGetter();

      _this6.assertVariable(obj, name, node);

      switch (node.operator) {
        case "++":
          return node.prefix ? ++obj[name] : obj[name]++;

        case "--":
          return node.prefix ? --obj[name] : obj[name]--;

        default:
          throw _this6.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.UpdateOperatorSyntaxError, node.operator, node);
      }
    };
  } // var o = {a: 1, b: 's', get name(){}, set name(){}  ...}
  ;

  _proto2.objectExpressionHandler = function objectExpressionHandler(node) {
    var _this7 = this;

    var items = [];

    function getKey(keyNode) {
      if (keyNode.type === "Identifier") {
        // var o = {a:1}
        return keyNode.name;
      } else if (keyNode.type === "Literal") {
        // var o = {"a":1}
        return keyNode.value;
      } else {
        return this.throwError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.ObjectStructureSyntaxError, keyNode.type, keyNode);
      }
    } // collect value, getter, and/or setter.


    var properties = Object.create(null);
    node.properties.forEach(function (property) {
      var kind = property.kind;
      var key = getKey(property.key);

      if (!properties[key] || kind === "init") {
        properties[key] = {};
      }

      properties[key][kind] = _this7.createClosure(property.value);
      items.push({
        key: key,
        property: property
      });
    });
    return function () {
      var result = {};
      var len = items.length;

      for (var i = 0; i < len; i++) {
        var item = items[i];
        var key = item.key;
        var kinds = properties[key];
        var value = kinds.init ? kinds.init() : undefined;
        var getter = kinds.get ? kinds.get() : function () {};
        var setter = kinds.set ? kinds.set() : function (a) {};

        if ("set" in kinds || "get" in kinds) {
          var descriptor = {
            configurable: true,
            enumerable: true,
            get: getter,
            set: setter
          };
          Object.defineProperty(result, key, descriptor);
        } else {
          var property = item.property;
          var kind = property.kind; // set function.name
          // var d = { test(){} }
          // var d = { test: function(){} }

          if (property.key.type === "Identifier" && property.value.type === "FunctionExpression" && kind === "init" && !property.value.id) {
            defineFunctionName(value, property.key.name);
          }

          result[key] = value;
        }
      }

      return result;
    };
  } // [1,2,3]
  ;

  _proto2.arrayExpressionHandler = function arrayExpressionHandler(node) {
    var _this8 = this;

    //fix: [,,,1,2]
    var items = node.elements.map(function (element) {
      return element ? _this8.createClosure(element) : element;
    });
    return function () {
      var len = items.length;
      var result = Array(len);

      for (var i = 0; i < len; i++) {
        var item = items[i];

        if (item) {
          result[i] = item();
        }
      }

      return result;
    };
  };

  _proto2.safeObjectGet = function safeObjectGet(obj, key, node) {
    return obj[key];
  };

  _proto2.createCallFunctionGetter = function createCallFunctionGetter(node) {
    var _this9 = this;

    switch (node.type) {
      case "MemberExpression":
        var objectGetter = this.createClosure(node.object);
        var keyGetter = this.createMemberKeyGetter(node);
        var source = this.source;
        return function () {
          var obj = objectGetter();
          var key = keyGetter();

          var func = _this9.safeObjectGet(obj, key, node);

          if (!func || !isFunction(func)) {
            var name = source.slice(node.start, node.end);
            throw _this9.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.FunctionUndefinedReferenceError, name, node);
          } // obj.eval = eval
          // obj.eval(...)


          if (func.__IS_EVAL_FUNC) {
            return function (code) {
              return func(new InternalInterpreterReflection(_this9), code, true);
            };
          } // obj.func = Function
          // obj.func(...)


          if (func.__IS_FUNCTION_FUNC) {
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              return func.apply(void 0, [new InternalInterpreterReflection(_this9)].concat(args));
            };
          } // method call
          // egobj.say(...)
          // eg: obj.say.call(...)
          // eg: obj.say.apply(...)
          // ======================
          // obj.func(...)
          // func = func.bind(obj)
          // tips:
          // func(...) -> func.bind(obj)(...)
          // func.call(...) -> obj.func.call.bind(obj.func)(...)
          // func.apply(...) -> obj.func.apply.bind(obj.func)(...)
          // ...others


          return func.bind(obj);
        };

      default:
        // test() or (0,test)() or a[1]() ...
        var closure = this.createClosure(node);
        return function () {
          var name = "";

          if (node.type === "Identifier") {
            name = node.name;
          } // const name: string = (<ESTree.Identifier>node).name;


          var func = closure();

          if (!func || !isFunction(func)) {
            throw _this9.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.FunctionUndefinedReferenceError, name, node);
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
          // var eval = eval;
          // function test(){
          //    eval(...); //note: use local scope in eval5but in Browser is use global scope
          // }


          if (node.type === "Identifier" && func.__IS_EVAL_FUNC && name === "eval") {
            return function (code) {
              var scope = _this9.getScopeFromName(name, _this9.getCurrentScope());

              var useGlobalScope = scope.name === SuperScopeName || // !scope.parent || // super scope
              scope.name === GlobalScopeName || // this.globalScope === scope ||
              scope.name === RootScopeName; // use local scope if calling eval in super scope

              return func(new InternalInterpreterReflection(_this9), code, !useGlobalScope);
            };
          } // use global scope
          // var g_eval = eval;
          // g_eval("a+1");
          //(0,eval)(...) ...eval alias


          if (func.__IS_EVAL_FUNC) {
            return function (code) {
              return func(new InternalInterpreterReflection(_this9), code, true);
            };
          } // Function('a', 'b', 'return a+b')


          if (func.__IS_FUNCTION_FUNC) {
            return function () {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }

              return func.apply(void 0, [new InternalInterpreterReflection(_this9)].concat(args));
            };
          }

          var ctx = _this9.options.globalContextInFunction; // with(obj) {
          //     test() // test.call(obj, ...)
          // }

          if (node.type === "Identifier") {
            var scope = _this9.getIdentifierScope(node);

            if (scope.name === WithScopeName) {
              ctx = scope.data;
            }
          } // function call
          // this = undefined
          // tips:
          // test(...) === test.call(undefined, ...)
          // fix: alert.call({}, ...) Illegal invocation


          return func.bind(ctx);
        };
    }
  } // func()
  ;

  _proto2.callExpressionHandler = function callExpressionHandler(node) {
    var _this10 = this;

    var funcGetter = this.createCallFunctionGetter(node.callee);
    var argsGetter = node.arguments.map(function (arg) {
      return _this10.createClosure(arg);
    });
    return function () {
      return funcGetter().apply(void 0, argsGetter.map(function (arg) {
        return arg();
      }));
    };
  } // var f = function() {...}
  ;

  _proto2.functionExpressionHandler = function functionExpressionHandler(node) {
    var _this11 = this;

    var self = this;
    var source = this.source;
    var oldDeclVars = this.collectDeclVars;
    var oldDeclFuncs = this.collectDeclFuncs;
    this.collectDeclVars = Object.create(null);
    this.collectDeclFuncs = Object.create(null);
    var name = node.id ? node.id.name : "";
    /**anonymous*/

    var paramLength = node.params.length;
    var paramsGetter = node.params.map(function (param) {
      return _this11.createParamNameGetter(param);
    }); // set scope

    var bodyClosure = this.createClosure(node.body);
    var declVars = this.collectDeclVars;
    var declFuncs = this.collectDeclFuncs;
    this.collectDeclVars = oldDeclVars;
    this.collectDeclFuncs = oldDeclFuncs;
    return function () {
      // bind current scope
      var runtimeScope = self.getCurrentScope();

      var func = function func() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        self.callStack.push("" + name);
        var prevScope = self.getCurrentScope();
        var currentScope = createScope(runtimeScope, "FunctionScope(" + name + ")");
        self.setCurrentScope(currentScope);
        self.addDeclarationsToScope(declVars, declFuncs, currentScope); // var t = function(){ typeof t } // function
        // t = function(){ typeof t } // function
        // z = function tx(){ typeof tx } // function
        // but
        // d = { say: function(){ typeof say } } // undefined

        if (name) {
          currentScope.data[name] = func;
        } // init arguments var


        currentScope.data["arguments"] = arguments;
        paramsGetter.forEach(function (getter, i) {
          currentScope.data[getter()] = args[i];
        }); // init this

        var prevContext = self.getCurrentContext(); //for ThisExpression

        self.setCurrentContext(this);
        var result = bodyClosure(); //reset

        self.setCurrentContext(prevContext);
        self.setCurrentScope(prevScope);
        self.callStack.pop();

        if (result instanceof Return) {
          return result.value;
        }
      };

      defineFunctionName(func, name);
      Object.defineProperty(func, "length", {
        value: paramLength,
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(func, "toString", {
        value: function value() {
          return source.slice(node.start, node.end);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });
      Object.defineProperty(func, "valueOf", {
        value: function value() {
          return source.slice(node.start, node.end);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });
      return func;
    };
  } // new Ctrl()
  ;

  _proto2.newExpressionHandler = function newExpressionHandler(node) {
    var _this12 = this;

    var source = this.source;
    var expression = this.createClosure(node.callee);
    var args = node.arguments.map(function (arg) {
      return _this12.createClosure(arg);
    });
    return function () {
      var construct = expression();

      if (!isFunction(construct) || construct.__IS_EVAL_FUNC) {
        var callee = node.callee;
        var name = source.slice(callee.start, callee.end);
        throw _this12.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.IsNotConstructor, name, node);
      } // new Function(...)


      if (construct.__IS_FUNCTION_FUNC) {
        return construct.apply(void 0, [new InternalInterpreterReflection(_this12)].concat(args.map(function (arg) {
          return arg();
        })));
      }

      return _construct(construct, args.map(function (arg) {
        return arg();
      }));
    };
  } // a.b a['b']
  ;

  _proto2.memberExpressionHandler = function memberExpressionHandler(node) {
    var objectGetter = this.createClosure(node.object);
    var keyGetter = this.createMemberKeyGetter(node);
    return function () {
      var obj = objectGetter();
      var key = keyGetter();
      return obj[key];
    };
  } //this
  ;

  _proto2.thisExpressionHandler = function thisExpressionHandler(node) {
    var _this13 = this;

    return function () {
      return _this13.getCurrentContext();
    };
  } // var1,var2,...
  ;

  _proto2.sequenceExpressionHandler = function sequenceExpressionHandler(node) {
    var _this14 = this;

    var expressions = node.expressions.map(function (item) {
      return _this14.createClosure(item);
    });
    return function () {
      var result;
      var len = expressions.length;

      for (var i = 0; i < len; i++) {
        var expression = expressions[i];
        result = expression();
      }

      return result;
    };
  } // 1 'name'
  ;

  _proto2.literalHandler = function literalHandler(node) {
    return function () {
      if (node.regex) {
        return new RegExp(node.regex.pattern, node.regex.flags);
      }

      return node.value;
    };
  } // var1 ...
  ;

  _proto2.identifierHandler = function identifierHandler(node) {
    var _this15 = this;

    return function () {
      var currentScope = _this15.getCurrentScope();

      var data = _this15.getScopeDataFromName(node.name, currentScope);

      _this15.assertVariable(data, node.name, node);

      return data[node.name];
    };
  };

  _proto2.getIdentifierScope = function getIdentifierScope(node) {
    var currentScope = this.getCurrentScope();
    var scope = this.getScopeFromName(node.name, currentScope);
    return scope;
  } // a=1 a+=2
  ;

  _proto2.assignmentExpressionHandler = function assignmentExpressionHandler(node) {
    var _this16 = this;

    // var s = function(){}
    // s.name === s
    if (node.left.type === "Identifier" && node.right.type === "FunctionExpression" && !node.right.id) {
      node.right.id = {
        type: "Identifier",
        name: node.left.name
      };
    }

    var dataGetter = this.createObjectGetter(node.left);
    var nameGetter = this.createNameGetter(node.left);
    var rightValueGetter = this.createClosure(node.right);
    return function () {
      var data = dataGetter();
      var name = nameGetter();
      var rightValue = rightValueGetter();

      if (node.operator !== "=") {
        // if a is undefined
        // a += 1
        _this16.assertVariable(data, name, node);
      }

      switch (node.operator) {
        case "=":
          return data[name] = rightValue;

        case "+=":
          return data[name] += rightValue;

        case "-=":
          return data[name] -= rightValue;

        case "*=":
          return data[name] *= rightValue;

        case "**=":
          return data[name] = Math.pow(data[name], rightValue);

        case "/=":
          return data[name] /= rightValue;

        case "%=":
          return data[name] %= rightValue;

        case "<<=":
          return data[name] <<= rightValue;

        case ">>=":
          return data[name] >>= rightValue;

        case ">>>=":
          return data[name] >>>= rightValue;

        case "&=":
          return data[name] &= rightValue;

        case "^=":
          return data[name] ^= rightValue;

        case "|=":
          return data[name] |= rightValue;

        default:
          throw _this16.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.AssignmentExpressionSyntaxError, node.type, node);
      }
    };
  } // function test(){}
  ;

  _proto2.functionDeclarationHandler = function functionDeclarationHandler(node) {
    if (node.id) {
      var functionClosure = this.functionExpressionHandler(node);
      Object.defineProperty(functionClosure, "isFunctionDeclareClosure", {
        value: true,
        writable: false,
        configurable: false,
        enumerable: false
      });
      this.funcDeclaration(node.id.name, functionClosure);
    }

    return function () {
      return EmptyStatementReturn;
    };
  };

  _proto2.getVariableName = function getVariableName(node) {
    if (node.type === "Identifier") {
      return node.name;
    } else {
      throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.VariableTypeSyntaxError, node.type, node);
    }
  } // var i;
  // var i=1;
  ;

  _proto2.variableDeclarationHandler = function variableDeclarationHandler(node) {
    var _this17 = this;

    var assignmentsClosure;
    var assignments = [];

    for (var i = 0; i < node.declarations.length; i++) {
      var decl = node.declarations[i];
      this.varDeclaration(this.getVariableName(decl.id));

      if (decl.init) {
        assignments.push({
          type: "AssignmentExpression",
          operator: "=",
          left: decl.id,
          right: decl.init
        });
      }
    }

    if (assignments.length) {
      assignmentsClosure = this.createClosure({
        type: "BlockStatement",
        body: assignments
      });
    }

    return function () {
      if (assignmentsClosure) {
        var oldValue = _this17.isVarDeclMode;
        _this17.isVarDeclMode = true;
        assignmentsClosure();
        _this17.isVarDeclMode = oldValue;
      }

      return EmptyStatementReturn;
    };
  };

  _proto2.assertVariable = function assertVariable(data, name, node) {
    if (data === this.globalScope.data && !(name in data)) {
      throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.VariableUndefinedReferenceError, name, node);
    }
  } // {...}
  ;

  _proto2.programHandler = function programHandler(node) {
    var _this18 = this;

    // const currentScope = this.getCurrentScope();
    var stmtClosures = node.body.map(function (stmt) {
      // if (stmt.type === "EmptyStatement") return null;
      return _this18.createClosure(stmt);
    });
    return function () {
      var result = EmptyStatementReturn;

      for (var i = 0; i < stmtClosures.length; i++) {
        var stmtClosure = stmtClosures[i]; // save last value

        var ret = _this18.setValue(stmtClosure()); // if (!stmtClosure) continue;
        // EmptyStatement


        if (ret === EmptyStatementReturn) continue;
        result = ret; // BlockStatement: break label;  continue label; for(){ break ... }
        // ReturnStatement: return xx;

        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel || result === Break || result === Continue) {
          break;
        }
      } // save last value


      return result;
    };
  } // all expression: a+1 a&&b a() a.b ...
  ;

  _proto2.expressionStatementHandler = function expressionStatementHandler(node) {
    return this.createClosure(node.expression);
  };

  _proto2.emptyStatementHandler = function emptyStatementHandler(node) {
    return function () {
      return EmptyStatementReturn;
    };
  } // return xx;
  ;

  _proto2.returnStatementHandler = function returnStatementHandler(node) {
    var argumentClosure = node.argument ? this.createClosure(node.argument) : noop;
    return function () {
      return new Return(argumentClosure());
    };
  } // if else
  ;

  _proto2.ifStatementHandler = function ifStatementHandler(node) {
    var testClosure = this.createClosure(node.test);
    var consequentClosure = this.createClosure(node.consequent);
    var alternateClosure = node.alternate ? this.createClosure(node.alternate) :
    /*!important*/
    function () {
      return EmptyStatementReturn;
    };
    return function () {
      return testClosure() ? consequentClosure() : alternateClosure();
    };
  } // test() ? true : false
  ;

  _proto2.conditionalExpressionHandler = function conditionalExpressionHandler(node) {
    return this.ifStatementHandler(node);
  } // for(var i = 0; i < 10; i++) {...}
  ;

  _proto2.forStatementHandler = function forStatementHandler(node) {
    var _this19 = this;

    var initClosure = noop;
    var testClosure = node.test ? this.createClosure(node.test) : function () {
      return true;
    };
    var updateClosure = noop;
    var bodyClosure = this.createClosure(node.body);

    if (node.type === "ForStatement") {
      initClosure = node.init ? this.createClosure(node.init) : initClosure;
      updateClosure = node.update ? this.createClosure(node.update) : noop;
    }

    return function (pNode) {
      var labelName;
      var result = EmptyStatementReturn;
      var shouldInitExec = node.type === "DoWhileStatement";

      if (pNode && pNode.type === "LabeledStatement") {
        labelName = pNode.label.name;
      }

      for (initClosure(); shouldInitExec || testClosure(); updateClosure()) {
        shouldInitExec = false; // save last value

        var ret = _this19.setValue(bodyClosure()); // notice: never return Break or Continue!


        if (ret === EmptyStatementReturn || ret === Continue) continue;

        if (ret === Break) {
          break;
        }

        result = ret; // stop continue label

        if (result instanceof ContinueLabel && result.value === labelName) {
          result = EmptyStatementReturn;
          continue;
        }

        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel) {
          break;
        }
      }

      return result;
    };
  } // while(1) {...}
  ;

  _proto2.whileStatementHandler = function whileStatementHandler(node) {
    return this.forStatementHandler(node);
  };

  _proto2.doWhileStatementHandler = function doWhileStatementHandler(node) {
    return this.forStatementHandler(node);
  };

  _proto2.forInStatementHandler = function forInStatementHandler(node) {
    var _this20 = this;

    // for( k in obj) or for(o.k in obj) ...
    var left = node.left;
    var rightClosure = this.createClosure(node.right);
    var bodyClosure = this.createClosure(node.body); // for(var k in obj) {...}

    if (node.left.type === "VariableDeclaration") {
      // init var k
      this.createClosure(node.left)(); // reset left
      // for( k in obj)

      left = node.left.declarations[0].id;
    }

    return function (pNode) {
      var labelName;
      var result = EmptyStatementReturn;
      var x;

      if (pNode && pNode.type === "LabeledStatement") {
        labelName = pNode.label.name;
      }

      var data = rightClosure();

      for (x in data) {
        // assign left to scope
        // k = x
        // o.k = x
        _this20.assignmentExpressionHandler({
          type: "AssignmentExpression",
          operator: "=",
          left: left,
          right: {
            type: "Literal",
            value: x
          }
        })(); // save last value


        var ret = _this20.setValue(bodyClosure()); // notice: never return Break or Continue!


        if (ret === EmptyStatementReturn || ret === Continue) continue;

        if (ret === Break) {
          break;
        }

        result = ret; // stop continue label

        if (result instanceof ContinueLabel && result.value === labelName) {
          result = EmptyStatementReturn;
          continue;
        }

        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel) {
          break;
        }
      }

      return result;
    };
  };

  _proto2.withStatementHandler = function withStatementHandler(node) {
    var _this21 = this;

    var objectClosure = this.createClosure(node.object);
    var bodyClosure = this.createClosure(node.body);
    return function () {
      var data = objectClosure();

      var currentScope = _this21.getCurrentScope();

      var newScope = new Scope(data, currentScope, WithScopeName); // const data = objectClosure();
      // copy all properties
      // for (let k in data) {
      // 	newScope.data[k] = data[k];
      // }

      _this21.setCurrentScope(newScope); // save last value


      var result = _this21.setValue(bodyClosure());

      _this21.setCurrentScope(currentScope);

      return result;
    };
  };

  _proto2.throwStatementHandler = function throwStatementHandler(node) {
    var _this22 = this;

    var argumentClosure = this.createClosure(node.argument);
    return function () {
      _this22.setValue(undefined);

      throw argumentClosure();
    };
  } // try{...}catch(e){...}finally{}
  ;

  _proto2.tryStatementHandler = function tryStatementHandler(node) {
    var _this23 = this;

    var blockClosure = this.createClosure(node.block);
    var handlerClosure = node.handler ? this.catchClauseHandler(node.handler) : null;
    var finalizerClosure = node.finalizer ? this.createClosure(node.finalizer) : null;
    return function () {
      var currentScope = _this23.getCurrentScope();

      var currentContext = _this23.getCurrentContext();

      var labelStack = currentScope.labelStack.concat([]);

      var callStack = _this23.callStack.concat([]);

      var result = EmptyStatementReturn;
      var finalReturn;
      var throwError;

      var reset = function reset() {
        _this23.setCurrentScope(currentScope); //reset scope


        _this23.setCurrentContext(currentContext); //reset context


        currentScope.labelStack = labelStack; //reset label stack

        _this23.callStack = callStack; //reset call stack
      };
      /**
       * try{...}catch(e){...}finally{...} execution sequence:
       * try stmt
       * try throw
       * catch stmt (if)
       * finally stmt
       *
       * finally throw or finally return
       * catch throw or catch return
       * try return
       */


      try {
        result = _this23.setValue(blockClosure());

        if (result instanceof Return) {
          finalReturn = result;
        }
      } catch (err) {
        reset();

        if (_this23.isInterruptThrow(err)) {
          throw err;
        }

        if (handlerClosure) {
          try {
            result = _this23.setValue(handlerClosure(err));

            if (result instanceof Return) {
              finalReturn = result;
            }
          } catch (err) {
            reset();

            if (_this23.isInterruptThrow(err)) {
              throw err;
            } // save catch throw error


            throwError = err;
          }
        }
      } // finally {


      if (finalizerClosure) {
        try {
          //do not save finally result
          result = finalizerClosure();

          if (result instanceof Return) {
            finalReturn = result;
          } // finalReturn = finalizerClosure();

        } catch (err) {
          reset();

          if (_this23.isInterruptThrow(err)) {
            throw err;
          } // save finally throw error


          throwError = err;
        } // if (finalReturn instanceof Return) {
        // 	result = finalReturn;
        // }

      } // }


      if (throwError) throw throwError;

      if (finalReturn) {
        return finalReturn;
      }

      return result;
    };
  } // ... catch(e){...}
  ;

  _proto2.catchClauseHandler = function catchClauseHandler(node) {
    var _this24 = this;

    var paramNameGetter = this.createParamNameGetter(node.param);
    var bodyClosure = this.createClosure(node.body);
    return function (e) {
      var result;

      var currentScope = _this24.getCurrentScope();

      var scopeData = currentScope.data; // get param name "e"

      var paramName = paramNameGetter();
      var isInScope = hasOwnProperty.call(scopeData, paramName); //paramName in scopeData;
      // save "e"

      var oldValue = scopeData[paramName]; // add "e" to scope

      scopeData[paramName] = e; // run

      result = bodyClosure(); // reset "e"

      if (isInScope) {
        scopeData[paramName] = oldValue;
      } else {
        //unset
        delete scopeData[paramName];
      }

      return result;
    };
  };

  _proto2.continueStatementHandler = function continueStatementHandler(node) {
    return function () {
      return node.label ? new ContinueLabel(node.label.name) : Continue;
    };
  };

  _proto2.breakStatementHandler = function breakStatementHandler(node) {
    return function () {
      return node.label ? new BreakLabel(node.label.name) : Break;
    };
  };

  _proto2.switchStatementHandler = function switchStatementHandler(node) {
    var _this25 = this;

    var discriminantClosure = this.createClosure(node.discriminant);
    var caseClosures = node.cases.map(function (item) {
      return _this25.switchCaseHandler(item);
    });
    return function () {
      var value = discriminantClosure();
      var match = false;
      var result;
      var ret, defaultCase;

      for (var i = 0; i < caseClosures.length; i++) {
        var item = caseClosures[i]();
        var test = item.testClosure();

        if (test === DefaultCase) {
          defaultCase = item;
          continue;
        }

        if (match || test === value) {
          match = true;
          ret = _this25.setValue(item.bodyClosure()); // notice: never return Break!

          if (ret === EmptyStatementReturn) continue;

          if (ret === Break) {
            break;
          }

          result = ret;

          if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel || result === Continue) {
            break;
          }
        }
      }

      if (!match && defaultCase) {
        ret = _this25.setValue(defaultCase.bodyClosure());
        var isEBC = ret === EmptyStatementReturn || ret === Break || ret === Continue; // notice: never return Break or Continue!

        if (!isEBC) {
          result = ret;
        }
      }

      return result;
    };
  };

  _proto2.switchCaseHandler = function switchCaseHandler(node) {
    var testClosure = node.test ? this.createClosure(node.test) : function () {
      return DefaultCase;
    };
    var bodyClosure = this.createClosure({
      type: "BlockStatement",
      body: node.consequent
    });
    return function () {
      return {
        testClosure: testClosure,
        bodyClosure: bodyClosure
      };
    };
  } // label: xxx
  ;

  _proto2.labeledStatementHandler = function labeledStatementHandler(node) {
    var _this26 = this;

    var labelName = node.label.name;
    var bodyClosure = this.createClosure(node.body);
    return function () {
      var result;

      var currentScope = _this26.getCurrentScope();

      currentScope.labelStack.push(labelName);
      result = bodyClosure(node); // stop break label

      if (result instanceof BreakLabel && result.value === labelName) {
        result = EmptyStatementReturn;
      }

      currentScope.labelStack.pop();
      return result;
    };
  };

  _proto2.debuggerStatementHandler = function debuggerStatementHandler(node) {
    return function () {
      debugger;
      return EmptyStatementReturn;
    };
  } // get es3/5 param name
  ;

  _proto2.createParamNameGetter = function createParamNameGetter(node) {
    if (node.type === "Identifier") {
      return function () {
        return node.name;
      };
    } else {
      throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.ParamTypeSyntaxError, node.type, node);
    }
  };

  _proto2.createObjectKeyGetter = function createObjectKeyGetter(node) {
    var getter; // var obj = { title: "" }

    if (node.type === "Identifier") {
      getter = function getter() {
        return node.name;
      };
    } else {
      // Literal or ...
      // var obj = { "title": "" } or others...
      getter = this.createClosure(node);
    }

    return function () {
      return getter();
    };
  };

  _proto2.createMemberKeyGetter = function createMemberKeyGetter(node) {
    // s['a'];  node.computed = true
    // s.foo;  node.computed = false
    return node.computed ? this.createClosure(node.property) : this.createObjectKeyGetter(node.property);
  } // for UnaryExpression UpdateExpression AssignmentExpression
  ;

  _proto2.createObjectGetter = function createObjectGetter(node) {
    var _this27 = this;

    switch (node.type) {
      case "Identifier":
        return function () {
          return _this27.getScopeDataFromName(node.name, _this27.getCurrentScope());
        };

      case "MemberExpression":
        return this.createClosure(node.object);

      default:
        throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.AssignmentTypeSyntaxError, node.type, node);
    }
  } // for UnaryExpression UpdateExpression AssignmentExpression
  ;

  _proto2.createNameGetter = function createNameGetter(node) {
    switch (node.type) {
      case "Identifier":
        return function () {
          return node.name;
        };

      case "MemberExpression":
        return this.createMemberKeyGetter(node);

      default:
        throw this.createInternalThrowError(_messages__WEBPACK_IMPORTED_MODULE_1__.Messages.AssignmentTypeSyntaxError, node.type, node);
    }
  };

  _proto2.varDeclaration = function varDeclaration(name) {
    var context = this.collectDeclVars;
    context[name] = undefined;
  };

  _proto2.funcDeclaration = function funcDeclaration(name, func) {
    var context = this.collectDeclFuncs;
    context[name] = func;
  };

  _proto2.addDeclarationsToScope = function addDeclarationsToScope(declVars, declFuncs, scope) {
    var scopeData = scope.data;

    for (var key in declFuncs) {
      var value = declFuncs[key];
      scopeData[key] = value ? value() : value;
    }

    for (var _key5 in declVars) {
      if (!(_key5 in scopeData)) {
        scopeData[_key5] = void 0;
      }
    }
  };

  _proto2.getScopeValue = function getScopeValue(name, startScope) {
    var scope = this.getScopeFromName(name, startScope);
    return scope.data[name];
  };

  _proto2.getScopeDataFromName = function getScopeDataFromName(name, startScope) {
    return this.getScopeFromName(name, startScope).data;
  };

  _proto2.getScopeFromName = function getScopeFromName(name, startScope) {
    var scope = startScope;

    do {
      if (name in scope.data) {
        //if (hasOwnProperty.call(scope.data, name)) {
        return scope;
      }
    } while (scope = scope.parent);

    return this.globalScope;
  };

  _proto2.setValue = function setValue(value) {
    var isFunctionCall = this.callStack.length;

    if (this.isVarDeclMode || isFunctionCall || value === EmptyStatementReturn || value === Break || value === Continue || value instanceof BreakLabel || value instanceof ContinueLabel) {
      return value;
    }

    this.value = value instanceof Return ? value.value : value;
    return value;
  };

  _proto2.getValue = function getValue() {
    return this.value;
  };

  return Interpreter;
}();
Interpreter.version = version;
Interpreter.eval = internalEval;
Interpreter.Function = internalFunction;
Interpreter.ecmaVersion = 5; // alert.call(globalContextInFunction, 1);
// fix: alert.call({}, 1); // Illegal invocation
// function func(){
//     this;// Interpreter.globalContextInFunction
// }
// func()

Interpreter.globalContextInFunction = void 0;
Interpreter.global = Object.create(null);

/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/interpreter/messages.js":
/*!***************************************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/interpreter/messages.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrowError": function() { return /* binding */ ThrowError; },
/* harmony export */   "ThrowSyntaxError": function() { return /* binding */ ThrowSyntaxError; },
/* harmony export */   "ThrowReferenceError": function() { return /* binding */ ThrowReferenceError; },
/* harmony export */   "ThrowTypeError": function() { return /* binding */ ThrowTypeError; },
/* harmony export */   "InterruptThrowError": function() { return /* binding */ InterruptThrowError; },
/* harmony export */   "InterruptThrowSyntaxError": function() { return /* binding */ InterruptThrowSyntaxError; },
/* harmony export */   "InterruptThrowReferenceError": function() { return /* binding */ InterruptThrowReferenceError; },
/* harmony export */   "Messages": function() { return /* binding */ Messages; }
/* harmony export */ });
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ThrowError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(ThrowError, _Error);

  function ThrowError() {
    return _Error.apply(this, arguments) || this;
  }

  return ThrowError;
}(_wrapNativeSuper(Error));
var ThrowSyntaxError =
/*#__PURE__*/
function (_SyntaxError) {
  _inheritsLoose(ThrowSyntaxError, _SyntaxError);

  function ThrowSyntaxError() {
    return _SyntaxError.apply(this, arguments) || this;
  }

  return ThrowSyntaxError;
}(_wrapNativeSuper(SyntaxError));
var ThrowReferenceError =
/*#__PURE__*/
function (_ReferenceError) {
  _inheritsLoose(ThrowReferenceError, _ReferenceError);

  function ThrowReferenceError() {
    return _ReferenceError.apply(this, arguments) || this;
  }

  return ThrowReferenceError;
}(_wrapNativeSuper(ReferenceError));
var ThrowTypeError =
/*#__PURE__*/
function (_TypeError) {
  _inheritsLoose(ThrowTypeError, _TypeError);

  function ThrowTypeError() {
    return _TypeError.apply(this, arguments) || this;
  }

  return ThrowTypeError;
}(_wrapNativeSuper(TypeError));
var InterruptThrowError =
/*#__PURE__*/
function (_ThrowError) {
  _inheritsLoose(InterruptThrowError, _ThrowError);

  function InterruptThrowError() {
    return _ThrowError.apply(this, arguments) || this;
  }

  return InterruptThrowError;
}(ThrowError);
var InterruptThrowSyntaxError =
/*#__PURE__*/
function (_ThrowSyntaxError) {
  _inheritsLoose(InterruptThrowSyntaxError, _ThrowSyntaxError);

  function InterruptThrowSyntaxError() {
    return _ThrowSyntaxError.apply(this, arguments) || this;
  }

  return InterruptThrowSyntaxError;
}(ThrowSyntaxError);
var InterruptThrowReferenceError =
/*#__PURE__*/
function (_ThrowReferenceError) {
  _inheritsLoose(InterruptThrowReferenceError, _ThrowReferenceError);

  function InterruptThrowReferenceError() {
    return _ThrowReferenceError.apply(this, arguments) || this;
  }

  return InterruptThrowReferenceError;
}(ThrowReferenceError);
var Messages = {
  UnknownError: [3001, "%0", InterruptThrowError],
  ExecutionTimeOutError: [3002, "Script execution timed out after %0ms", InterruptThrowError],
  NodeTypeSyntaxError: [1001, "Unknown node type: %0", InterruptThrowReferenceError],
  BinaryOperatorSyntaxError: [1002, "Unknown binary operator: %0", InterruptThrowReferenceError],
  LogicalOperatorSyntaxError: [1003, "Unknown logical operator: %0", InterruptThrowReferenceError],
  UnaryOperatorSyntaxError: [1004, "Unknown unary operator: %0", InterruptThrowReferenceError],
  UpdateOperatorSyntaxError: [1005, "Unknown update operator: %0", InterruptThrowReferenceError],
  ObjectStructureSyntaxError: [1006, "Unknown object structure: %0", InterruptThrowReferenceError],
  AssignmentExpressionSyntaxError: [1007, "Unknown assignment expression: %0", InterruptThrowReferenceError],
  VariableTypeSyntaxError: [1008, "Unknown variable type: %0", InterruptThrowReferenceError],
  ParamTypeSyntaxError: [1009, "Unknown param type: %0", InterruptThrowReferenceError],
  AssignmentTypeSyntaxError: [1010, "Unknown assignment type: %0", InterruptThrowReferenceError],
  FunctionUndefinedReferenceError: [2001, "%0 is not a function", ThrowReferenceError],
  VariableUndefinedReferenceError: [2002, "%0 is not defined", ThrowReferenceError],
  IsNotConstructor: [2003, "%0 is not a constructor", ThrowTypeError]
};

/***/ }),

/***/ "./node_modules/l7eval5/dist/esm/vm.js":
/*!*********************************************!*\
  !*** ./node_modules/l7eval5/dist/esm/vm.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createContext": function() { return /* binding */ createContext; },
/* harmony export */   "compileFunction": function() { return /* binding */ compileFunction; },
/* harmony export */   "runInContext": function() { return /* binding */ _runInContext; },
/* harmony export */   "runInNewContext": function() { return /* binding */ runInNewContext; },
/* harmony export */   "Script": function() { return /* binding */ Script; }
/* harmony export */ });
/* harmony import */ var _interpreter_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interpreter/main */ "./node_modules/l7eval5/dist/esm/interpreter/main.js");
 // TODO:
// add tests

function createContext(ctx) {
  if (ctx === void 0) {
    ctx = Object.create(null);
  }

  return ctx;
}
function compileFunction(code, params, options) {
  if (params === void 0) {
    params = [];
  }

  if (options === void 0) {
    options = {};
  }

  var ctx = options.parsingContext;
  var timeout = options.timeout === undefined ? 0 : options.timeout;
  var wrapCode = "\n    (function anonymous(" + params.join(",") + "){\n         " + code + "\n    });\n    ";
  var interpreter = new _interpreter_main__WEBPACK_IMPORTED_MODULE_0__.Interpreter(ctx, {
    ecmaVersion: options.ecmaVersion,
    timeout: timeout,
    rootContext: options.rootContext,
    globalContextInFunction: options.globalContextInFunction
  });
  return interpreter.evaluate(wrapCode);
}

function _runInContext(code, ctx, options) {
  var interpreter = new _interpreter_main__WEBPACK_IMPORTED_MODULE_0__.Interpreter(ctx, options);
  return interpreter.evaluate(code);
}


var runInNewContext = _runInContext;
var Script =
/*#__PURE__*/
function () {
  function Script(code) {
    this._code = code;
  }

  var _proto = Script.prototype;

  _proto.runInContext = function runInContext(ctx) {
    return _runInContext(this._code, ctx);
  };

  _proto.runInNewContext = function runInNewContext(ctx) {
    return _runInContext(this._code, ctx);
  };

  return Script;
}();

/***/ }),

/***/ "./node_modules/l7regl/dist/regl.js":
/*!******************************************!*\
  !*** ./node_modules/l7regl/dist/regl.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory(__webpack_require__(/*! l7eval5 */ "./node_modules/l7eval5/dist/esm/index.js")) :
	0;
}(this, (function (l7eval5) { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map(function (y, i) { return unbox(y, path + '[' + i + ']') }))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
/* globals performance */
var clock = isMiniAli ? 
(function () { return +(new Date()) } ) : 
(
  (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) }
);

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0,
    width: '100%',
    height: '100%'
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = canvas.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM environments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      // ext = extensions[name] = gl.getExtension(name)
      // 
      ext = extensions[name] = getExtension(name_)
    } catch (e) {}
    return !!ext
  }

  // 
  function getExtension(name) {
    if(!!gl.getExtension(name)) {
      return gl.getExtension(name)
    } else if(!!gl.getExtension(name.toLowerCase())) {
      return gl.getExtension(name.toLowerCase())
    } else {
      return null
    }
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

//  canvas
function isAliMiniCanvas(object) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  if(isMiniAli && object && object.getContext) {
    return true
  } else {
    return false
  }
}

//  image
function isAliMiniImage(object) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  if(isMiniAli && object && 'src' in object && 'crossOrigin' in object) {
    return true;
  } else {
    return false;
  }
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  // TOOD:  canvas/image 
  if(isAliMiniCanvas(object) || isAliMiniImage(object)) {
    return true
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS) || new Uint32Array(0))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isAliMiniCanvas(data) || isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isAliMiniCanvas(data) || isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if(isAliMiniImage(data)) {
      // TOOD:  image 
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])
      check$1.optional(function () {
        if (!limits.npotTextureCube) {
          check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
        }
      })

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              check$1.optional(function () {
                if (colorTexture) {
                  check$1.oneOf(
                    options.colorFormat, colorTextureFormats,
                    'invalid color format for texture')
                } else {
                  check$1.oneOf(
                    options.colorFormat, colorRenderbufferFormats,
                    'invalid color format for renderbuffer')
                }
              })
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var VAO_OPTIONS = [
  'attributes',
  'elements',
  'offset',
  'count',
  'primitive',
  'instances'
]

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState,
  elementState,
  drawState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          binding.buffer.bind()
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
      if (drawState.elements) {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer)
      } else {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null)
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    this.elements = null
    this.ownsElements = false
    this.count = 0
    this.offset = 0
    this.instances = -1
    this.primitive = 4
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
    var elements = elementState.getElements(this.elements)
    if (elements) {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer)
    } else {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = null
      ext.bindVertexArrayOES(null)
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (this.ownsElements) {
      this.elements.destroy()
      this.elements = null
      this.ownsElements = false
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (options) {
      var attributes
      if (Array.isArray(options)) {
        attributes = options
        if (vao.elements && vao.ownsElements) {
          vao.elements.destroy()
        }
        vao.elements = null
        vao.ownsElements = false
        vao.offset = 0
        vao.count = 0
        vao.instances = -1
        vao.primitive = 4
      } else {
        check$1(typeof options === 'object', 'invalid arguments for create vao')
        check$1('attributes' in options, 'must specify attributes for vao')
        if (options.elements) {
          var elements = options.elements
          if (vao.ownsElements) {
            if (typeof elements === 'function' && elements._reglType === 'elements') {
              vao.elements.destroy()
              vao.ownsElements = false
            } else {
              vao.elements(elements)
              vao.ownsElements = false
            }
          } else if (elementState.getElements(options.elements)) {
            vao.elements = options.elements
            vao.ownsElements = false
          } else {
            vao.elements = elementState.create(options.elements)
            vao.ownsElements = true
          }
        } else {
          vao.elements = null
          vao.ownsElements = false
        }
        attributes = options.attributes

        // set default vao
        vao.offset = 0
        vao.count = -1
        vao.instances = -1
        vao.primitive = 4

        // copy element properties
        if (vao.elements) {
          vao.count = vao.elements._elements.vertCount
          vao.primitive = vao.elements._elements.primType
        }

        if ('offset' in options) {
          vao.offset = options.offset | 0
        }
        if ('count' in options) {
          vao.count = options.count | 0
        }
        if ('instances' in options) {
          vao.instances = options.instances | 0
        }
        if ('primitive' in options) {
          check$1(options.primitive in primTypes, 'bad primitive type: ' + options.primitive)
          vao.primitive = primTypes[options.primitive]
        }

        // check.optional(() => {
        //   var keys = Object.keys(options)
        //   for (var i = 0; i < keys.length; ++i) {
        //     check(VAO_OPTIONS.indexOf(keys[i]) >= 0, 'invalid option for vao: "' + keys[i] + '" valid options are ' + VAO_OPTIONS)
        //   }
        // })
        //  ie11
        check$1.optional(function() {
          var keys = Object.keys(options)
          for (var i = 0; i < keys.length; ++i) {
            check$1(VAO_OPTIONS.indexOf(keys[i]) >= 0, 'invalid option for vao: "' + keys[i] + '" valid options are ' + VAO_OPTIONS)
          }
        })
        check$1(Array.isArray(attributes), 'attributes must be an array')
      }

      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0

      if (vao.ownsElements) {
        vao.elements.destroy()
        vao.elements = null
        vao.ownsElements = false
      }

      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      check$1.optional(function () {
        if (extensions.oes_texture_float) {
          check$1(
            type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
            'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

          if (type === GL_FLOAT$7) {
            check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
          }
        } else {
          check$1(
            type === GL_UNSIGNED_BYTE$7,
            'Reading from a framebuffer is only allowed for the type \'uint8\'')
        }
      })
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    // var proc = Function.apply(null, linkedNames.concat(src))
    var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
    var proc = isMiniAli?l7eval5.Function.apply(null, linkedNames.concat(src)):Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$2 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers
  var extVertexArrays = extensions.oes_vertex_array_object

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    // TODO: should use VAO to get default values for offset properties
    // should move vao parse into here and out of the old stuff

    var staticDraw = {}
    var vaoActive = false

    function parseVAO () {
      if (S_VAO in staticOptions) {
        var vao = staticOptions[S_VAO]
        if (vao !== null && attributeState.getVAO(vao) === null) {
          vao = attributeState.createVAO(vao)
        }

        vaoActive = true
        staticDraw.vao = vao

        return createStaticDecl(function (env) {
          var vaoRef = attributeState.getVAO(vao)
          if (vaoRef) {
            return env.link(vaoRef)
          } else {
            return 'null'
          }
        })
      } else if (S_VAO in dynamicOptions) {
        vaoActive = true
        var dyn = dynamicOptions[S_VAO]
        return createDynamicDecl(dyn, function (env, scope) {
          var vaoRef = env.invoke(scope, dyn)
          return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
        })
      }
      return null
    }

    var vao = parseVAO()

    var elementsActive = false

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        staticDraw.elements = elements
        if (isBufferArgs(elements)) {
          var e = staticDraw.elements = elementState.create(elements, true)
          elements = elementState.getElements(e)
          elementsActive = true
        } else if (elements) {
          elements = elementState.getElements(elements)
          elementsActive = true
          check$1.command(elements, 'invalid elements', env.commandStr)
        }

        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        elementsActive = true

        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.elements + '.getElements(' + env.shared.vao + '.currentVAO.elements):null')
          })
      }
      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        staticDraw.primitive = primitive
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.primitive:' + GL_TRIANGLES$1)
          })
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        if (isOffset) {
          staticDraw.offset = value
        } else {
          staticDraw.instances = value
        }
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset) {
        if (elementsActive) {
          return createStaticDecl(function (env, scope) {
            env.OFFSET = 0
            return 0
          })
        } else if (vaoActive) {
          return new Declaration(
            vao.thisDep,
            vao.contextDep,
            vao.propDep,
            function (env, scope) {
              return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.offset:0')
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.instances:-1')
          })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        staticDraw.count = count
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      } else if (vaoActive) {
        var countVariable = new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao, '.currentVAO?', env.shared.vao, '.currentVAO.count:-1')
          })
        return countVariable
      }
      return null
    }

    var primitive = parsePrimitive()
    var count = parseVertCount()
    var instances = parseParam(S_INSTANCES, false)

    return {
      elements: elements,
      primitive: primitive,
      count: count,
      instances: instances,
      offset: OFFSET,
      vao: vao,

      vaoActive: vaoActive,
      elementsActive: elementsActive,

      // static draw props
      static: staticDraw
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            check$1.optional(function () {
              if ('divisor' in value) {
                check$1.command(divisor === 0 || extInstancing,
                  'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
                check$1.command(divisor >= 0,
                  'invalid divisor for attribute "' + attribute + '"', env.commandStr)
              }

              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = draw.vao
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO &&
      shader.program &&
      !attribLocations &&
      extensions.angle_instanced_arrays &&
      draw.static.elements) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO({
          attributes: staticBindings,
          elements: draw.static.elements
        }))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
      if(isMiniAli) return 'Date.now()';
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter, isBatchInnerLoop) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      if (infix.charAt(0) === 'M') {
        scope(GL, '.uniform', infix, '(', LOCATION, ',')
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
        scope(');')
      } else if (unroll > 1) {
        var prev = []
        var cur = []
        for (var j = 0; j < unroll; ++j) {
          if (Array.isArray(VALUE)) {
            cur.push(VALUE[j])
          } else {
            cur.push(scope.def(VALUE + '[' + j + ']'))
          }
          if (isBatchInnerLoop) {
            prev.push(scope.def())
          }
        }
        if (isBatchInnerLoop) {
          scope('if(!', env.batchId, '||', prev.map(function (p, i) {
            return p + '!==' + cur[i]
          }).join('||'), '){', prev.map(function (p, i) {
            return p + '=' + cur[i] + ';'
          }).join(''))
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');')
        if (isBatchInnerLoop) {
          scope('}')
        }
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        if (isBatchInnerLoop) {
          var prevS = scope.def()
          scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){',
            prevS, '=', VALUE, ';')
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');')
        if (isBatchInnerLoop) {
          scope('}')
        }
      }
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
        if (drawOptions.elementsActive) {
          scope(
            'if(' + ELEMENTS + ')' +
            GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);')
        }
      } else {
        ELEMENTS = scope.def()
        scope(
          ELEMENTS, '=', DRAW_STATE, '.', S_ELEMENTS, ';',
          'if(', ELEMENTS, '){',
          GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER$2, ',', ELEMENTS, '.buffer.buffer);}',
          'else if(', shared.vao, '.currentVAO){',
          ELEMENTS, '=', env.shared.elements + '.getElements(' + shared.vao, '.currentVAO.elements);',
          (!extVertexArrays ? 'if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);' : ''),
          '}')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    }, false)
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
    if (env.shared.vao) {
      draw(env.shared.vao, '.setVAO(null);')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all, false)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }

    if (env.shared.vao) {
      batch(env.shared.vao, '.setVAO(null);')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState,
    elementState,
    drawState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  if (!isMiniAli && canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (!isMiniAli && canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    attributeState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));
//# sourceMappingURL=regl.js.map


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ (function(module) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isNumber.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/***/ (function(module) {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),

/***/ "./node_modules/lodash/mergeWith.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mergeWith.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

module.exports = mergeWith;


/***/ }),

/***/ "./node_modules/pbf/index.js":
/*!***********************************!*\
  !*** ./node_modules/pbf/index.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;

        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}


/***/ }),

/***/ "./node_modules/polygon-clipping/dist/polygon-clipping.umd.js":
/*!********************************************************************!*\
  !*** ./node_modules/polygon-clipping/dist/polygon-clipping.umd.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   */
  var Node =
  /** @class */
  function () {
    function Node(key, data) {
      this.next = null;
      this.key = key;
      this.data = data;
      this.left = null;
      this.right = null;
    }

    return Node;
  }();
  /* follows "An implementation of top-down splaying"
   * by D. Sleator <sleator@cs.cmu.edu> March 1992
   */


  function DEFAULT_COMPARE(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  /**
   * Simple top down splay, not requiring i to be in the tree t.
   */


  function splay(i, t, comparator) {
    var N = new Node(null, null);
    var l = N;
    var r = N;

    while (true) {
      var cmp = comparator(i, t.key); //if (i < t.key) {

      if (cmp < 0) {
        if (t.left === null) break; //if (i < t.left.key) {

        if (comparator(i, t.left.key) < 0) {
          var y = t.left;
          /* rotate right */

          t.left = y.right;
          y.right = t;
          t = y;
          if (t.left === null) break;
        }

        r.left = t;
        /* link right */

        r = t;
        t = t.left; //} else if (i > t.key) {
      } else if (cmp > 0) {
        if (t.right === null) break; //if (i > t.right.key) {

        if (comparator(i, t.right.key) > 0) {
          var y = t.right;
          /* rotate left */

          t.right = y.left;
          y.left = t;
          t = y;
          if (t.right === null) break;
        }

        l.right = t;
        /* link left */

        l = t;
        t = t.right;
      } else break;
    }
    /* assemble */


    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
  }

  function insert(i, data, t, comparator) {
    var node = new Node(i, data);

    if (t === null) {
      node.left = node.right = null;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);

    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp >= 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }

    return node;
  }

  function split(key, v, comparator) {
    var left = null;
    var right = null;

    if (v) {
      v = splay(key, v, comparator);
      var cmp = comparator(v.key, key);

      if (cmp === 0) {
        left = v.left;
        right = v.right;
      } else if (cmp < 0) {
        right = v.right;
        v.right = null;
        left = v;
      } else {
        left = v.left;
        v.left = null;
        right = v;
      }
    }

    return {
      left: left,
      right: right
    };
  }

  function merge(left, right, comparator) {
    if (right === null) return left;
    if (left === null) return right;
    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
  }
  /**
   * Prints level of the tree
   */


  function printRow(root, prefix, isTail, out, printNode) {
    if (root) {
      out("" + prefix + (isTail ? ' ' : ' ') + printNode(root) + "\n");
      var indent = prefix + (isTail ? '    ' : '   ');
      if (root.left) printRow(root.left, indent, false, out, printNode);
      if (root.right) printRow(root.right, indent, true, out, printNode);
    }
  }

  var Tree =
  /** @class */
  function () {
    function Tree(comparator) {
      if (comparator === void 0) {
        comparator = DEFAULT_COMPARE;
      }

      this._root = null;
      this._size = 0;
      this._comparator = comparator;
    }
    /**
     * Inserts a key, allows duplicates
     */


    Tree.prototype.insert = function (key, data) {
      this._size++;
      return this._root = insert(key, data, this._root, this._comparator);
    };
    /**
     * Adds a key, if it is not present in the tree
     */


    Tree.prototype.add = function (key, data) {
      var node = new Node(key, data);

      if (this._root === null) {
        node.left = node.right = null;
        this._size++;
        this._root = node;
      }

      var comparator = this._comparator;
      var t = splay(key, this._root, comparator);
      var cmp = comparator(key, t.key);
      if (cmp === 0) this._root = t;else {
        if (cmp < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp > 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }

        this._size++;
        this._root = node;
      }
      return this._root;
    };
    /**
     * @param  {Key} key
     * @return {Node|null}
     */


    Tree.prototype.remove = function (key) {
      this._root = this._remove(key, this._root, this._comparator);
    };
    /**
     * Deletes i from the tree if it's there
     */


    Tree.prototype._remove = function (i, t, comparator) {
      var x;
      if (t === null) return null;
      t = splay(i, t, comparator);
      var cmp = comparator(i, t.key);

      if (cmp === 0) {
        /* found it */
        if (t.left === null) {
          x = t.right;
        } else {
          x = splay(i, t.left, comparator);
          x.right = t.right;
        }

        this._size--;
        return x;
      }

      return t;
      /* It wasn't there */
    };
    /**
     * Removes and returns the node with smallest key
     */


    Tree.prototype.pop = function () {
      var node = this._root;

      if (node) {
        while (node.left) {
          node = node.left;
        }

        this._root = splay(node.key, this._root, this._comparator);
        this._root = this._remove(node.key, this._root, this._comparator);
        return {
          key: node.key,
          data: node.data
        };
      }

      return null;
    };
    /**
     * Find without splaying
     */


    Tree.prototype.findStatic = function (key) {
      var current = this._root;
      var compare = this._comparator;

      while (current) {
        var cmp = compare(key, current.key);
        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;
      }

      return null;
    };

    Tree.prototype.find = function (key) {
      if (this._root) {
        this._root = splay(key, this._root, this._comparator);
        if (this._comparator(key, this._root.key) !== 0) return null;
      }

      return this._root;
    };

    Tree.prototype.contains = function (key) {
      var current = this._root;
      var compare = this._comparator;

      while (current) {
        var cmp = compare(key, current.key);
        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;
      }

      return false;
    };

    Tree.prototype.forEach = function (visitor, ctx) {
      var current = this._root;
      var Q = [];
      /* Initialize stack s */

      var done = false;

      while (!done) {
        if (current !== null) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length !== 0) {
            current = Q.pop();
            visitor.call(ctx, current);
            current = current.right;
          } else done = true;
        }
      }

      return this;
    };
    /**
     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
     */


    Tree.prototype.range = function (low, high, fn, ctx) {
      var Q = [];
      var compare = this._comparator;
      var node = this._root;
      var cmp;

      while (Q.length !== 0 || node) {
        if (node) {
          Q.push(node);
          node = node.left;
        } else {
          node = Q.pop();
          cmp = compare(node.key, high);

          if (cmp > 0) {
            break;
          } else if (compare(node.key, low) >= 0) {
            if (fn.call(ctx, node)) return this; // stop if smth is returned
          }

          node = node.right;
        }
      }

      return this;
    };
    /**
     * Returns array of keys
     */


    Tree.prototype.keys = function () {
      var keys = [];
      this.forEach(function (_a) {
        var key = _a.key;
        return keys.push(key);
      });
      return keys;
    };
    /**
     * Returns array of all the data in the nodes
     */


    Tree.prototype.values = function () {
      var values = [];
      this.forEach(function (_a) {
        var data = _a.data;
        return values.push(data);
      });
      return values;
    };

    Tree.prototype.min = function () {
      if (this._root) return this.minNode(this._root).key;
      return null;
    };

    Tree.prototype.max = function () {
      if (this._root) return this.maxNode(this._root).key;
      return null;
    };

    Tree.prototype.minNode = function (t) {
      if (t === void 0) {
        t = this._root;
      }

      if (t) while (t.left) {
        t = t.left;
      }
      return t;
    };

    Tree.prototype.maxNode = function (t) {
      if (t === void 0) {
        t = this._root;
      }

      if (t) while (t.right) {
        t = t.right;
      }
      return t;
    };
    /**
     * Returns node at given index
     */


    Tree.prototype.at = function (index) {
      var current = this._root;
      var done = false;
      var i = 0;
      var Q = [];

      while (!done) {
        if (current) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length > 0) {
            current = Q.pop();
            if (i === index) return current;
            i++;
            current = current.right;
          } else done = true;
        }
      }

      return null;
    };

    Tree.prototype.next = function (d) {
      var root = this._root;
      var successor = null;

      if (d.right) {
        successor = d.right;

        while (successor.left) {
          successor = successor.left;
        }

        return successor;
      }

      var comparator = this._comparator;

      while (root) {
        var cmp = comparator(d.key, root.key);
        if (cmp === 0) break;else if (cmp < 0) {
          successor = root;
          root = root.left;
        } else root = root.right;
      }

      return successor;
    };

    Tree.prototype.prev = function (d) {
      var root = this._root;
      var predecessor = null;

      if (d.left !== null) {
        predecessor = d.left;

        while (predecessor.right) {
          predecessor = predecessor.right;
        }

        return predecessor;
      }

      var comparator = this._comparator;

      while (root) {
        var cmp = comparator(d.key, root.key);
        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {
          predecessor = root;
          root = root.right;
        }
      }

      return predecessor;
    };

    Tree.prototype.clear = function () {
      this._root = null;
      this._size = 0;
      return this;
    };

    Tree.prototype.toList = function () {
      return toList(this._root);
    };
    /**
     * Bulk-load items. Both array have to be same size
     */


    Tree.prototype.load = function (keys, values, presort) {
      if (values === void 0) {
        values = [];
      }

      if (presort === void 0) {
        presort = false;
      }

      var size = keys.length;
      var comparator = this._comparator; // sort if needed

      if (presort) sort(keys, values, 0, size - 1, comparator);

      if (this._root === null) {
        // empty tree
        this._root = loadRecursive(keys, values, 0, size);
        this._size = size;
      } else {
        // that re-builds the whole tree from two in-order traversals
        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
        size = this._size + size;
        this._root = sortedListToBST({
          head: mergedList
        }, 0, size);
      }

      return this;
    };

    Tree.prototype.isEmpty = function () {
      return this._root === null;
    };

    Object.defineProperty(Tree.prototype, "size", {
      get: function get() {
        return this._size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tree.prototype, "root", {
      get: function get() {
        return this._root;
      },
      enumerable: true,
      configurable: true
    });

    Tree.prototype.toString = function (printNode) {
      if (printNode === void 0) {
        printNode = function printNode(n) {
          return String(n.key);
        };
      }

      var out = [];
      printRow(this._root, '', true, function (v) {
        return out.push(v);
      }, printNode);
      return out.join('');
    };

    Tree.prototype.update = function (key, newKey, newData) {
      var comparator = this._comparator;

      var _a = split(key, this._root, comparator),
          left = _a.left,
          right = _a.right;

      if (comparator(key, newKey) < 0) {
        right = insert(newKey, newData, right, comparator);
      } else {
        left = insert(newKey, newData, left, comparator);
      }

      this._root = merge(left, right, comparator);
    };

    Tree.prototype.split = function (key) {
      return split(key, this._root, this._comparator);
    };

    return Tree;
  }();

  function loadRecursive(keys, values, start, end) {
    var size = end - start;

    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key = keys[middle];
      var data = values[middle];
      var node = new Node(key, data);
      node.left = loadRecursive(keys, values, start, middle);
      node.right = loadRecursive(keys, values, middle + 1, end);
      return node;
    }

    return null;
  }

  function createList(keys, values) {
    var head = new Node(null, null);
    var p = head;

    for (var i = 0; i < keys.length; i++) {
      p = p.next = new Node(keys[i], values[i]);
    }

    p.next = null;
    return head.next;
  }

  function toList(root) {
    var current = root;
    var Q = [];
    var done = false;
    var head = new Node(null, null);
    var p = head;

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = p = p.next = Q.pop();
          current = current.right;
        } else done = true;
      }
    }

    p.next = null; // that'll work even if the tree was empty

    return head.next;
  }

  function sortedListToBST(list, start, end) {
    var size = end - start;

    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var left = sortedListToBST(list, start, middle);
      var root = list.head;
      root.left = left;
      list.head = list.head.next;
      root.right = sortedListToBST(list, middle + 1, end);
      return root;
    }

    return null;
  }

  function mergeLists(l1, l2, compare) {
    var head = new Node(null, null); // dummy

    var p = head;
    var p1 = l1;
    var p2 = l2;

    while (p1 !== null && p2 !== null) {
      if (compare(p1.key, p2.key) < 0) {
        p.next = p1;
        p1 = p1.next;
      } else {
        p.next = p2;
        p2 = p2.next;
      }

      p = p.next;
    }

    if (p1 !== null) {
      p.next = p1;
    } else if (p2 !== null) {
      p.next = p2;
    }

    return head.next;
  }

  function sort(keys, values, left, right, compare) {
    if (left >= right) return;
    var pivot = keys[left + right >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do {
        i++;
      } while (compare(keys[i], pivot) < 0);

      do {
        j--;
      } while (compare(keys[j], pivot) > 0);

      if (i >= j) break;
      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;
      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values, left, j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  /**
   * A bounding box has the format:
   *
   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
   *
   */
  var isInBbox = function isInBbox(bbox, point) {
    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
  };
  /* Returns either null, or a bbox (aka an ordered pair of points)
   * If there is only one point of overlap, a bbox with identical points
   * will be returned */

  var getBboxOverlap = function getBboxOverlap(b1, b2) {
    // check if the bboxes overlap at all
    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values

    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values

    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap

    return {
      ll: {
        x: lowerX,
        y: lowerY
      },
      ur: {
        x: upperX,
        y: upperY
      }
    };
  };

  /* Javascript doesn't do integer math. Everything is
   * floating point with percision Number.EPSILON.
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
   */
  var epsilon = Number.EPSILON; // IE Polyfill

  if (epsilon === undefined) epsilon = Math.pow(2, -52);
  var EPSILON_SQ = epsilon * epsilon;
  /* FLP comparator */

  var cmp = function cmp(a, b) {
    // check if they're both 0
    if (-epsilon < a && a < epsilon) {
      if (-epsilon < b && b < epsilon) {
        return 0;
      }
    } // check if they're flp equal


    var ab = a - b;

    if (ab * ab < EPSILON_SQ * a * b) {
      return 0;
    } // normal comparison


    return a < b ? -1 : 1;
  };

  /**
   * This class rounds incoming values sufficiently so that
   * floating points problems are, for the most part, avoided.
   *
   * Incoming points are have their x & y values tested against
   * all previously seen x & y values. If either is 'too close'
   * to a previously seen value, it's value is 'snapped' to the
   * previously seen value.
   *
   * All points should be rounded by this class before being
   * stored in any data structures in the rest of this algorithm.
   */

  var PtRounder = /*#__PURE__*/function () {
    function PtRounder() {
      _classCallCheck(this, PtRounder);

      this.reset();
    }

    _createClass(PtRounder, [{
      key: "reset",
      value: function reset() {
        this.xRounder = new CoordRounder();
        this.yRounder = new CoordRounder();
      }
    }, {
      key: "round",
      value: function round(x, y) {
        return {
          x: this.xRounder.round(x),
          y: this.yRounder.round(y)
        };
      }
    }]);

    return PtRounder;
  }();

  var CoordRounder = /*#__PURE__*/function () {
    function CoordRounder() {
      _classCallCheck(this, CoordRounder);

      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON

      this.round(0);
    } // Note: this can rounds input values backwards or forwards.
    //       You might ask, why not restrict this to just rounding
    //       forwards? Wouldn't that allow left endpoints to always
    //       remain left endpoints during splitting (never change to
    //       right). No - it wouldn't, because we snap intersections
    //       to endpoints (to establish independence from the segment
    //       angle for t-intersections).


    _createClass(CoordRounder, [{
      key: "round",
      value: function round(coord) {
        var node = this.tree.add(coord);
        var prevNode = this.tree.prev(node);

        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
          this.tree.remove(coord);
          return prevNode.key;
        }

        var nextNode = this.tree.next(node);

        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
          this.tree.remove(coord);
          return nextNode.key;
        }

        return coord;
      }
    }]);

    return CoordRounder;
  }(); // singleton available by import


  var rounder = new PtRounder();

  /* Cross Product of two vectors with first point at origin */

  var crossProduct = function crossProduct(a, b) {
    return a.x * b.y - a.y * b.x;
  };
  /* Dot Product of two vectors with first point at origin */

  var dotProduct = function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y;
  };
  /* Comparator for two vectors with same starting point */

  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {
    var v1 = {
      x: endPt1.x - basePt.x,
      y: endPt1.y - basePt.y
    };
    var v2 = {
      x: endPt2.x - basePt.x,
      y: endPt2.y - basePt.y
    };
    var kross = crossProduct(v1, v2);
    return cmp(kross, 0);
  };
  var length = function length(v) {
    return Math.sqrt(dotProduct(v, v));
  };
  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */

  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {
    var vBase = {
      x: pBase.x - pShared.x,
      y: pBase.y - pShared.y
    };
    var vAngle = {
      x: pAngle.x - pShared.x,
      y: pAngle.y - pShared.y
    };
    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
  };
  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */

  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {
    var vBase = {
      x: pBase.x - pShared.x,
      y: pBase.y - pShared.y
    };
    var vAngle = {
      x: pAngle.x - pShared.x,
      y: pAngle.y - pShared.y
    };
    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
  };
  /* Get the x coordinate where the given line (defined by a point and vector)
   * crosses the horizontal line with the given y coordiante.
   * In the case of parrallel lines (including overlapping ones) returns null. */

  var horizontalIntersection = function horizontalIntersection(pt, v, y) {
    if (v.y === 0) return null;
    return {
      x: pt.x + v.x / v.y * (y - pt.y),
      y: y
    };
  };
  /* Get the y coordinate where the given line (defined by a point and vector)
   * crosses the vertical line with the given x coordiante.
   * In the case of parrallel lines (including overlapping ones) returns null. */

  var verticalIntersection = function verticalIntersection(pt, v, x) {
    if (v.x === 0) return null;
    return {
      x: x,
      y: pt.y + v.y / v.x * (x - pt.x)
    };
  };
  /* Get the intersection of two lines, each defined by a base point and a vector.
   * In the case of parrallel lines (including overlapping ones) returns null. */

  var intersection = function intersection(pt1, v1, pt2, v2) {
    // take some shortcuts for vertical and horizontal lines
    // this also ensures we don't calculate an intersection and then discover
    // it's actually outside the bounding box of the line
    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.
    // This algorithm is based on Schneider and Eberly.
    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

    var kross = crossProduct(v1, v2);
    if (kross == 0) return null;
    var ve = {
      x: pt2.x - pt1.x,
      y: pt2.y - pt1.y
    };
    var d1 = crossProduct(ve, v1) / kross;
    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error

    var x1 = pt1.x + d2 * v1.x,
        x2 = pt2.x + d1 * v2.x;
    var y1 = pt1.y + d2 * v1.y,
        y2 = pt2.y + d1 * v2.y;
    var x = (x1 + x2) / 2;
    var y = (y1 + y2) / 2;
    return {
      x: x,
      y: y
    };
  };

  var SweepEvent = /*#__PURE__*/function () {
    _createClass(SweepEvent, null, [{
      key: "compare",
      // for ordering sweep events in the sweep event queue
      value: function compare(a, b) {
        // favor event with a point that the sweep line hits first
        var ptCmp = SweepEvent.comparePoints(a.point, b.point);
        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed

        if (a.point !== b.point) a.link(b); // favor right events over left

        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints
        // ordering of this case is the same as for their segments

        return Segment.compare(a.segment, b.segment);
      } // for ordering points in sweep line order

    }, {
      key: "comparePoints",
      value: function comparePoints(aPt, bPt) {
        if (aPt.x < bPt.x) return -1;
        if (aPt.x > bPt.x) return 1;
        if (aPt.y < bPt.y) return -1;
        if (aPt.y > bPt.y) return 1;
        return 0;
      } // Warning: 'point' input will be modified and re-used (for performance)

    }]);

    function SweepEvent(point, isLeft) {
      _classCallCheck(this, SweepEvent);

      if (point.events === undefined) point.events = [this];else point.events.push(this);
      this.point = point;
      this.isLeft = isLeft; // this.segment, this.otherSE set by factory
    }

    _createClass(SweepEvent, [{
      key: "link",
      value: function link(other) {
        if (other.point === this.point) {
          throw new Error('Tried to link already linked events');
        }

        var otherEvents = other.point.events;

        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
          var evt = otherEvents[i];
          this.point.events.push(evt);
          evt.point = this.point;
        }

        this.checkForConsuming();
      }
      /* Do a pass over our linked events and check to see if any pair
       * of segments match, and should be consumed. */

    }, {
      key: "checkForConsuming",
      value: function checkForConsuming() {
        // FIXME: The loops in this method run O(n^2) => no good.
        //        Maintain little ordered sweep event trees?
        //        Can we maintaining an ordering that avoids the need
        //        for the re-sorting with getLeftmostComparator in geom-out?
        // Compare each pair of events to see if other events also match
        var numEvents = this.point.events.length;

        for (var i = 0; i < numEvents; i++) {
          var evt1 = this.point.events[i];
          if (evt1.segment.consumedBy !== undefined) continue;

          for (var j = i + 1; j < numEvents; j++) {
            var evt2 = this.point.events[j];
            if (evt2.consumedBy !== undefined) continue;
            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
            evt1.segment.consume(evt2.segment);
          }
        }
      }
    }, {
      key: "getAvailableLinkedEvents",
      value: function getAvailableLinkedEvents() {
        // point.events is always of length 2 or greater
        var events = [];

        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
          var evt = this.point.events[i];

          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
            events.push(evt);
          }
        }

        return events;
      }
      /**
       * Returns a comparator function for sorting linked events that will
       * favor the event that will give us the smallest left-side angle.
       * All ring construction starts as low as possible heading to the right,
       * so by always turning left as sharp as possible we'll get polygons
       * without uncessary loops & holes.
       *
       * The comparator function has a compute cache such that it avoids
       * re-computing already-computed values.
       */

    }, {
      key: "getLeftmostComparator",
      value: function getLeftmostComparator(baseEvent) {
        var _this = this;

        var cache = new Map();

        var fillCache = function fillCache(linkedEvent) {
          var nextEvent = linkedEvent.otherSE;
          cache.set(linkedEvent, {
            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
          });
        };

        return function (a, b) {
          if (!cache.has(a)) fillCache(a);
          if (!cache.has(b)) fillCache(b);

          var _cache$get = cache.get(a),
              asine = _cache$get.sine,
              acosine = _cache$get.cosine;

          var _cache$get2 = cache.get(b),
              bsine = _cache$get2.sine,
              bcosine = _cache$get2.cosine; // both on or above x-axis


          if (asine >= 0 && bsine >= 0) {
            if (acosine < bcosine) return 1;
            if (acosine > bcosine) return -1;
            return 0;
          } // both below x-axis


          if (asine < 0 && bsine < 0) {
            if (acosine < bcosine) return -1;
            if (acosine > bcosine) return 1;
            return 0;
          } // one above x-axis, one below


          if (bsine < asine) return -1;
          if (bsine > asine) return 1;
          return 0;
        };
      }
    }]);

    return SweepEvent;
  }();

  // segments and sweep events when all else is identical

  var segmentId = 0;

  var Segment = /*#__PURE__*/function () {
    _createClass(Segment, null, [{
      key: "compare",

      /* This compare() function is for ordering segments in the sweep
       * line tree, and does so according to the following criteria:
       *
       * Consider the vertical line that lies an infinestimal step to the
       * right of the right-more of the two left endpoints of the input
       * segments. Imagine slowly moving a point up from negative infinity
       * in the increasing y direction. Which of the two segments will that
       * point intersect first? That segment comes 'before' the other one.
       *
       * If neither segment would be intersected by such a line, (if one
       * or more of the segments are vertical) then the line to be considered
       * is directly on the right-more of the two left inputs.
       */
      value: function compare(a, b) {
        var alx = a.leftSE.point.x;
        var blx = b.leftSE.point.x;
        var arx = a.rightSE.point.x;
        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane

        if (brx < alx) return 1;
        if (arx < blx) return -1;
        var aly = a.leftSE.point.y;
        var bly = b.leftSE.point.y;
        var ary = a.rightSE.point.y;
        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?

        if (alx < blx) {
          // are the two segments in the same horizontal plane?
          if (bly < aly && bly < ary) return 1;
          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?

          var aCmpBLeft = a.comparePoint(b.leftSE.point);
          if (aCmpBLeft < 0) return 1;
          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?

          var bCmpARight = b.comparePoint(a.rightSE.point);
          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more
          // left endpoint to be first (arbitrary?)

          return -1;
        } // is left endpoint of segment A the right-more?


        if (alx > blx) {
          if (aly < bly && aly < bry) return -1;
          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?

          var bCmpALeft = b.comparePoint(a.leftSE.point);
          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?

          var aCmpBRight = a.comparePoint(b.rightSE.point);
          if (aCmpBRight < 0) return 1;
          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more
          // left endpoint to be first (arbitrary?)

          return 1;
        } // if we get here, the two left endpoints are in the same
        // vertical plane, ie alx === blx
        // consider the lower left-endpoint to come first


        if (aly < bly) return -1;
        if (aly > bly) return 1; // left endpoints are identical
        // check for colinearity by using the left-more right endpoint
        // is the A right endpoint more left-more?

        if (arx < brx) {
          var _bCmpARight = b.comparePoint(a.rightSE.point);

          if (_bCmpARight !== 0) return _bCmpARight;
        } // is the B right endpoint more left-more?


        if (arx > brx) {
          var _aCmpBRight = a.comparePoint(b.rightSE.point);

          if (_aCmpBRight < 0) return 1;
          if (_aCmpBRight > 0) return -1;
        }

        if (arx !== brx) {
          // are these two [almost] vertical segments with opposite orientation?
          // if so, the one with the lower right endpoint comes first
          var ay = ary - aly;
          var ax = arx - alx;
          var by = bry - bly;
          var bx = brx - blx;
          if (ay > ax && by < bx) return 1;
          if (ay < ax && by > bx) return -1;
        } // we have colinear segments with matching orientation
        // consider the one with more left-more right endpoint to be first


        if (arx > brx) return 1;
        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same
        // vertical plane, ie arx === brx
        // consider the lower right-endpoint to come first

        if (ary < bry) return -1;
        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential
        // fall back on creation order as consistent tie-breaker

        if (a.id < b.id) return -1;
        if (a.id > b.id) return 1; // identical segment, ie a === b

        return 0;
      }
      /* Warning: a reference to ringWindings input will be stored,
       *  and possibly will be later modified */

    }]);

    function Segment(leftSE, rightSE, rings, windings) {
      _classCallCheck(this, Segment);

      this.id = ++segmentId;
      this.leftSE = leftSE;
      leftSE.segment = this;
      leftSE.otherSE = rightSE;
      this.rightSE = rightSE;
      rightSE.segment = this;
      rightSE.otherSE = leftSE;
      this.rings = rings;
      this.windings = windings; // left unset for performance, set later in algorithm
      // this.ringOut, this.consumedBy, this.prev
    }

    _createClass(Segment, [{
      key: "replaceRightSE",

      /* When a segment is split, the rightSE is replaced with a new sweep event */
      value: function replaceRightSE(newRightSE) {
        this.rightSE = newRightSE;
        this.rightSE.segment = this;
        this.rightSE.otherSE = this.leftSE;
        this.leftSE.otherSE = this.rightSE;
      }
    }, {
      key: "bbox",
      value: function bbox() {
        var y1 = this.leftSE.point.y;
        var y2 = this.rightSE.point.y;
        return {
          ll: {
            x: this.leftSE.point.x,
            y: y1 < y2 ? y1 : y2
          },
          ur: {
            x: this.rightSE.point.x,
            y: y1 > y2 ? y1 : y2
          }
        };
      }
      /* A vector from the left point to the right */

    }, {
      key: "vector",
      value: function vector() {
        return {
          x: this.rightSE.point.x - this.leftSE.point.x,
          y: this.rightSE.point.y - this.leftSE.point.y
        };
      }
    }, {
      key: "isAnEndpoint",
      value: function isAnEndpoint(pt) {
        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
      }
      /* Compare this segment with a point.
       *
       * A point P is considered to be colinear to a segment if there
       * exists a distance D such that if we travel along the segment
       * from one * endpoint towards the other a distance D, we find
       * ourselves at point P.
       *
       * Return value indicates:
       *
       *   1: point lies above the segment (to the left of vertical)
       *   0: point is colinear to segment
       *  -1: point lies below the segment (to the right of vertical)
       */

    }, {
      key: "comparePoint",
      value: function comparePoint(point) {
        if (this.isAnEndpoint(point)) return 0;
        var lPt = this.leftSE.point;
        var rPt = this.rightSE.point;
        var v = this.vector(); // Exactly vertical segments.

        if (lPt.x === rPt.x) {
          if (point.x === lPt.x) return 0;
          return point.x < lPt.x ? 1 : -1;
        } // Nearly vertical segments with an intersection.
        // Check to see where a point on the line with matching Y coordinate is.


        var yDist = (point.y - lPt.y) / v.y;
        var xFromYDist = lPt.x + yDist * v.x;
        if (point.x === xFromYDist) return 0; // General case.
        // Check to see where a point on the line with matching X coordinate is.

        var xDist = (point.x - lPt.x) / v.x;
        var yFromXDist = lPt.y + xDist * v.y;
        if (point.y === yFromXDist) return 0;
        return point.y < yFromXDist ? -1 : 1;
      }
      /**
       * Given another segment, returns the first non-trivial intersection
       * between the two segments (in terms of sweep line ordering), if it exists.
       *
       * A 'non-trivial' intersection is one that will cause one or both of the
       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
       *
       *   * endpoint of segA with endpoint of segB --> trivial
       *   * endpoint of segA with point along segB --> non-trivial
       *   * endpoint of segB with point along segA --> non-trivial
       *   * point along segA with point along segB --> non-trivial
       *
       * If no non-trivial intersection exists, return null
       * Else, return null.
       */

    }, {
      key: "getIntersection",
      value: function getIntersection(other) {
        // If bboxes don't overlap, there can't be any intersections
        var tBbox = this.bbox();
        var oBbox = other.bbox();
        var bboxOverlap = getBboxOverlap(tBbox, oBbox);
        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.
        // This will 'snap' intersections to endpoints if possible, and will
        // handle cases of colinearity.

        var tlp = this.leftSE.point;
        var trp = this.rightSE.point;
        var olp = other.leftSE.point;
        var orp = other.rightSE.point; // does each endpoint touch the other segment?
        // note that we restrict the 'touching' definition to only allow segments
        // to touch endpoints that lie forward from where we are in the sweep line pass

        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?

        if (touchesThisLSE && touchesOtherLSE) {
          // these two cases are for colinear segments with matching left
          // endpoints, and one segment being longer than the other
          if (touchesThisRSE && !touchesOtherRSE) return trp;
          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)
          // or just on their left endpoint (one trivial intersection

          return null;
        } // does this left endpoint matches (other doesn't)


        if (touchesThisLSE) {
          // check for segments that just intersect on opposing endpoints
          if (touchesOtherRSE) {
            if (tlp.x === orp.x && tlp.y === orp.y) return null;
          } // t-intersection on left endpoint


          return tlp;
        } // does other left endpoint matches (this doesn't)


        if (touchesOtherLSE) {
          // check for segments that just intersect on opposing endpoints
          if (touchesThisRSE) {
            if (trp.x === olp.x && trp.y === olp.y) return null;
          } // t-intersection on left endpoint


          return olp;
        } // trivial intersection on right endpoints


        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint

        if (touchesThisRSE) return trp;
        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between
        // infinite lines laid over the segments

        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,
        // they would have an endpoint intersection and that case was already handled above

        if (pt === null) return null; // is the intersection found between the lines not on the segments?

        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed

        return rounder.round(pt.x, pt.y);
      }
      /**
       * Split the given segment into multiple segments on the given points.
       *  * Each existing segment will retain its leftSE and a new rightSE will be
       *    generated for it.
       *  * A new segment will be generated which will adopt the original segment's
       *    rightSE, and a new leftSE will be generated for it.
       *  * If there are more than two points given to split on, new segments
       *    in the middle will be generated with new leftSE and rightSE's.
       *  * An array of the newly generated SweepEvents will be returned.
       *
       * Warning: input array of points is modified
       */

    }, {
      key: "split",
      value: function split(point) {
        var newEvents = [];
        var alreadyLinked = point.events !== undefined;
        var newLeftSE = new SweepEvent(point, true);
        var newRightSE = new SweepEvent(point, false);
        var oldRightSE = this.rightSE;
        this.replaceRightSE(newRightSE);
        newEvents.push(newRightSE);
        newEvents.push(newLeftSE);
        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,
        // sometimes one of the resulting new segments is vertical, in which
        // case its left and right events may need to be swapped

        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
          newSeg.swapEvents();
        }

        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
          this.swapEvents();
        } // in the point we just used to create new sweep events with was already
        // linked to other events, we need to check if either of the affected
        // segments should be consumed


        if (alreadyLinked) {
          newLeftSE.checkForConsuming();
          newRightSE.checkForConsuming();
        }

        return newEvents;
      }
      /* Swap which event is left and right */

    }, {
      key: "swapEvents",
      value: function swapEvents() {
        var tmpEvt = this.rightSE;
        this.rightSE = this.leftSE;
        this.leftSE = tmpEvt;
        this.leftSE.isLeft = true;
        this.rightSE.isLeft = false;

        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
          this.windings[i] *= -1;
        }
      }
      /* Consume another segment. We take their rings under our wing
       * and mark them as consumed. Use for perfectly overlapping segments */

    }, {
      key: "consume",
      value: function consume(other) {
        var consumer = this;
        var consumee = other;

        while (consumer.consumedBy) {
          consumer = consumer.consumedBy;
        }

        while (consumee.consumedBy) {
          consumee = consumee.consumedBy;
        }

        var cmp = Segment.compare(consumer, consumee);
        if (cmp === 0) return; // already consumed
        // the winner of the consumption is the earlier segment
        // according to sweep line ordering

        if (cmp > 0) {
          var tmp = consumer;
          consumer = consumee;
          consumee = tmp;
        } // make sure a segment doesn't consume it's prev


        if (consumer.prev === consumee) {
          var _tmp = consumer;
          consumer = consumee;
          consumee = _tmp;
        }

        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
          var ring = consumee.rings[i];
          var winding = consumee.windings[i];
          var index = consumer.rings.indexOf(ring);

          if (index === -1) {
            consumer.rings.push(ring);
            consumer.windings.push(winding);
          } else consumer.windings[index] += winding;
        }

        consumee.rings = null;
        consumee.windings = null;
        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue

        consumee.leftSE.consumedBy = consumer.leftSE;
        consumee.rightSE.consumedBy = consumer.rightSE;
      }
      /* The first segment previous segment chain that is in the result */

    }, {
      key: "prevInResult",
      value: function prevInResult() {
        if (this._prevInResult !== undefined) return this._prevInResult;
        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
        return this._prevInResult;
      }
    }, {
      key: "beforeState",
      value: function beforeState() {
        if (this._beforeState !== undefined) return this._beforeState;
        if (!this.prev) this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };else {
          var seg = this.prev.consumedBy || this.prev;
          this._beforeState = seg.afterState();
        }
        return this._beforeState;
      }
    }, {
      key: "afterState",
      value: function afterState() {
        if (this._afterState !== undefined) return this._afterState;
        var beforeState = this.beforeState();
        this._afterState = {
          rings: beforeState.rings.slice(0),
          windings: beforeState.windings.slice(0),
          multiPolys: []
        };
        var ringsAfter = this._afterState.rings;
        var windingsAfter = this._afterState.windings;
        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter

        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
          var ring = this.rings[i];
          var winding = this.windings[i];
          var index = ringsAfter.indexOf(ring);

          if (index === -1) {
            ringsAfter.push(ring);
            windingsAfter.push(winding);
          } else windingsAfter[index] += winding;
        } // calcualte polysAfter


        var polysAfter = [];
        var polysExclude = [];

        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
          if (windingsAfter[_i] === 0) continue; // non-zero rule

          var _ring = ringsAfter[_i];
          var poly = _ring.poly;
          if (polysExclude.indexOf(poly) !== -1) continue;
          if (_ring.isExterior) polysAfter.push(poly);else {
            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);

            var _index = polysAfter.indexOf(_ring.poly);

            if (_index !== -1) polysAfter.splice(_index, 1);
          }
        } // calculate multiPolysAfter


        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
          var mp = polysAfter[_i2].multiPoly;
          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
        }

        return this._afterState;
      }
      /* Is this segment part of the final result? */

    }, {
      key: "isInResult",
      value: function isInResult() {
        // if we've been consumed, we're not in the result
        if (this.consumedBy) return false;
        if (this._isInResult !== undefined) return this._isInResult;
        var mpsBefore = this.beforeState().multiPolys;
        var mpsAfter = this.afterState().multiPolys;

        switch (operation.type) {
          case 'union':
            {
              // UNION - included iff:
              //  * On one side of us there is 0 poly interiors AND
              //  * On the other side there is 1 or more.
              var noBefores = mpsBefore.length === 0;
              var noAfters = mpsAfter.length === 0;
              this._isInResult = noBefores !== noAfters;
              break;
            }

          case 'intersection':
            {
              // INTERSECTION - included iff:
              //  * on one side of us all multipolys are rep. with poly interiors AND
              //  * on the other side of us, not all multipolys are repsented
              //    with poly interiors
              var least;
              var most;

              if (mpsBefore.length < mpsAfter.length) {
                least = mpsBefore.length;
                most = mpsAfter.length;
              } else {
                least = mpsAfter.length;
                most = mpsBefore.length;
              }

              this._isInResult = most === operation.numMultiPolys && least < most;
              break;
            }

          case 'xor':
            {
              // XOR - included iff:
              //  * the difference between the number of multipolys represented
              //    with poly interiors on our two sides is an odd number
              var diff = Math.abs(mpsBefore.length - mpsAfter.length);
              this._isInResult = diff % 2 === 1;
              break;
            }

          case 'difference':
            {
              // DIFFERENCE included iff:
              //  * on exactly one side, we have just the subject
              var isJustSubject = function isJustSubject(mps) {
                return mps.length === 1 && mps[0].isSubject;
              };

              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
              break;
            }

          default:
            throw new Error("Unrecognized operation type found ".concat(operation.type));
        }

        return this._isInResult;
      }
    }], [{
      key: "fromRing",
      value: function fromRing(pt1, pt2, ring) {
        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering

        var cmpPts = SweepEvent.comparePoints(pt1, pt2);

        if (cmpPts < 0) {
          leftPt = pt1;
          rightPt = pt2;
          winding = 1;
        } else if (cmpPts > 0) {
          leftPt = pt2;
          rightPt = pt1;
          winding = -1;
        } else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));

        var leftSE = new SweepEvent(leftPt, true);
        var rightSE = new SweepEvent(rightPt, false);
        return new Segment(leftSE, rightSE, [ring], [winding]);
      }
    }]);

    return Segment;
  }();

  var RingIn = /*#__PURE__*/function () {
    function RingIn(geomRing, poly, isExterior) {
      _classCallCheck(this, RingIn);

      if (!Array.isArray(geomRing) || geomRing.length === 0) {
        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
      }

      this.poly = poly;
      this.isExterior = isExterior;
      this.segments = [];

      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {
        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
      }

      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
      this.bbox = {
        ll: {
          x: firstPoint.x,
          y: firstPoint.y
        },
        ur: {
          x: firstPoint.x,
          y: firstPoint.y
        }
      };
      var prevPoint = firstPoint;

      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        }

        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points

        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
        this.segments.push(Segment.fromRing(prevPoint, point, this));
        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
        prevPoint = point;
      } // add segment from last to first if last is not the same as first


      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
      }
    }

    _createClass(RingIn, [{
      key: "getSweepEvents",
      value: function getSweepEvents() {
        var sweepEvents = [];

        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
          var segment = this.segments[i];
          sweepEvents.push(segment.leftSE);
          sweepEvents.push(segment.rightSE);
        }

        return sweepEvents;
      }
    }]);

    return RingIn;
  }();
  var PolyIn = /*#__PURE__*/function () {
    function PolyIn(geomPoly, multiPoly) {
      _classCallCheck(this, PolyIn);

      if (!Array.isArray(geomPoly)) {
        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
      }

      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value

      this.bbox = {
        ll: {
          x: this.exteriorRing.bbox.ll.x,
          y: this.exteriorRing.bbox.ll.y
        },
        ur: {
          x: this.exteriorRing.bbox.ur.x,
          y: this.exteriorRing.bbox.ur.y
        }
      };
      this.interiorRings = [];

      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
        var ring = new RingIn(geomPoly[i], this, false);
        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
        this.interiorRings.push(ring);
      }

      this.multiPoly = multiPoly;
    }

    _createClass(PolyIn, [{
      key: "getSweepEvents",
      value: function getSweepEvents() {
        var sweepEvents = this.exteriorRing.getSweepEvents();

        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
          var ringSweepEvents = this.interiorRings[i].getSweepEvents();

          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
            sweepEvents.push(ringSweepEvents[j]);
          }
        }

        return sweepEvents;
      }
    }]);

    return PolyIn;
  }();
  var MultiPolyIn = /*#__PURE__*/function () {
    function MultiPolyIn(geom, isSubject) {
      _classCallCheck(this, MultiPolyIn);

      if (!Array.isArray(geom)) {
        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
      }

      try {
        // if the input looks like a polygon, convert it to a multipolygon
        if (typeof geom[0][0][0] === 'number') geom = [geom];
      } catch (ex) {// The input is either malformed or has empty arrays.
        // In either case, it will be handled later on.
      }

      this.polys = [];
      this.bbox = {
        ll: {
          x: Number.POSITIVE_INFINITY,
          y: Number.POSITIVE_INFINITY
        },
        ur: {
          x: Number.NEGATIVE_INFINITY,
          y: Number.NEGATIVE_INFINITY
        }
      };

      for (var i = 0, iMax = geom.length; i < iMax; i++) {
        var poly = new PolyIn(geom[i], this);
        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
        this.polys.push(poly);
      }

      this.isSubject = isSubject;
    }

    _createClass(MultiPolyIn, [{
      key: "getSweepEvents",
      value: function getSweepEvents() {
        var sweepEvents = [];

        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
          var polySweepEvents = this.polys[i].getSweepEvents();

          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
            sweepEvents.push(polySweepEvents[j]);
          }
        }

        return sweepEvents;
      }
    }]);

    return MultiPolyIn;
  }();

  var RingOut = /*#__PURE__*/function () {
    _createClass(RingOut, null, [{
      key: "factory",

      /* Given the segments from the sweep line pass, compute & return a series
       * of closed rings from all the segments marked to be part of the result */
      value: function factory(allSegments) {
        var ringsOut = [];

        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
          var segment = allSegments[i];
          if (!segment.isInResult() || segment.ringOut) continue;
          var prevEvent = null;
          var event = segment.leftSE;
          var nextEvent = segment.rightSE;
          var events = [event];
          var startingPoint = event.point;
          var intersectionLEs = [];
          /* Walk the chain of linked events to form a closed ring */

          while (true) {
            prevEvent = event;
            event = nextEvent;
            events.push(event);
            /* Is the ring complete? */

            if (event.point === startingPoint) break;

            while (true) {
              var availableLEs = event.getAvailableLinkedEvents();
              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier
               * part of the algorithm malfunctioned... please file a bug report. */

              if (availableLEs.length === 0) {
                var firstPt = events[0].point;
                var lastPt = events[events.length - 1].point;
                throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
              }
              /* Only one way to go, so cotinue on the path */


              if (availableLEs.length === 1) {
                nextEvent = availableLEs[0].otherSE;
                break;
              }
              /* We must have an intersection. Check for a completed loop */


              var indexLE = null;

              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                if (intersectionLEs[j].point === event.point) {
                  indexLE = j;
                  break;
                }
              }
              /* Found a completed loop. Cut that off and make a ring */


              if (indexLE !== null) {
                var intersectionLE = intersectionLEs.splice(indexLE)[0];
                var ringEvents = events.splice(intersectionLE.index);
                ringEvents.unshift(ringEvents[0].otherSE);
                ringsOut.push(new RingOut(ringEvents.reverse()));
                continue;
              }
              /* register the intersection */


              intersectionLEs.push({
                index: events.length,
                point: event.point
              });
              /* Choose the left-most option to continue the walk */

              var comparator = event.getLeftmostComparator(prevEvent);
              nextEvent = availableLEs.sort(comparator)[0].otherSE;
              break;
            }
          }

          ringsOut.push(new RingOut(events));
        }

        return ringsOut;
      }
    }]);

    function RingOut(events) {
      _classCallCheck(this, RingOut);

      this.events = events;

      for (var i = 0, iMax = events.length; i < iMax; i++) {
        events[i].segment.ringOut = this;
      }

      this.poly = null;
    }

    _createClass(RingOut, [{
      key: "getGeom",
      value: function getGeom() {
        // Remove superfluous points (ie extra points along a straight line),
        var prevPt = this.events[0].point;
        var points = [prevPt];

        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
          var _pt = this.events[i].point;
          var _nextPt = this.events[i + 1].point;
          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
          points.push(_pt);
          prevPt = _pt;
        } // ring was all (within rounding error of angle calc) colinear points


        if (points.length === 1) return null; // check if the starting point is necessary

        var pt = points[0];
        var nextPt = points[1];
        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
        points.push(points[0]);
        var step = this.isExteriorRing() ? 1 : -1;
        var iStart = this.isExteriorRing() ? 0 : points.length - 1;
        var iEnd = this.isExteriorRing() ? points.length : -1;
        var orderedPoints = [];

        for (var _i = iStart; _i != iEnd; _i += step) {
          orderedPoints.push([points[_i].x, points[_i].y]);
        }

        return orderedPoints;
      }
    }, {
      key: "isExteriorRing",
      value: function isExteriorRing() {
        if (this._isExteriorRing === undefined) {
          var enclosing = this.enclosingRing();
          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
        }

        return this._isExteriorRing;
      }
    }, {
      key: "enclosingRing",
      value: function enclosingRing() {
        if (this._enclosingRing === undefined) {
          this._enclosingRing = this._calcEnclosingRing();
        }

        return this._enclosingRing;
      }
      /* Returns the ring that encloses this one, if any */

    }, {
      key: "_calcEnclosingRing",
      value: function _calcEnclosingRing() {
        // start with the ealier sweep line event so that the prevSeg
        // chain doesn't lead us inside of a loop of ours
        var leftMostEvt = this.events[0];

        for (var i = 1, iMax = this.events.length; i < iMax; i++) {
          var evt = this.events[i];
          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
        }

        var prevSeg = leftMostEvt.segment.prevInResult();
        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;

        while (true) {
          // no segment found, thus no ring can enclose us
          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev
          // segment must loop back around and enclose us

          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev
          // segment must either loop around us or the ring of the prev prev
          // seg, which would make us and the ring of the prev peers

          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
              return prevSeg.ringOut;
            } else return prevSeg.ringOut.enclosingRing();
          } // two segments are from the same ring, so this was a penisula
          // of that ring. iterate downward, keep searching


          prevSeg = prevPrevSeg.prevInResult();
          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        }
      }
    }]);

    return RingOut;
  }();
  var PolyOut = /*#__PURE__*/function () {
    function PolyOut(exteriorRing) {
      _classCallCheck(this, PolyOut);

      this.exteriorRing = exteriorRing;
      exteriorRing.poly = this;
      this.interiorRings = [];
    }

    _createClass(PolyOut, [{
      key: "addInterior",
      value: function addInterior(ring) {
        this.interiorRings.push(ring);
        ring.poly = this;
      }
    }, {
      key: "getGeom",
      value: function getGeom() {
        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points

        if (geom[0] === null) return null;

        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points

          if (ringGeom === null) continue;
          geom.push(ringGeom);
        }

        return geom;
      }
    }]);

    return PolyOut;
  }();
  var MultiPolyOut = /*#__PURE__*/function () {
    function MultiPolyOut(rings) {
      _classCallCheck(this, MultiPolyOut);

      this.rings = rings;
      this.polys = this._composePolys(rings);
    }

    _createClass(MultiPolyOut, [{
      key: "getGeom",
      value: function getGeom() {
        var geom = [];

        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points

          if (polyGeom === null) continue;
          geom.push(polyGeom);
        }

        return geom;
      }
    }, {
      key: "_composePolys",
      value: function _composePolys(rings) {
        var polys = [];

        for (var i = 0, iMax = rings.length; i < iMax; i++) {
          var ring = rings[i];
          if (ring.poly) continue;
          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
            var enclosingRing = ring.enclosingRing();
            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
            enclosingRing.poly.addInterior(ring);
          }
        }

        return polys;
      }
    }]);

    return MultiPolyOut;
  }();

  /**
   * NOTE:  We must be careful not to change any segments while
   *        they are in the SplayTree. AFAIK, there's no way to tell
   *        the tree to rebalance itself - thus before splitting
   *        a segment that's in the tree, we remove it from the tree,
   *        do the split, then re-insert it. (Even though splitting a
   *        segment *shouldn't* change its correct position in the
   *        sweep line tree, the reality is because of rounding errors,
   *        it sometimes does.)
   */

  var SweepLine = /*#__PURE__*/function () {
    function SweepLine(queue) {
      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;

      _classCallCheck(this, SweepLine);

      this.queue = queue;
      this.tree = new Tree(comparator);
      this.segments = [];
    }

    _createClass(SweepLine, [{
      key: "process",
      value: function process(event) {
        var segment = event.segment;
        var newEvents = []; // if we've already been consumed by another segment,
        // clean up our body parts and get out

        if (event.consumedBy) {
          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
          return newEvents;
        }

        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
        if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + 'in SweepLine tree. Please submit a bug report.');
        var prevNode = node;
        var nextNode = node;
        var prevSeg = undefined;
        var nextSeg = undefined; // skip consumed segments still in tree

        while (prevSeg === undefined) {
          prevNode = this.tree.prev(prevNode);
          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
        } // skip consumed segments still in tree


        while (nextSeg === undefined) {
          nextNode = this.tree.next(nextNode);
          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
        }

        if (event.isLeft) {
          // Check for intersections against the previous segment in the sweep line
          var prevMySplitter = null;

          if (prevSeg) {
            var prevInter = prevSeg.getIntersection(segment);

            if (prevInter !== null) {
              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;

              if (!prevSeg.isAnEndpoint(prevInter)) {
                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);

                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
            }
          } // Check for intersections against the next segment in the sweep line


          var nextMySplitter = null;

          if (nextSeg) {
            var nextInter = nextSeg.getIntersection(segment);

            if (nextInter !== null) {
              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;

              if (!nextSeg.isAnEndpoint(nextInter)) {
                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);

                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                  newEvents.push(_newEventsFromSplit[_i]);
                }
              }
            }
          } // For simplicity, even if we find more than one intersection we only
          // spilt on the 'earliest' (sweep-line style) of the intersections.
          // The other intersection will be handled in a future process().


          if (prevMySplitter !== null || nextMySplitter !== null) {
            var mySplitter = null;
            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
            } // Rounding errors can cause changes in ordering,
            // so remove afected segments and right sweep events before splitting

            this.queue.remove(segment.rightSE);
            newEvents.push(segment.rightSE);

            var _newEventsFromSplit2 = segment.split(mySplitter);

            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
              newEvents.push(_newEventsFromSplit2[_i2]);
            }
          }

          if (newEvents.length > 0) {
            // We found some intersections, so re-do the current event to
            // make sure sweep line ordering is totally consistent for later
            // use with the segment 'prev' pointers
            this.tree.remove(segment);
            newEvents.push(event);
          } else {
            // done with left event
            this.segments.push(segment);
            segment.prev = prevSeg;
          }
        } else {
          // event.isRight
          // since we're about to be removed from the sweep line, check for
          // intersections between our previous and next segments
          if (prevSeg && nextSeg) {
            var inter = prevSeg.getIntersection(nextSeg);

            if (inter !== null) {
              if (!prevSeg.isAnEndpoint(inter)) {
                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);

                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                  newEvents.push(_newEventsFromSplit3[_i3]);
                }
              }

              if (!nextSeg.isAnEndpoint(inter)) {
                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);

                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                  newEvents.push(_newEventsFromSplit4[_i4]);
                }
              }
            }
          }

          this.tree.remove(segment);
        }

        return newEvents;
      }
      /* Safely split a segment that is currently in the datastructures
       * IE - a segment other than the one that is currently being processed. */

    }, {
      key: "_splitSafely",
      value: function _splitSafely(seg, pt) {
        // Rounding errors can cause changes in ordering,
        // so remove afected segments and right sweep events before splitting
        // removeNode() doesn't work, so have re-find the seg
        // https://github.com/w8r/splay-tree/pull/5
        this.tree.remove(seg);
        var rightSE = seg.rightSE;
        this.queue.remove(rightSE);
        var newEvents = seg.split(pt);
        newEvents.push(rightSE); // splitting can trigger consumption

        if (seg.consumedBy === undefined) this.tree.insert(seg);
        return newEvents;
      }
    }]);

    return SweepLine;
  }();

  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && ({"NODE_ENV":"development"}).POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && ({"NODE_ENV":"development"}).POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
  var Operation = /*#__PURE__*/function () {
    function Operation() {
      _classCallCheck(this, Operation);
    }

    _createClass(Operation, [{
      key: "run",
      value: function run(type, geom, moreGeoms) {
        operation.type = type;
        rounder.reset();
        /* Convert inputs to MultiPoly objects */

        var multipolys = [new MultiPolyIn(geom, true)];

        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
          multipolys.push(new MultiPolyIn(moreGeoms[i], false));
        }

        operation.numMultiPolys = multipolys.length;
        /* BBox optimization for difference operation
         * If the bbox of a multipolygon that's part of the clipping doesn't
         * intersect the bbox of the subject at all, we can just drop that
         * multiploygon. */

        if (operation.type === 'difference') {
          // in place removal
          var subject = multipolys[0];
          var _i = 1;

          while (_i < multipolys.length) {
            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);
          }
        }
        /* BBox optimization for intersection operation
         * If we can find any pair of multipolygons whose bbox does not overlap,
         * then the result will be empty. */


        if (operation.type === 'intersection') {
          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
          //       it could be optimized to O(n * ln(n))
          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
            var mpA = multipolys[_i2];

            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
            }
          }
        }
        /* Put segment endpoints in a priority queue */


        var queue = new Tree(SweepEvent.compare);

        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
          var sweepEvents = multipolys[_i3].getSweepEvents();

          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
            queue.insert(sweepEvents[_j]);

            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
              // prevents an infinite loop, an otherwise common manifestation of bugs
              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');
            }
          }
        }
        /* Pass the sweep line over those endpoints */


        var sweepLine = new SweepLine(queue);
        var prevQueueSize = queue.size;
        var node = queue.pop();

        while (node) {
          var evt = node.key;

          if (queue.size === prevQueueSize) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            var seg = evt.segment;
            throw new Error("Unable to pop() ".concat(evt.isLeft ? 'left' : 'right', " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + 'Please file a bug report.');
          }

          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');
          }

          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
            // prevents an infinite loop, an otherwise common manifestation of bugs
            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');
          }

          var newEvents = sweepLine.process(evt);

          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
            var _evt = newEvents[_i4];
            if (_evt.consumedBy === undefined) queue.insert(_evt);
          }

          prevQueueSize = queue.size;
          node = queue.pop();
        } // free some memory we don't need anymore


        rounder.reset();
        /* Collect and compile segments we're keeping into a multipolygon */

        var ringsOut = RingOut.factory(sweepLine.segments);
        var result = new MultiPolyOut(ringsOut);
        return result.getGeom();
      }
    }]);

    return Operation;
  }(); // singleton available by import

  var operation = new Operation();

  var union = function union(geom) {
    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      moreGeoms[_key - 1] = arguments[_key];
    }

    return operation.run('union', geom, moreGeoms);
  };

  var intersection$1 = function intersection(geom) {
    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      moreGeoms[_key2 - 1] = arguments[_key2];
    }

    return operation.run('intersection', geom, moreGeoms);
  };

  var xor = function xor(geom) {
    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      moreGeoms[_key3 - 1] = arguments[_key3];
    }

    return operation.run('xor', geom, moreGeoms);
  };

  var difference = function difference(subjectGeom) {
    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      clippingGeoms[_key4 - 1] = arguments[_key4];
    }

    return operation.run('difference', subjectGeom, clippingGeoms);
  };

  var index = {
    union: union,
    intersection: intersection$1,
    xor: xor,
    difference: difference
  };

  return index;

})));


/***/ }),

/***/ "./node_modules/supercluster/dist/supercluster.js":
/*!********************************************************!*\
  !*** ./node_modules/supercluster/dist/supercluster.js ***!
  \********************************************************/
/***/ (function(module) {

(function (global, factory) {
 true ? module.exports = factory() :
0;
})(this, (function () { 'use strict';

function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) { return; }

    var m = (left + right) >> 1;

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        var t = coords[2 * k + inc];
        var i = left;
        var j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) { swapItem(ids, coords, left, right); }

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) { i++; }
            while (coords[2 * j + inc] > t) { j--; }
        }

        if (coords[2 * left + inc] === t) { swapItem(ids, coords, left, j); }
        else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var x, y;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[i]); }
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[m]); }

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function within(ids, coords, qx, qy, r, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var r2 = r * r;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) { result.push(ids[i]); }
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        var x = coords[2 * m];
        var y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) { result.push(ids[m]); }

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function sqDist(ax, ay, bx, by) {
    var dx = ax - bx;
    var dy = ay - by;
    return dx * dx + dy * dy;
}

var defaultGetX = function (p) { return p[0]; };
var defaultGetY = function (p) { return p[1]; };

var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {
    if ( getX === void 0 ) getX = defaultGetX;
    if ( getY === void 0 ) getY = defaultGetY;
    if ( nodeSize === void 0 ) nodeSize = 64;
    if ( ArrayType === void 0 ) ArrayType = Float64Array;

    this.nodeSize = nodeSize;
    this.points = points;

    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;

    var ids = this.ids = new IndexArrayType(points.length);
    var coords = this.coords = new ArrayType(points.length * 2);

    for (var i = 0; i < points.length; i++) {
        ids[i] = i;
        coords[2 * i] = getX(points[i]);
        coords[2 * i + 1] = getY(points[i]);
    }

    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
};

KDBush.prototype.range = function range$1 (minX, minY, maxX, maxY) {
    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
};

KDBush.prototype.within = function within$1 (x, y, r) {
    return within(this.ids, this.coords, x, y, r, this.nodeSize);
};

var defaultOptions = {
    minZoom: 0,   // min zoom to generate clusters on
    maxZoom: 16,  // max zoom level to cluster the points on
    minPoints: 2, // minimum points to form a cluster
    radius: 40,   // cluster radius in pixels
    extent: 512,  // tile extent (radius is calculated relative to it)
    nodeSize: 64, // size of the KD-tree leaf node, affects performance
    log: false,   // whether to log timing info

    // whether to generate numeric ids for input features (in vector tiles)
    generateId: false,

    // a reduce function for calculating custom cluster properties
    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }

    // properties to use for individual points when running the reducer
    map: function (props) { return props; } // props => ({sum: props.my_value})
};

var fround = Math.fround || (function (tmp) { return (function (x) { tmp[0] = +x; return tmp[0]; }); })(new Float32Array(1));

var Supercluster = function Supercluster(options) {
    this.options = extend(Object.create(defaultOptions), options);
    this.trees = new Array(this.options.maxZoom + 1);
};

Supercluster.prototype.load = function load (points) {
    var ref = this.options;
        var log = ref.log;
        var minZoom = ref.minZoom;
        var maxZoom = ref.maxZoom;
        var nodeSize = ref.nodeSize;

    if (log) { console.time('total time'); }

    var timerId = "prepare " + (points.length) + " points";
    if (log) { console.time(timerId); }

    this.points = points;

    // generate a cluster object for each point and index input points into a KD-tree
    var clusters = [];
    for (var i = 0; i < points.length; i++) {
        if (!points[i].geometry) { continue; }
        clusters.push(createPointCluster(points[i], i));
    }
    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

    if (log) { console.timeEnd(timerId); }

    // cluster points on max zoom, then cluster the results on previous zoom, etc.;
    // results in a cluster hierarchy across zoom levels
    for (var z = maxZoom; z >= minZoom; z--) {
        var now = +Date.now();

        // create a new set of clusters for the zoom and index them with a KD-tree
        clusters = this._cluster(clusters, z);
        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

        if (log) { console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now); }
    }

    if (log) { console.timeEnd('total time'); }

    return this;
};

Supercluster.prototype.getClusters = function getClusters (bbox, zoom) {
    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
    var minLat = Math.max(-90, Math.min(90, bbox[1]));
    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
    var maxLat = Math.max(-90, Math.min(90, bbox[3]));

    if (bbox[2] - bbox[0] >= 360) {
        minLng = -180;
        maxLng = 180;
    } else if (minLng > maxLng) {
        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
        return easternHem.concat(westernHem);
    }

    var tree = this.trees[this._limitZoom(zoom)];
    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
    var clusters = [];
    for (var i = 0, list = ids; i < list.length; i += 1) {
        var id = list[i];

            var c = tree.points[id];
        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
    }
    return clusters;
};

Supercluster.prototype.getChildren = function getChildren (clusterId) {
    var originId = this._getOriginId(clusterId);
    var originZoom = this._getOriginZoom(clusterId);
    var errorMsg = 'No cluster with the specified id.';

    var index = this.trees[originZoom];
    if (!index) { throw new Error(errorMsg); }

    var origin = index.points[originId];
    if (!origin) { throw new Error(errorMsg); }

    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
    var ids = index.within(origin.x, origin.y, r);
    var children = [];
    for (var i = 0, list = ids; i < list.length; i += 1) {
        var id = list[i];

            var c = index.points[id];
        if (c.parentId === clusterId) {
            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
        }
    }

    if (children.length === 0) { throw new Error(errorMsg); }

    return children;
};

Supercluster.prototype.getLeaves = function getLeaves (clusterId, limit, offset) {
    limit = limit || 10;
    offset = offset || 0;

    var leaves = [];
    this._appendLeaves(leaves, clusterId, limit, offset, 0);

    return leaves;
};

Supercluster.prototype.getTile = function getTile (z, x, y) {
    var tree = this.trees[this._limitZoom(z)];
    var z2 = Math.pow(2, z);
    var ref = this.options;
        var extent = ref.extent;
        var radius = ref.radius;
    var p = radius / extent;
    var top = (y - p) / z2;
    var bottom = (y + 1 + p) / z2;

    var tile = {
        features: []
    };

    this._addTileFeatures(
        tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
        tree.points, x, y, z2, tile);

    if (x === 0) {
        this._addTileFeatures(
            tree.range(1 - p / z2, top, 1, bottom),
            tree.points, z2, y, z2, tile);
    }
    if (x === z2 - 1) {
        this._addTileFeatures(
            tree.range(0, top, p / z2, bottom),
            tree.points, -1, y, z2, tile);
    }

    return tile.features.length ? tile : null;
};

Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom (clusterId) {
    var expansionZoom = this._getOriginZoom(clusterId) - 1;
    while (expansionZoom <= this.options.maxZoom) {
        var children = this.getChildren(clusterId);
        expansionZoom++;
        if (children.length !== 1) { break; }
        clusterId = children[0].properties.cluster_id;
    }
    return expansionZoom;
};

Supercluster.prototype._appendLeaves = function _appendLeaves (result, clusterId, limit, offset, skipped) {
    var children = this.getChildren(clusterId);

    for (var i = 0, list = children; i < list.length; i += 1) {
        var child = list[i];

            var props = child.properties;

        if (props && props.cluster) {
            if (skipped + props.point_count <= offset) {
                // skip the whole cluster
                skipped += props.point_count;
            } else {
                // enter the cluster
                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
                // exit the cluster
            }
        } else if (skipped < offset) {
            // skip a single point
            skipped++;
        } else {
            // add a single point
            result.push(child);
        }
        if (result.length === limit) { break; }
    }

    return skipped;
};

Supercluster.prototype._addTileFeatures = function _addTileFeatures (ids, points, x, y, z2, tile) {
    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {
        var i = list[i$1];

            var c = points[i];
        var isCluster = c.numPoints;

        var tags = (void 0), px = (void 0), py = (void 0);
        if (isCluster) {
            tags = getClusterProperties(c);
            px = c.x;
            py = c.y;
        } else {
            var p = this.points[c.index];
            tags = p.properties;
            px = lngX(p.geometry.coordinates[0]);
            py = latY(p.geometry.coordinates[1]);
        }

        var f = {
            type: 1,
            geometry: [[
                Math.round(this.options.extent * (px * z2 - x)),
                Math.round(this.options.extent * (py * z2 - y))
            ]],
            tags: tags
        };

        // assign id
        var id = (void 0);
        if (isCluster) {
            id = c.id;
        } else if (this.options.generateId) {
            // optionally generate id
            id = c.index;
        } else if (this.points[c.index].id) {
            // keep id if already assigned
            id = this.points[c.index].id;
        }

        if (id !== undefined) { f.id = id; }

        tile.features.push(f);
    }
};

Supercluster.prototype._limitZoom = function _limitZoom (z) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));
};

Supercluster.prototype._cluster = function _cluster (points, zoom) {
    var clusters = [];
    var ref = this.options;
        var radius = ref.radius;
        var extent = ref.extent;
        var reduce = ref.reduce;
        var minPoints = ref.minPoints;
    var r = radius / (extent * Math.pow(2, zoom));

    // loop through each point
    for (var i = 0; i < points.length; i++) {
        var p = points[i];
        // if we've already visited the point at this zoom level, skip it
        if (p.zoom <= zoom) { continue; }
        p.zoom = zoom;

        // find all nearby points
        var tree = this.trees[zoom + 1];
        var neighborIds = tree.within(p.x, p.y, r);

        var numPointsOrigin = p.numPoints || 1;
        var numPoints = numPointsOrigin;

        // count the number of points in a potential cluster
        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {
            var neighborId = list[i$1];

                var b = tree.points[neighborId];
            // filter out neighbors that are already processed
            if (b.zoom > zoom) { numPoints += b.numPoints || 1; }
        }

        // if there were neighbors to merge, and there are enough points to form a cluster
        if (numPoints > numPointsOrigin && numPoints >= minPoints) {
            var wx = p.x * numPointsOrigin;
            var wy = p.y * numPointsOrigin;

            var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;

            // encode both zoom and point index on which the cluster originated -- offset by total length of features
            var id = (i << 5) + (zoom + 1) + this.points.length;

            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {
                var neighborId$1 = list$1[i$2];

                    var b$1 = tree.points[neighborId$1];

                if (b$1.zoom <= zoom) { continue; }
                b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)

                var numPoints2 = b$1.numPoints || 1;
                wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center
                wy += b$1.y * numPoints2;

                b$1.parentId = id;

                if (reduce) {
                    if (!clusterProperties) { clusterProperties = this._map(p, true); }
                    reduce(clusterProperties, this._map(b$1));
                }
            }

            p.parentId = id;
            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));

        } else { // left points as unclustered
            clusters.push(p);

            if (numPoints > 1) {
                for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {
                    var neighborId$2 = list$2[i$3];

                        var b$2 = tree.points[neighborId$2];
                    if (b$2.zoom <= zoom) { continue; }
                    b$2.zoom = zoom;
                    clusters.push(b$2);
                }
            }
        }
    }

    return clusters;
};

// get index of the point from which the cluster originated
Supercluster.prototype._getOriginId = function _getOriginId (clusterId) {
    return (clusterId - this.points.length) >> 5;
};

// get zoom of the point from which the cluster originated
Supercluster.prototype._getOriginZoom = function _getOriginZoom (clusterId) {
    return (clusterId - this.points.length) % 32;
};

Supercluster.prototype._map = function _map (point, clone) {
    if (point.numPoints) {
        return clone ? extend({}, point.properties) : point.properties;
    }
    var original = this.points[point.index].properties;
    var result = this.options.map(original);
    return clone && result === original ? extend({}, result) : result;
};

function createCluster(x, y, id, numPoints, properties) {
    return {
        x: fround(x), // weighted cluster center; round for consistency with Float32Array index
        y: fround(y),
        zoom: Infinity, // the last zoom the cluster was processed at
        id: id, // encodes index of the first child of the cluster and its zoom level
        parentId: -1, // parent cluster id
        numPoints: numPoints,
        properties: properties
    };
}

function createPointCluster(p, id) {
    var ref = p.geometry.coordinates;
    var x = ref[0];
    var y = ref[1];
    return {
        x: fround(lngX(x)), // projected point coordinates
        y: fround(latY(y)),
        zoom: Infinity, // the last zoom the point was processed at
        index: id, // index of the source feature in the original input array,
        parentId: -1 // parent cluster id
    };
}

function getClusterJSON(cluster) {
    return {
        type: 'Feature',
        id: cluster.id,
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.x), yLat(cluster.y)]
        }
    };
}

function getClusterProperties(cluster) {
    var count = cluster.numPoints;
    var abbrev =
        count >= 10000 ? ((Math.round(count / 1000)) + "k") :
        count >= 1000 ? ((Math.round(count / 100) / 10) + "k") : count;
    return extend(extend({}, cluster.properties), {
        cluster: true,
        cluster_id: cluster.id,
        point_count: count,
        point_count_abbreviated: abbrev
    });
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    var sin = Math.sin(lat * Math.PI / 180);
    var y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 : y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    var y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

function extend(dest, src) {
    for (var id in src) { dest[id] = src[id]; }
    return dest;
}

function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}

return Supercluster;

}));


/***/ }),

/***/ "./node_modules/wgs84/index.js":
/*!*************************************!*\
  !*** ./node_modules/wgs84/index.js ***!
  \*************************************/
/***/ (function(module) {

module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;


/***/ })

}]);